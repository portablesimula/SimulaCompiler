Module MASSAGE("iAPX");
begin
%+A   insert SCOMN,SKNWN,SBASE,ASMLIST,COASM;
%-A   insert SCOMN,SKNWN,SBASE,COASM;
       -----------------------------------------------------------------
       ---  COPYRIGHT 1988 by                                        ---
       ---  Simula a.s.                                              ---
       ---  Oslo, Norway                                             ---
       ---                                                           ---
       ---                                                           ---
       ---              P O R T A B L E     S I M U L A              ---
       ---                                                           ---
       ---                   F O R    I B M    P C                   ---
       ---                                                           ---
       ---                                                           ---
       ---           S   -   C   O   M   P   I   L   E   R           ---
       ---                                                           ---
       ---              M a s s a g e   R o u t i n e s              ---
       ---                                                           ---
       ---                                                           ---
       ---  Selection Switches:                                      ---
       ---                                                           ---
       ---     A - Includes Assembly Output                          ---
       ---     C - Includes Consistency Checks                       ---
       ---     D - Includes Tracing Dumps                            ---
       ---     S - Includes System Generation                        ---
       ---     E - Extended mode -- 32-bit 386                       ---
       -----------------------------------------------------------------

Define qSP_ = 16383; -- 3FFF Hex = 37777oct=011 111 111 111 111

Macro OprEQ(2);
begin
%-V %+E    (%1 = %2)
%-V %-E    OprEQUAL(%1,%2)
%+V        (%1 = %2)
endmacro;

Macro OprNE(2);
begin
%-V %+E    (%1 <> %2)
%-V %-E    OprNotEQUAL(%1,%2)
%+V        (%1 <> %2)
endmacro;

macro OprRegs(1);
begin
%-E   getOprRegs( %1 .sbireg)
%+E   getOprRegs( %1        )
endmacro;

%-D macro mPOPK(1);
%-D begin -- NB: ref(Qpkt) b;
%-D       b:=findPush2(%1);  --- FindPush(%1);
%-D       if b <> none
%-D       then
%-D            DeleteQinstr(%1); RepDelete(b);
%-D       endif;
%-D endmacro ; -- POPK

%-D macro findPush(1);
%-D begin findPush2(%1) endmacro;

-- Declared in 'scomn.def':
-- Range(0:255) RecDepth;  -- Current Masseur recursion depth left
-- Boolean DeadCode; -- initial false
-- Boolean Changeable;
-- short integer stackMod1, stackMod2;

Boolean trial,success;  -- initial (false,false)
Boolean EvalSeen,CallSeen; -- evalseen not used

%+D const infix(string) qINSTRname(65)= ("q0????",
%+D     "WAIT  ","EVAL  ","TSTOFL","LAHF  ","SAHF  ","CWD   ","FDUP  ","IRET  ",
%+D     "DOS2  ","FLDCK ","FMONAD","FDYAD ","FPUSH ","FPOP  ","PUSHR ","POPR  ",
%+D     "RSTRB ","RSTRW ","MONADR","TRIADR","CONDEC","MOV   ","XCHG  ","DYADR ",
%+D     "SHIFT ","POPK  ","RET   ","INT   ","ADJST ","ENTER ","LEAVE ","      ",
%+D %-E "DYADC ","LOADSC","PUSHC ","LOADC ","JMPM  ","JMPFM ","q39???","PUSHA ",
%+D %+E "DYADC ","q34???","PUSHC ","LOADC ","JMPM  ","q38???","BOUND ","PUSHA ",
%+D     "LOADA ","STORE ","XCHGM ","FLD   ","FLDC  ","FST   ","FSTP  ","DYADM ",
%+D %-E "DYADMR","MONADM","TRIADM","LOAD  ","LDS   ","LES   ","FDYADM","PUSHM ",
%+D %+E "DYADMR","MONADM","TRIADM","LOAD  ","q53???","q54???","FDYADM","PUSHM ",
%+D     "POPM  ","MOVMC ","DYADMC","CALL  ","JMP   ","FDEST ","BDEST ","LABEL ")
%page

%+D Routine ReMasseur; import ref(Qpkt) qi;
%+D begin 
%+D       if listq1 > 1 then ListQinstr("ReMass:   ",qi,false) endif;
%+D       Masseur(qi);
%+D end;

%-D macro ReMasseur(1);
%-D begin Masseur(%1) endmacro;

%+D Routine RepMasseur; import ref(Qpkt) qi;
%+D begin ref(Qpkt) ReMaX,ReMaY;
%+D   if listq1 > 1
%+D   then ReMaX:=qi; ListQinstr("RepMass:  ",ReMaX,false);
%+D        repeat ReMaX:=ReMaX.next while ReMaX <> none
%+D        do ListQinstr("RepMass:  ",ReMaX,false);
%+D           if ReMaX=qi then IERR("RepMasseur: LOOP in queue");
%+D              goto E endif;
%+D        endrepeat;
%+D   endif;
%+D       ReMaX:=qi; repeat ReMaY:=ReMaX.next;
%+D         if listq1>1 then ListQinstr("ReMASS:   ",ReMaX,false) endif;
%+D         Masseur(ReMaX);
%+D       while ReMaY <> none do ReMaX:=ReMaY endrepeat;
%+D E:
%+D end;

%-D Macro RepMasseur(1)
%-D begin ReMaX:=%1;
%-D       repeat ReMaY:=ReMaX.next; Masseur(ReMaX); ReMaX:=ReMaY;
%-D       while ReMaY <> none do endrepeat;
%-D endmacro;

macro DOMASSAGE(0)
begin
      case 0:qMXX (qi .fnc)
      ----  K_Qfrm1 **********************************************
      when qFDYAD:
%+E        if NUMID <> WTLx167 then
              if MASSLV > 19 then mFDYAD(qi)      endif
%+E        endif
      when qFPOP:        if MASSLV > 18 then mFPOP(qi)       endif
%+S   when qPUSHR:       if MASSLV >  1 then mPUSHR(qi)      endif
%-S   when qPUSHR:                           mPUSHR(qi)
%+S   when qPOPR:        if MASSLV >  4 then mPOPR(qi)       endif
%-S   when qPOPR:                            mPOPR(qi)
%+C   when qWAIT, qEVAL, qTSTOFL, qLAHF,  qSAHF, qCWD,    -- nothing
%+C        qFDUP, qIRET, qDOS2, qFLDCK, qFMONAD, qFPUSH:  -- nothing
      ---- K_Qfrm2 , K_Qfrm2b ************************************
      when qMONADR:      if MASSLV > 12 then mMONADR(qi)     endif
      when qTRIADR:      if MASSLV > 15 then mTRIADR(qi)     endif
      when qCONDEC:      if MASSLV > 20 then mCondition(qi)  endif
      when qMOV:         if MASSLV > 10 then mMOV(qi)        endif
      when qDYADR:       if MASSLV > 13 then mDYADR(qi)      endif
%+S   when qPOPK:        if MASSLV >  3 then mPOPK(qi)       endif
%-S   when qPOPK:                            mPOPK(qi)
      when qDYADC:    if qi . kind <> K_Qfrm2b then
                         if MASSLV > 14 then mDYADC(qi)      endif endif
%+S %-E   when qLOADSC:  if MASSLV >  7 then mLOADSC(qi)     endif
%+S       when qLOADC:   if MASSLV >  6 then mLOADC(qi)      endif
%-S %-E   when qLOADSC:                      mLOADSC(qi)
%-S       when qLOADC:                       mLOADC(qi)
%+C   when qRSTRB, qRSTRW, qXCHG, qSHIFT,  qRET,   qINT,  -- nothing
%+C        qADJST, qENTER, qLEAVE, qLINE, qPUSHC:         -- nothing
      ----  K_Qfrm3  ----  mOPR except for FLDC ******************
%+S   when qLOADA:  mOPR(qi); if MASSLV >  9 then mLOADA(qi)  endif
%-S   when qLOADA:  mOPR(qi);                     mLOADA(qi)
      when qSTORE:  mOPR(qi); if MASSLV > 11 then mSTORE(qi)  endif
      when qTRIADM: mOPR(qi); if MASSLV > 16 then mTRIADM(qi) endif
%+C   when qFLDC:           -- nothing
      when qJMPM, qPUSHA, qXCHGM,  qFLD, qFST, qFSTP, qDYADM,
%-E        qJMPFM,
%+E        qBOUND,
           qDYADMR, qMONADM,
      ---- K_Qfrm4 , K_Qfrm4b, K_Qfrm4c  ---- mOPR for all *******
           qFDYADM, qPUSHM, qMOVMC, qDYADMC:  mOPR(qi)
%+S   when qLOAD:   mOPR(qi); if MASSLV >  8 then mLOAD(qi)  endif
%-S   when qLOAD:   mOPR(qi);                     mLOAD(qi)
%-E   when qLDS,
%-E        qLES:    mOPR(qi); if MASSLV > 30 then mLSR(qi)   endif
%+S   when qPOPM:   mOPR(qi); if MASSLV >  5 then mPOPM(qi)  endif
%-S   when qPOPM:   mOPR(qi);                     mPOPM(qi)
      ----  K_Qfrm5 **********************************************
      when qJMP:         if MASSLV > 20 then mCondition(qi)  endif
%+C   when qCALL:           -- nothing
      ----  K_Qfrm6 **********************************************
      when qFDEST:       if MASSLV > 21 then mFDEST(qi)      endif
%+C   when qBDEST, qLABEL:  -- nothing
%+C   otherwise IERR("Wrong Qcode.fnc in Masseur");
      endcase
endmacro

Routine Masseur; import ref(Qpkt) qi;
begin -- range(0:MaxByte) kind,fnc;
      ref(Qpkt) b; -- for inline mPOPK
      RecDepth:=RecDepth-1;
      if RecDepth = 0
      then
%+D        WARNING("Masseur: Recursion overflow");
           goto E;
      endif;
%+D   RST(R_Massage);
%+D   if (MASSDP-RecDepth) > 8
%+D   then edwrd(errmsg,MASSDP-RecDepth); WARNING("Masseur: RecDepth=") endif;

      DOMASSAGE -- (qi);

E:    RecDepth:=RecDepth+1;
end;
%title ********   Peephole optimizer and exhaust   ****************

-------------------------   N O T E   ----------------------------------
-- There is a problem with moving LABELs if they hava
-- been referred in already exhausted code. This manifests only if a
-- partial exhaust has been performed. The variable 'deleteOK' keeps track
-- of this. If this is false no iCode producing Qinstructions may be
-- deleted or changed to avoid possible changes in the LABEL address.
-- NB: Since only FULL exhaust, or FIRST partial exhaust, are handled, BDESTs
--     and FJUMPs can NEVER be exhausted when examined here!!! Consequently,
--     tests for that are NOT performed.
------------------------------------------------------------------------

visible routine peepExhaust; import boolean all;
begin ref(Qpkt) qi,qn,qnext,qx,qy,qz; range(0:qMXX) fnc; range(0:255) cond;
      boolean push0,reverse; range(0:nregs) qreg;
      ref(Qfrm4c) firstLDS; infix(memAddr) LDSopr; range(0:maxword) rmask;
      range(0:maxword) LDSoprRegs;
%-E   boolean deletemark;
      ref(Qfrm6) qdest; ref(Qfrm5) jmp; infix(word) fix;
%+D   range(0:maxword) count; range(0:10) old1;
%+D   range(0:maxword) xxx,yyy,zzz,ldd,ppp;
%+S   range(0:nregs) r2; range(0:255) AO, andor; range(0:maxword) n;
      qnext:=qfirst;
      if not deleteOK
%-S                   or (qcount<20)
      then goto E0 endif
%+S   if qnext=none then outstring("empty Qbuffer!"); outimage; goto E1 endif
%+D   xxx:=yyy:=zzz:=ldd:=ppp:=0; count:=if all then qcount else qcount/2;
%+D   old1:=listq1; if TLIST>listq1 then listq1:=TLIST endif;
%+D   if listq1 > 1 then outstring("---- peephole, count: ");
%+D                      outint(count); outimage;
%+D        qi:=qnext;
%+D        repeat while qi<>none
%+D        do ListQinstr(qINSTRname(qi.fnc),qi,false); qi:=qi.next endrepeat
%+D        outstring("---- start -----------------------"); outimage;
%+D   endif
      firstLDS:=none;
%-E   deletemark:=false;
      repeat qi:=qnext; A1:A2:A3:A4: qnext:=qi.next
      while qnext<>none
      do case 0:qMXX (qi.fnc)
------------------------------------------------------------------------
-- remove "dead jumps" (may result from FDEST moving)
------------------------------------------------------------------------
--    <nonjump>               <nonjump>             o no conditional JMP
--   {JMP 0 di}*              JMP 0 d1
--    JMP 0 x           -->   |
------------------------------------------------------------------------
-- invert cond. jump (may result from PUSHC AL,255 removal)
------------------------------------------------------------------------
--    JMP subc y              JMP not(subc) x
--    JMP 0 x           -->   |
--    FDEST y                 |
------------------------------------------------------------------------
         when qJMP:
              --- dead jump deletion ---
              qn:=qi.pred;
         L0:  if qn=none then
              elsif qn.fnc<>qJMP 
              then if qn.fnc=qLINE then qn:=qn.pred; goto L0 endif
              elsif qn.subc=0
              then -- if qnext=qi qua Qfrm5.dst
                   -- then qnext:=qnext.next endif
                   deleteJMP(qi);
%+D                yyy:=yyy+1;
                   qi:=qn.next; if qi=none then goto E2 endif
                   goto A1;
              elsif qi.subc=0 -- cond. jmp (qn) followed by jmp
              then if qn qua Qfrm5.dst=qnext
                   then qi.subc:=notQcond(qn.subc); deleteJMP(qn);
%+D                     yyy:=yyy+1;
                        goto A2;
                   endif;
              endif
-------------------- 16 BIT MODE ONLY ----------------------------------
--- MARK LDS after FDEST for later deletion (NOTE: subc used !!!)     --
------------------------------------------------------------------------
%-E           if firstLDS<>none
%-E           then
%-E                qdest:=qi qua Qfrm5.dst;
%-E                if qdest=none then
%-E                elsif qdest.fnc=qFDEST
%-E                then jmp:=qdest.pred;
%-E                     repeat while jmp.fnc=qLINE
%-E                     do jmp:=jmp.pred endrepeat
%-E                     if jmp.fnc<>qJMP then
%-E                     elsif jmp.subc=0
%-E                     then qn:=qdest.next;
%-E                          repeat if qn=none then goto JMP1 endif;
%-E      --- below OK ???    while qn.fnc=qLINE do qn:=qn.next endrepeat
%-E                          while wAND(LDSoprRegs,qn.write)=0
%-E                          do qn:=qn.next endrepeat
%-E                          if qn.fnc<>qLDS                             then
%-E                          elsif firstLDS.aux <>qn qua Qfrm4c.aux      then
%-E                          elsif qn qua Qfrm4c.nrep<>firstLDS.nrep     then
%-E                          elsif firstLDS.reg <>qn.reg                 then
%-E                          elsif OprNE(LDSopr,qn qua Qfrm4c.opr)       then
%-E                          elsif sameLOAD(firstLDS,qi,LDSoprRegs)
%-E                          then qn.subc:=1 endif
%-E                     endif
%-E                endif;  JMP1:
%-E                if qi.subc=0 then goto N9 endif
%-E           endif;
%+E           if qi.subc=0 then firstLDS:=none endif;

------------------------------------------------------------------------
-- remove superfluous LDS/LOAD (should have been done in masseur???)
-------------------- 16 BIT MODE ONLY ----------------------------------
-- NOTE: subc used as marker !!!!
-- b: LDS r opr nrep ofst     LDS r opr nrep ofst   o r unmodified <b,a>
--    .                  -->  .                     o sr unmodified <b,a>
--    .                       .                     o R(opr) unmodified [b,a>
-- a: LDS r opr nrep ofst     |                     o a.opr=b.opr
--                                                  o a.nrep=b.nrep
--                                                  o a.ofst=b.ofst
--    .                                             o M(opr) unmodified <b,a>
-------------------- 32 BIT MODE ONLY ----------------------------------
-- b: LOAD EBX opr nrep ofst  LOAD EBX opr nrep ofst o EBX unmodified <b,a>
--    .                  -->  .                      o
--    .                       .                      o R(opr) unmodified [b,a>
-- a: LOAD EBX opr nrep ofst  |                      o a.opr=b.opr
--                                                   o a.nrep=b.nrep
--                                                   o a.ofst=b.ofst
--    .                                              o M(opr) unmodified <b,a>
------------------------------------------------------------------------
%-E      when qLDS:
%+E      when qLOAD: if qi.reg <> qEBX then goto Nx4 endif
              if firstLDS=none then goto LDS1
              elsif firstLDS.aux <>qi qua Qfrm4c.aux      then ---
%+E           elsif firstLDS.subc<>qi.subc                then ---
              elsif qi qua Qfrm4c.nrep<>firstLDS.nrep     then ---
%-E           elsif firstLDS.reg <>qi.reg                 then ---
%-E           elsif qi.subc<>0                            then ---
              elsif OprNE(LDSopr,qi qua Qfrm4c.opr)       then ---
              elsif sameLOAD(firstLDS,qi,LDSoprRegs)
              then deleteQinstr(qi); qnext:=qnext.pred;
%+D                ldd:=ldd+1;
%+E                jmp:=qnext;
%+E                if jmp.fnc=qJMP -- we know it must have subc<>0
%+E                then qdest:=jmp.dst;
%+E                     if qdest<>none then if qdest.fnc=qFDEST
%+E                     then jmp:=qdest.pred; qn:=qdest.next;
%+E                          repeat while jmp.fnc=qLINE
%+E                          do jmp:=jmp.pred endrepeat
%+E                          if jmp.fnc=qJMP and (jmp.subc=0)
%+E                          then qn:=qdest.next;
%+E                               repeat if qn=none then goto Nx1 endif;
%+E                               while qn.fnc=qLINE do qn:=qn.next endrepeat
%+E                               if QinstrEqual(firstLDS,qn)
%+E                               then deleteQinstr(qn)
%+DE                                   ldd:=ldd+1;
%+E                               endif
%+E                          endif
%+E                     endif endif
%+E                endif
                   goto N0;
              endif
%-E           if deletemark then deleteQinstr(firstLDS);
%-E %+D          ldd:=ldd+1;
%-E           endif
      LDS1:   LDSopr:=qi qua Qfrm4c.opr; LDSoprRegs:=OprRegs(LDSopr);
%-E           rmask:=umask(qi.reg); deletemark:=false;
%+E           rmask:=uEBX
              if wAND(LDSoprRegs,rmask)<>0 then firstLDS:=none
              else
%-E                if qi.subc<>0 then qi.subc:=0; deletemark:=true endif;
%-E                LDSoprRegs:=wOR(LDSoprRegs,wOR(rmask,uDS));
%+E                LDSoprRegs:=wOR(LDSoprRegs,uEBX);
                   firstLDS:=qi;
              endif

         when qFDEST:
              jmp:=qi qua Qfrm6.jmp;
------------------------------------------------------------------------
-- remove "jump $+1" (may result from other optimisations)
------------------------------------------------------------------------
--    FJMP  a                 |
--      .                     .                     o DEST/LABEL/LINE only
--    FDEST a                 |
------------------------------------------------------------------------
              qn:=jmp;
              repeat qn:=qn.next while qn<>qi
              do case 0:qMXX (qn.fnc)
                 when qFDEST, qBDEST, qLABEL, qLINE: -- OK
                 otherwise goto C1 endcase
              endrepeat;
%+D           yyy:=yyy+1;
              qi:=jmp.pred; deleteJMP(jmp); goto A4;
------------------------------------------------------------------------
-- resolve "jump to jump" (speed optim., same Qcode length) by moving
-- the jump destination. 
-- only FDEST considered. If moved backwards, FDEST changed to BDEST
------------------------------------------------------------------------
--    FJMP  a                 FJMP  a  /  JMP 0 a
--      .                     .
--    FDEST a                 | - moved after 'x'
--    JMP 0 x           -->   JMP 0 x
------------------------------------------------------------------------
      C1:     qn:=qnext;
              repeat
                 case 0:qMXX (qn.fnc)
                 when qJMP:
                      if qn.subc=0
                      then qdest:=qn qua Qfrm5.dst;
                           -- qdest=none: JUMP to address/LABEL
                           if qdest<>none
                           then if    qdest.fnc=qFDEST then goto C3
                                elsif qdest.fnc=qBDEST
                                then possBJMP(jmp,qn); goto C2 endif
                           endif
                      endif
                      goto N5;
                 when qFDEST, qBDEST, qLABEL: -- OK
                 when qLINE: if  DEBMOD>2 then goto N6 endif
                 otherwise goto N7 endcase;
                 qn:=qn.next
              while qn<>none do endrepeat; goto N8;
      C2:C3:  -- move AFTER if possible (to treat it again)
         M2:  qx:=qdest.next; if qx=none then qx:=qdest endif;
              moveQinstr(qi,qx)
%+D           xxx:=xxx+1;

         when qLABEL:
              qn:=qnext;
              repeat
                 case 0:qMXX (qn.fnc)
                 when qJMP:
                      if qn.subc=0
                      then qdest:=qn qua Qfrm5.dst;
                           -- qdest=none: JUMP to address/LABEL
                           -- qdest=qn: FJUMP to ungenerated FDEST
                           if qdest=none then elsif qdest<>qn
                           then goto M2 endif
                      endif
                      goto N1;
                 when qFDEST, qBDEST, qLABEL: -- OK
                 when qLINE: if  DEBMOD>2 then goto N2 endif
                 otherwise goto N3 endcase;
                 qn:=qn.next
              while qn<>none do endrepeat;
              goto N4;

         when qBDEST,qCALL,qJMPM: -- turn off firstLDS
   N1:N2:N3:N4:N5:N6:N7:N8:N9:
%-E   N10:    if firstLDS<>none
%-E           then
%-E                if deleteMark then deleteQinstr(firstLDS)
%-E %+D               ldd:=ldd+1;
%-E           endif endif;
              firstLDS:=none;

%-E      when qLOADSC: if qi.subc=qDS then goto N10 endif

         when qPUSHC:
------------------------------------------------------------------------
-- simplify code from relations
------------------------------------------------------------------------
--qi    PUSHC reg,255           |
--qnext FJMP  x                 FJMP  x
--      .                       .
--qdest FDEST x    ----\        |
--      POPR  reg      |        POPR  reg
--      CMP   reg,0    |        CMP   reg,0
--qn    JMP   ccc,y    |        JMP   ccc,y
--      |              ?-->    {FDEST x}             o - if ccc=xEQ
--      .              :        .
--      DEST y         :        DEST y               o (may be BDEST)
--      |              ?-->    {FDEST x}             o - if ccc=xNE
------------------------------------------------------------------------
--     {PUSHR  reg}             |
--      JMP    a                |
--qdest FDEST  b     --\        |
--qi    PUSHC  reg,0   !        |
--      FDEST  a       !        |
--     {POPR   reg}    !        |
--      CMP    reg,0   !        CMP   reg,0
--qn    JMP    ccc,dst !        JMP   ccc,dst
--      |              ?-->    {FDEST b}             o - if ccc=xNE
--      .              :        .
--      DEST dst       :        DEST  dst            o (may be BDEST)
--      |              ?-->    {FDEST b}             o - if ccc=xEQ
------------------------------------------------------------------------

              -- if qi.reg<>qAL then goto Np2 endif;
              if qi.kind<>K_Qfrm2 then goto Np3 endif;         -- PUSHC AL,
              qreg:=qi.reg;
              if qnext.fnc=qFDEST
              then if qi qua Qfrm2.aux.val<>0 then goto Np19 endif;     ---0
                   qdest:=qi.pred; if qdest=none then goto Np20 endif
                   qx:=qnext.next; if qx=none then goto Np21 endif
                   jmp:=qdest.pred; if jmp=none then goto Np22 endif
                   if jmp.fnc<>qJMP then goto Np2
                   elsif jmp.subc<>0 then goto Np23 endif
                   jmp:=qnext qua Qfrm6.jmp;
                   push0:=true;
              elsif qnext.fnc=qJMP
              then if qi qua Qfrm2.aux.val<>255 then goto Np1 endif;    ---255
                   if qnext.subc<>0 then goto Np5 endif;            -- FJUMP x
                   qdest:=qnext qua Qfrm5.dst; if qdest=none then goto Np6 endif
                   qx:=qdest.next; if qx=none then goto Np8 endif
                   push0:=false;
              else goto Np4 endif
              if qdest.fnc<>qFDEST then goto Np7 endif         -- FDEST x
              if qx.fnc<>qPOPR then goto Np9 endif
              if qx.subc<>qreg then goto Np10 endif             -- POPR  AL
              qn:=qx.next; if qn=none then goto Np11 endif;    -- keep it in qx!
              if qn.reg<>qreg then goto Np12 endif
              if qn.subc<>qCMP then goto Np13 endif
              if qn.fnc<>qDYADC then goto Np14 endif
              if qn qua Qfrm2.aux.val<>0 then goto Np15 endif  -- CMP  AL,0
              qn:=qn.next; if qn=none then goto Np16 endif
              if qn.fnc<>qJMP then goto Np17 endif
              cond:=qn.subc; if push0 then cond:=notQcond(cond) endif
              if cond=q_wEQ                                 -- JMP  wEQ,y
              then qn:=qn.next; if qn=none then goto Np18 endif
        P1:        moveQinstr(qdest,qn); deleteQinstr(qi);
%+D                ppp:=ppp+1
                   if push0
                   then if jmp=qnext.pred
                        then deleteJMP(jmp); qnext:=qx.next
%+D                          yyy:=yyy+1;
                   endif endif
------------------------------------------------------------------------
--    PUSHR AL                |       
--    POPR  AL                |       
------------------------------------------------------------------------
                   qn:=qx.pred;
                   if qn.fnc<>qPUSHR then
                   elsif qn.subc=qreg
                   then deleteQinstr(qn); deleteQinstr(qx);
%+D                     ppp:=ppp+2
                   endif
                   qn:=qnext.pred; 
                   repeat while qn<>none
                   do qi:=qn; fnc:=qn.fnc;
                      if    fnc=qFDEST then qn:=qn.pred
                      elsif fnc=qLABEL then qn:=qn.pred
                      elsif fnc=qLINE  then qn:=qn.pred
                      else goto A3 endif;
                   endrepeat;
              elsif cond=q_wNE                              -- JMP  wNE,y
              then qy:=qn qua Qfrm5.dst;
                   if qy=none then
                   elsif qy=qn then
                   else if qy.fnc=qBDEST then possBJMP(qdest.jmp,qn) endif
                        qn:=qy; goto P1
                   endif
              endif

         when qCONDEC:
------------------------------------------------------------------------
-- simplify code from relations
------------------------------------------------------------------------
--qn  LOADC  reg,0            |
--qi  CONDEC subc,reg         |
--nxt CMP    reg,val          |                     o val=0 or 255
--qx  JMP    xxx,dst          JMP   ccc,dst         o ccc=subc if xxx=wNE
--    .                       .                     o    =not(subc) if wEQ
------------------------------------------------------------------------
-- SYSGEN ONLY: simplify code from Simuletta bool.expr.
------------------------------------------------------------------------
--qn  LOADC  reg,0            |
--qi  CONDEC sub1,reg         JMP   sub1,dst        o subc inverted if JMP wEQ
--  .............................................
--qy: CMP    .....            CMP   ......      :
--  : LOADC  r2,0             |                 :
--  : CONDEC sub2,r2          JMP   sub2,newdst :   o subc inverted if JMP wEQ
--  : AND    reg,r2           |                 :
--  :...........................................:*   - may be repeated
--nxt CMP    reg,255          |
--qx  JMP    wNE,dst          |                     o - or wEQ
--    .                       .
--    FDEST  dst              FDEST  dst
--    |                       FDEST  newdst
------------------------------------------------------------------------
              cond:=qi.subc; qreg:=qi.reg;
              qn:=qi.pred; if qn=none then goto Nc11 endif
              if qn.fnc<>qLOADC then goto Nc6 endif
              if qn.kind<>K_Qfrm2 then goto Nc7 endif
              if qn qua Qfrm2.aux.val<>0 then goto Nc8 endif     -- LOADC AL,0
              if qn.reg<>qreg then goto Nc2 endif
              qx:=qy:=qnext;

%+S           andor:=0; n:=0;
%+S           if (SYSGEN<>0) and all then
%+S           repeat qz:=qnext:=qx;

%+S              if andor=255 then goto Y0 endif
%+S %+D          if listq1 > 1 then ListQinstr("condecAO: ",qz,false) endif;
%+S %-E          repeat while (qz.fnc=qLDS) or (qz.fnc=qLOAD)
%+S %+E          repeat while qz.fnc=qLOAD
%+S              do qz:=qz.next; if qz=none then goto Y1 endif endrepeat
%+S              if qz.subc<>qCMP then goto Y2 endif
%+S ---   if qz.fnc<>qDYADC and (qz.fnc<>qDYADM) and (qz.fnc<>qDYADMR)
%+S ---      and (qz.fnc<>qDYADR) and (qz.fnc<>qDYADC) and (qz.fnc<>qDYADMC)
%+S ---   then goto Y2 endif
%+S              qz:=qz.next; if qz=none then goto Y3 endif
%+S              if qz.fnc<>qLOADC then goto Y4 endif
%+S              if qz.kind<>K_Qfrm2 then goto Y5 endif
%+S              if qz qua Qfrm2.aux.val<>0 then goto Y6 endif
%+S              r2:=qz.reg; qz:=qz.next; if qz=none then goto Y7 endif
%+S              if qz.fnc<>qCONDEC then goto Y8 endif
%+S              if qz.reg<>r2 then goto Y9 endif
%+S              qz:=qz.next; if qz=none then goto Y10 endif
%+S              if qz.fnc<>qDYADR then goto Y11 endif
%+S              if qz.subc=qAND
%+S              then if andor=qOR then andor:=255; goto Y16 endif; AO:=qAND;
%+S              elsif qz.subc=qOR
%+S              then if andor=qAND then andor:=255; goto Y17 endif; AO:=qOR;
%+S              else goto Y12 endif
%+S              if qz qua Qfrm2.aux.val<>r2 then goto Y13 endif
%+S              if qz.reg<>qreg then goto Y14 endif
%+S              qz:=qz.next; if qz=none then goto Y15 endif
%+S %+D          if listq1 > 1 then ListQinstr("-- found: ",qz,false) endif;
%+S              qx:=qz; andor:=AO;
%+S Y0:Y1:Y2:Y3:Y4:Y5:Y6:Y7:Y8:Y9:Y10:Y11:Y12:Y13:Y14:Y15:Y16:Y17:
%+S           while qx<>qnext do n:=n+1 endrepeat endif

              if qnext.subc<>qCMP then goto Nc3 endif
              if qnext.fnc<>qDYADC then goto Nc4 endif
              if qnext.reg<>qreg then goto Nc1 endif
              if    qnext qua Qfrm2.aux.val=0   then reverse:=false
%+S              if andor<>0 then goto Nc17 endif -- cant handle that
              elsif qnext qua Qfrm2.aux.val=255 then reverse:=true
              else goto Nc5 endif;
              qx:=qnext.next;
              if qx.fnc<>qJMP then goto Nc9 endif
              if    qx.subc=q_wEQ then reverse:=not reverse
              elsif qx.subc=q_wNE then -- qx.subc:=         qi.subc
              else goto Nc10 endif

%+S           if andor<>0
%+S           then if andor=255 then goto Nc15 endif -- mix of AND and OR
%+S                qdest:=qx qua Qfrm5.dst;
%+S                if qdest=none then goto Nc13 endif
%+S                if qdest.fnc<>qFDEST then goto Nc14 endif
%+S           ---  deleteLOAD(qx.next);
%+S                if andor=qAND
%+S                then reverse:=true;
%+S                     if qx.subc=q_wEQ then qdest:=qx.next; qx.subc:=0
%+S
%+S                     else qdest:=qdest.next;
%+S                          if qdest=none then goto Nc16 endif
%+S                          deleteJMP(qx) endif
%+S                else reverse:=false;
%+S                     if qx.subc<>q_wEQ then qdest:=qx.next; qx.subc:=0
%+S                     else qdest:=qdest.next;
%+S                          if qdest=none then goto Nc18 endif
%+S                          deleteJMP(qx) endif
%+S                endif
%+S                insertFJUMP(if reverse then notQcond(qi.subc)
%+S                            else qi.subc,qn,qdest); qx:=qn.pred;
%+S                repeat while n<>0
%+S                do n:=n-1;
%+S                   -- skip pointer/register load, set qy at CMP
%+S %-E               repeat while qy.fnc=qLDS or (qy.fnc=qLOAD)
%+S %+E               repeat while qy.fnc=qLOAD
%+S                   do qy:=qy.next endrepeat
%+S                   deleteQinstr(qy.next); -- LOADC
%+S                   insertFJUMP(if reverse then notQcond(qy.next.subc)
%+S                               else qy.next.subc,qy.next,qdest);
%+S                   qy:=qy.next;
%+S                   deleteQinstr(qy.next); -- CONDEC
%+S                   deleteQinstr(qy.next); -- AND/OR
%+S %+D               zzz:=zzz+2;
%+S                   qy:=qy.next endrepeat;
%+S                qx:=qn.pred;    -- for LDS scanning
%+S           else
                   if reverse then cond:=notQcond(cond) endif; qx.subc:=cond;
%+S           endif
              deleteQinstr(qn); deleteQinstr(qi); deleteQinstr(qnext);
%+D           zzz:=zzz+3;
              qnext:=qx;
         endcase
    Nc1:Nc2:Nc3:Nc4:Nc5:Nc6:Nc7:Nc8:Nc9:Nc10:Nc11:
%+S      Nc13:Nc14:Nc15:Nc16:Nc17:Nc18:
    Np1:Np2:Np3:Np4:Np5:Np6:Np7:Np8:Np9:Np10:
    Np11:Np12:Np13:Np14:Np15:Np16:Np17:Np18:Np19:Np20:Np21:Np22:Np23:
    N0:
%+E Nx1:        Nx4:
      endrepeat;
E2:
%-E   if firstLDS<>none
%-E   then if deleteMark then deleteQinstr(firstLDS)
%-E %+D       ldd:=ldd+1;
%-E   endif endif
%+D   if listq1<>0 then if (xxx+yyy+zzz+ldd+ppp)>0
%+D   then outstring(" at l. "); outint(curline);
%+D        outstring(" ("); outint(qcount); outstring(")");
%+D        if xxx<>0 then outstring(" jmp chgd:"); outint(xxx); endif
%+D        if yyy<>0 then outstring(" jmp del:"); outint(yyy) endif;
%+D        if zzz<>0 then outstring(" condec:"); outint(zzz) endif;
%+D        if ldd<>0 then outstring(" LDS:"); outint(ldd) endif;
%+D        if ppp<>0 then outstring(" push:"); outint(ppp) endif;
%+D        outimage; 
%+D   endif endif
%+D   listq1:=old1;
%+S E1:
E0:
      exhaust(CSEGID,all);
end;

routine deleteJMP; import ref(Qfrm5) jmp;
begin ref(Qfrm6) dst; dst:=jmp.dst;
      if jmp qua ref(Qpkt)=dst qua ref(Qpkt) -- FDEST not generated yet
      then jmp.addr.kind:=0; removeQinstr(jmp)
      else if dst<>none --- dest must be in buffer
           then deleteQinstr(dst) endif
           deleteQinstr(jmp);
      endif
end

routine possBJMP; import ref(Qfrm5) fjmp,bjmp;
-- see if BDEST precedes FDEST (the latter to be moved to bdest)
begin ref(Qpkt) qn; ref(Qfrm6) bdst;
      qn:=bjmp; bdst:=bjmp.dst;
      repeat qn:=qn.pred while qn<>fjmp
      do if qn=bdst then goto E endif endrepeat;
      -- CHANGE (bdst precedes fjmp)
      fjmp.addr:=noadr; bdst:=fjmp.dst;
      bdst.fnc:=qBDEST;
      -- ??? fix.val:=fdst.aux; -- ??
      -- ??? FIXTAB(fix.HI).elt(fix.LO).segid.val:=0; -- ??
%-D   bdst.aux:=0;
%+D   bdst.aux:=LabelSequ:=LabelSequ+1;
E:end;

routine sameLOAD;
 import ref(Qfrm4c) firstLDS; ref(Qpkt) qn; range(0:maxword) LDSoprRegs;
 export boolean res;
--- check regs and operand of n not written in <firstLDS,qn>
begin ref(qpkt) n;
      n:=firstLDS; res:=false;
      repeat n:=n.next while n <> qn
      do if n.fnc=qJMP then -- OK
         elsif wAND(LDSoprRegs,n.write) <> 0 then goto E1
         elsif wAND(n.write,uM) = 0 then -- OK
         else case 0:K_Qfrm6 (n.kind)
              when K_Qfrm2: if n.fnc=qRSTRW then goto X1
                            elsif n.fnc=qRSTRB
                            then X1:if firstLDS.opr.kind <> extadr
                                    then goto E2 endif;
                            endif;
             when K_Qfrm3,K_Qfrm4,K_Qfrm4b,K_Qfrm4c:
                  if SameMemPart(n,firstLDS) then goto E3 endif;
             otherwise goto E4 endcase;
        endif;
      endrepeat;
      res:=true;
E1:E2:E3:E4:end;

--- %+S routine deleteLOAD; import ref(Qpkt) qi;
--- %+S begin ref(Qfrm5) jmp; ref(Qfrm6) qdest; ref(Qpkt) qn;
--- %+S       jmp:=qi.pred;
--- %+S       repeat if qi=none then goto E1 endif;
--- %+S       while qi.fnc=qLINE do qi:=qi.next endrepeat
--- %+S %-E   if    qi.fnc<>qLDS  then ---
--- %+S %+E   if    qi.fnc<>qLOAD then ---
--- %+S       elsif prevLOAD=none then ---
--- %+S       elsif not QinstrEqual(prevLOAD,qi) then -- nothing
--- %+S %-E   elsif SameMemRegUnwritten(prevLOAD,qi,wOR(umask(qi.reg),uDS))
--- %+S %+E   elsif SameMemRegUnwritten(prevLOAD,qi,uEBX)
--- %+S       then deleteQinstr(qi);
--- %+S            if jmp.fnc=qJMP -- we know it must have subc<>0
--- %+S            then qdest:=jmp.dst;
--- %+S                 if qdest<>none then if qdest.fnc=qFDEST
--- %+S                 then jmp:=qdest.pred;
--- %+S                      repeat while jmp.fnc=qLINE
--- %+S                      do jmp:=jmp.pred endrepeat
--- %+S                      if jmp.fnc=qJMP and (jmp.subc=0) then
--- %+S                         qn:=qdest.next;
--- %+S                         repeat if qn=none then goto E2 endif;
--- %+S                         while qn.fnc=qLINE do qn:=qn.next endrepeat
--- %+S                         if QinstrEqual(prevLOAD,qn)
--- %+S                         then deleteQinstr(qn) endif
--- %+S                      endif
--- %+S                 endif endif
--- %+S            endif
--- %+S       endif
--- %+S E1: E2:
--- %+S end;

%title ***   I n s t r u c t i o n   R o u t i n e s   ***

Routine AppendQinstr; import ref(Qpkt) qi;
begin boolean newstate; range(0:MaxByte) kind;
      ref(Qpkt) b; -- for inline mPOPK
%+D   RST(R_AppendQinstr); if InMassage then IERR("InMassage") endif;
      newstate:=DeadCode; qi.isize:=0; qcount:=qcount+1;
      --- Update pred,next links in Q-queue ---
      if qlast <> none
      then qlast.next:=qi; qi.pred:=qlast; qi.next:=none; qlast:=qi;
      else qi.pred:=qi.next:=none; qfirst:=qlast:=qi endif;

      case 0:qMXX (qi.fnc)
      when qFDYAD:
%+E        qi.reg:=bOR(qi.reg,2*StackDepth87);
           StackDepth87:=StackDepth87-1;
           if qi.subc=qFCOM then StackDepth87:=StackDepth87-1 endif;
      when qFDYADM:
%+E        qi qua Qfrm4.aux.LO:=bOR(qi qua Qfrm4.aux.LO,2*StackDepth87);
           if qi.subc=qFCOM then StackDepth87:=StackDepth87-1 endif;
%+E   when qFMONAD: qi.reg:=bOR(qi.reg,2*StackDepth87);
%+E   when qFST: qi.subc:=bOR(qi.subc,2*StackDepth87);
      when qFPUSH,qFSTP:
%+E        qi.subc:=bOR(qi.subc,2*StackDepth87);
           StackDepth87:=StackDepth87-1
      when qFPOP,qFLD,qFLDC,qFDUP: StackDepth87:=StackDepth87+1
%+E        qi.subc:=bOR(qi.subc,2*StackDepth87);
           if StackDepth87=9
           then ERROR("Too complicated arithmetic expression") endif;
      when qFLDCK: StackDepth87:=StackDepth87+1
           if StackDepth87=9
           then ERROR("Too complicated arithmetic expression") endif;
      when qFDEST,qBDEST,qLABEL: newstate:=false; DeadCode:=false
%-E   when qJMPM,qJMPFM:   newstate:=true;
%+E   when qJMPM:          newstate:=true;
           if DeadCode then DeleteQPosibJ(qi) endif
      when qJMP: if qi.subc=0 then newstate:=true endif;
           if DeadCode then DeleteQPosibJ(qi) endif
      otherwise if DeadCode then DeleteQinstr(qi) endif
      endcase;

      if DeadCode then PreMindMask:=uSPBPM; PreReadMask:=NotMindMask:=0;
      else MakeRegMap(qi);
%+D        if listq1 > 1 then ListQinstr("AppQ:     ",qi,true) endif;
%+S        if MASSLV <> 0 then
              --------------------------------------------
              RecDepth:=MASSDP;  -- >1 always
              inmassage:=true; DOMASSAGE; InMassage:=false;
              --------------------------------------------
%+S        endif
      endif;

      DeadCode:=newstate
      if qcount > QBFLIM then peepExhaust(false); deleteOK:=false endif;
end;

Routine QinstrIsDeleted; import ref(Qpkt) qi; export Boolean res;
begin --- Check that 'qi' is in queue ---
      if    (qi.pred=none) and (qi<>qfirst) then res:=true
      elsif (qi.next=none) then res:= (qi<>qlast)
      else res:=false endif;
end;

Routine InsertQinstr; import ref(Qpkt) qi,suc;
begin --- Check that 'suc' is in queue ---
%+D   if QinstrIsDeleted(suc)
%+D   then IERR("INSERT: Q-Instruction is DELETED");
%+D   else RST(R_InsertQinstr);
           qi.isize:=0; qcount:=qcount+1;
           if suc <> qfirst
           then suc.pred.next:=qi; qi.pred:=suc.pred;
                qi.next:=suc; suc.pred:=qi;
           else qi.pred:=none; qi.next:=suc; suc.pred:=qi; qfirst:=qi endif;
           MakeRegMap(qi);
%+D        if listq1 > 1 then ListQinstr("Insert:   ",qi,true) endif;
%+D   endif;
end;

--- macro InsertQinstr(2)
--- begin
---            %1 qua Qpkt.isize:=0; qcount:=qcount+1;
---            if %2  <> qfirst
---            then %2 .pred.next:=%1; %1 qua Qpkt.pred:=%2 .pred;
---                 %1 qua Qpkt.next:=%2 ; %2 .pred:=%1;
---            else %1 qua Qpkt.pred:=none; %1 qua Qpkt.next:=%2 ;
---                 %2 .pred:=%1; qfirst:=%1 endif;
---            MakeRegMap(%1 qua Qpkt);
--- endmacro;

%+D Visible Routine ModifyQinstr; import ref(Qpkt) qi;
%+D begin MakeRegMap(qi); qi.isize:=0;
%+D       if listq1 > 1 then ListQinstr("Modify:   ",qi,true) endif;
%+D end;

%-D Visible Macro   ModifyQinstr(1)
%-D begin MakeRegMap(%1); %1 .isize:=0;
%-D endmacro;
%page

Visible Routine Qf1; import range(0:MaxByte) fnc,subc,type;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm1);
      if qi=none then qi:=NEWOBX(size(Qfrm1));
%+D        ObjCount(K_Qfrm1):=ObjCount(K_Qfrm1)+1;
      else FreeObj(K_Qfrm1):=qi qua FreeObject.next endif;
      qi.kind:=K_Qfrm1; qi qua Qfrm1.fnc:=fnc; qi qua Qfrm1.subc:=subc;
      qi qua Qfrm1.reg:=0; qi qua Qfrm1.type:=type; AppendQinstr(qi);
end;

Routine InsertQf1;
import ref(Qpkt) qx; range(0:MaxByte) fnc,subc,type; export ref(Object) qi;
begin qi:=FreeObj(K_Qfrm1);
      if qi=none then qi:=NEWOBX(size(Qfrm1));
%+D        ObjCount(K_Qfrm1):=ObjCount(K_Qfrm1)+1;
      else FreeObj(K_Qfrm1):=qi qua FreeObject.next endif;
      qi.kind:=K_Qfrm1; qi qua Qfrm1.fnc:=fnc; qi qua Qfrm1.subc:=subc;
      qi qua Qfrm1.reg:=0; qi qua Qfrm1.type:=type; InsertQinstr(qi,qx);
end;

Visible Routine Qf1b; import range(0:MaxByte) fnc,subc,reg,type;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm1);
      if qi=none then qi:=NEWOBX(size(Qfrm1));
%+D        ObjCount(K_Qfrm1):=ObjCount(K_Qfrm1)+1;
      else FreeObj(K_Qfrm1):=qi qua FreeObject.next endif;
      qi.kind:=K_Qfrm1; qi qua Qfrm1.fnc:=fnc;
      qi qua Qfrm1.subc:=subc; qi qua Qfrm1.reg:=reg;
      qi qua Qfrm1.type:=type; AppendQinstr(qi);
end;

Routine InsertQf1b;
import ref(Qpkt) qx; range(0:MaxByte) fnc,subc,reg,type;
export ref(Object) qi;
begin qi:=FreeObj(K_Qfrm1);
      if qi=none then qi:=NEWOBX(size(Qfrm1));
%+D        ObjCount(K_Qfrm1):=ObjCount(K_Qfrm1)+1;
      else FreeObj(K_Qfrm1):=qi qua FreeObject.next endif;
      qi.kind:=K_Qfrm1; qi qua Qfrm1.fnc:=fnc;
      qi qua Qfrm1.subc:=subc; qi qua Qfrm1.reg:=reg;
      qi qua Qfrm1.type:=type; InsertQinstr(qi,qx);
end;

Visible Routine Qf2;
import range(0:MaxByte) fnc,subc,reg,type;
%-E    range(0:MaxWord) aux;
%+E    integer          aux;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm2);
      if qi=none then qi:=NEWOBX(size(Qfrm2));
%+D        ObjCount(K_Qfrm2):=ObjCount(K_Qfrm2)+1;
      else FreeObj(K_Qfrm2):=qi qua FreeObject.next endif;
      qi.kind:=K_Qfrm2; qi qua Qfrm2.fnc:=fnc; qi qua Qfrm2.subc:=subc;
      qi qua Qfrm2.reg:=reg; qi qua Qfrm2.aux.val:=aux;
      qi qua Qfrm2.type:=type; AppendQinstr(qi);
end;

Visible Routine InsertQf2;
import ref(Qpkt) qx; range(0:MaxByte) fnc,subc,reg,type;
%-E    range(0:MaxWord) aux;
%+E    integer          aux;
export ref(Object) qi;
begin qi:=FreeObj(K_Qfrm2);
      if qi=none then qi:=NEWOBX(size(Qfrm2));
%+D        ObjCount(K_Qfrm2):=ObjCount(K_Qfrm2)+1;
      else FreeObj(K_Qfrm2):=qi qua FreeObject.next endif;
      qi.kind:=K_Qfrm2; qi qua Qfrm2.fnc:=fnc; qi qua Qfrm2.subc:=subc;
      qi qua Qfrm2.reg:=reg; qi qua Qfrm2.aux.val:=aux;
      qi qua Qfrm2.type:=type; InsertQinstr(qi,qx);
end;

Visible Routine Qf2b;
import range(0:MaxByte) fnc,subc,reg,type,fld; infix(MemAddr) addr;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm2b);
      if qi=none then qi:=NEWOBX(size(Qfrm2b));
%+D        ObjCount(K_Qfrm2b):=ObjCount(K_Qfrm2b)+1;
      else FreeObj(K_Qfrm2b):=qi qua FreeObject.next endif;
      qi qua Qfrm2b.fnc:=fnc; qi qua Qfrm2b.subc:=subc;
      qi qua Qfrm2b.reg:=reg; qi qua Qfrm2b.aux.val:=fld;
      qi qua Qfrm2b.addr:=addr; qi.kind:=K_Qfrm2b;
      qi qua Qfrm2.type:=type; AppendQinstr(qi);
end;

Routine InsertQf2b;
import ref(Qpkt) qx; range(0:MaxByte) fnc,subc,reg,type,fld; infix(MemAddr) addr
export ref(Object) qi;
begin qi:=FreeObj(K_Qfrm2b);
      if qi=none then qi:=NEWOBX(size(Qfrm2b));
%+D        ObjCount(K_Qfrm2b):=ObjCount(K_Qfrm2b)+1;
      else FreeObj(K_Qfrm2b):=qi qua FreeObject.next endif;
      qi qua Qfrm2b.fnc:=fnc; qi qua Qfrm2b.subc:=subc;
      qi qua Qfrm2b.reg:=reg; qi qua Qfrm2b.aux.val:=fld;
      qi qua Qfrm2b.addr:=addr; qi.kind:=K_Qfrm2b;
      qi qua Qfrm2.type:=type; InsertQinstr(qi,qx);
end;

Visible Routine Qf3;
import range(0:MaxByte) fnc,subc,reg,type; infix(MemAddr) opr;
begin ref(Object) qi;
      qi:=FreeObj(K_Qfrm3);
      if qi=none then qi:=NEWOBX(size(Qfrm3));
%+D        ObjCount(K_Qfrm3):=ObjCount(K_Qfrm3)+1;
      else FreeObj(K_Qfrm3):=qi qua FreeObject.next endif;
      qi qua Qfrm3.fnc:=fnc; qi qua Qfrm3.subc:=subc;
      qi qua Qfrm3.reg:=reg; qi qua Qfrm3.opr:=opr;
      qi qua Qfrm3.type:=type; qi.kind:=K_Qfrm3; AppendQinstr(qi);
end;

Routine InsertQf3;
import ref(Qpkt) qx; range(0:MaxByte) fnc,subc,reg,type; infix(MemAddr) opr;
export ref(Object) qi;
begin qi:=FreeObj(K_Qfrm3);
      if qi=none then qi:=NEWOBX(size(Qfrm3));
%+D        ObjCount(K_Qfrm3):=ObjCount(K_Qfrm3)+1;
      else FreeObj(K_Qfrm3):=qi qua FreeObject.next endif;
      qi qua Qfrm3.fnc:=fnc; qi qua Qfrm3.subc:=subc;
      qi qua Qfrm3.reg:=reg; qi qua Qfrm3.opr:=opr;
      qi qua Qfrm3.type:=type; qi.kind:=K_Qfrm3; InsertQinstr(qi,qx);
end;

Visible Routine Qf3b;
import range(0:MaxByte) fnc,subc,reg,type; infix(ValueItem) val;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm3);
      if qi=none then qi:=NEWOBX(size(Qfrm3));
%+D        ObjCount(K_Qfrm3):=ObjCount(K_Qfrm3)+1;
      else FreeObj(K_Qfrm3):=qi qua FreeObject.next endif;
      qi qua Qfrm3.fnc:=fnc; qi qua Qfrm3.subc:=subc;
      qi qua Qfrm3.reg:=reg; qi qua Qfrm3.val:=val;
      qi qua Qfrm3.type:=type; qi.kind:=K_Qfrm3; AppendQinstr(qi);
end;

Routine InsertQf3b;
import ref(Qpkt) qx; range(0:MaxByte) fnc,subc,reg,type; infix(ValueItem) val;
export ref(Object) qi;
begin qi:=FreeObj(K_Qfrm3);
      if qi=none then qi:=NEWOBX(size(Qfrm3));
%+D        ObjCount(K_Qfrm3):=ObjCount(K_Qfrm3)+1;
      else FreeObj(K_Qfrm3):=qi qua FreeObject.next endif;
      qi qua Qfrm3.fnc:=fnc; qi qua Qfrm3.subc:=subc;
      qi qua Qfrm3.reg:=reg; qi qua Qfrm3.val:=val;
      qi qua Qfrm3.type:=type; qi.kind:=K_Qfrm3; InsertQinstr(qi,qx);
end;

Visible Routine Qf4;
import range(0:MaxByte) fnc,subc,reg,type;
%-E    range(0:MaxWord) aux;
%+E    integer          aux;
       infix(MemAddr) opr;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm4);
      if qi=none then qi:=NEWOBX(size(Qfrm4));
%+D        ObjCount(K_Qfrm4):=ObjCount(K_Qfrm4)+1;
      else FreeObj(K_Qfrm4):=qi qua FreeObject.next endif;
      qi qua Qfrm4.fnc:=fnc; qi qua Qfrm4.subc:=subc;
      qi qua Qfrm4.reg:=reg; qi qua Qfrm4.aux.val:=aux;
      qi qua Qfrm4.opr:=opr; qi qua Qfrm4.type:=type;
      qi.kind:=K_Qfrm4; AppendQinstr(qi);
end;

Routine InsertQf4;
import ref(Qpkt) qx; range(0:MaxByte) fnc,subc,reg,type;
%-E    range(0:MaxWord) aux;
%+E    integer          aux;
       infix(MemAddr) opr;
export ref(Object) qi;
begin qi:=FreeObj(K_Qfrm4);
      if qi=none then qi:=NEWOBX(size(Qfrm4));
%+D        ObjCount(K_Qfrm4):=ObjCount(K_Qfrm4)+1;
      else FreeObj(K_Qfrm4):=qi qua FreeObject.next endif;
      qi qua Qfrm4.fnc:=fnc; qi qua Qfrm4.subc:=subc;
      qi qua Qfrm4.reg:=reg; qi qua Qfrm4.aux.val:=aux;
      qi qua Qfrm4.opr:=opr; qi qua Qfrm4.type:=type;
      qi.kind:=K_Qfrm4; InsertQinstr(qi,qx);
end;

Visible Routine Qf4b;
import range(0:MaxByte) fnc,subc,reg,type;
%-E    range(0:MaxWord) aux;
%+E    integer          aux;
       infix(MemAddr) opr; infix(MemAddr) addr;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm4b);
      if qi=none then qi:=NEWOBX(size(Qfrm4b));
%+D        ObjCount(K_Qfrm4b):=ObjCount(K_Qfrm4b)+1;
      else FreeObj(K_Qfrm4b):=qi qua FreeObject.next endif;
      qi qua Qfrm4b.fnc:=fnc; qi qua Qfrm4b.subc:=subc;
      qi qua Qfrm4b.reg:=reg; qi qua Qfrm4b.aux.val:=aux;
      qi qua Qfrm4b.opr:=opr; qi qua Qfrm4b.addr:=addr;
      qi qua Qfrm4b.type:=type; qi.kind:=K_Qfrm4b; AppendQinstr(qi);
end;

Routine InsertQf4b;
import ref(Qpkt) qx; range(0:MaxByte) fnc,subc,reg,type;
%-E    range(0:MaxWord) aux;
%+E    integer          aux;
       infix(MemAddr) opr; infix(MemAddr) addr;
export ref(Object) qi;
begin qi:=FreeObj(K_Qfrm4b);
      if qi=none then qi:=NEWOBX(size(Qfrm4b));
%+D        ObjCount(K_Qfrm4b):=ObjCount(K_Qfrm4b)+1;
      else FreeObj(K_Qfrm4b):=qi qua FreeObject.next endif;
      qi qua Qfrm4b.fnc:=fnc; qi qua Qfrm4b.subc:=subc;
      qi qua Qfrm4b.reg:=reg; qi qua Qfrm4b.aux.val:=aux;
      qi qua Qfrm4b.opr:=opr; qi qua Qfrm4b.addr:=addr;
      qi qua Qfrm4b.type:=type; qi.kind:=K_Qfrm4b; InsertQinstr(qi,qx);
end;

Visible Routine Qf4c;
import range(0:MaxByte) fnc,subc,reg,type;
%-E    range(0:MaxWord) aux;
%+E    integer          aux;
       infix(MemAddr) opr; range(0:MaxByte) nrep;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm4c);
      if qi=none then qi:=NEWOBX(size(Qfrm4c));
%+D        ObjCount(K_Qfrm4c):=ObjCount(K_Qfrm4c)+1;
      else FreeObj(K_Qfrm4c):=qi qua FreeObject.next endif;
      qi qua Qfrm4c.fnc:=fnc; qi qua Qfrm4c.subc:=subc;
      qi qua Qfrm4c.reg:=reg; qi qua Qfrm4c.aux.val:=aux;
      qi qua Qfrm4c.opr:=opr; qi qua Qfrm4c.nrep:=nrep;
      qi qua Qfrm4c.type:=type; qi.kind:=K_Qfrm4c; AppendQinstr(qi);
end;

Routine InsertQf4c;
import ref(Qpkt) qx; range(0:MaxByte) fnc,subc,reg,type;
%-E    range(0:MaxWord) aux;
%+E    integer          aux;
       infix(MemAddr) opr; range(0:MaxByte) nrep;
export ref(Object) qi;
begin qi:=FreeObj(K_Qfrm4c);
      if qi=none then qi:=NEWOBX(size(Qfrm4c));
%+D        ObjCount(K_Qfrm4c):=ObjCount(K_Qfrm4c)+1;
      else FreeObj(K_Qfrm4c):=qi qua FreeObject.next endif;
      qi qua Qfrm4c.fnc:=fnc; qi qua Qfrm4c.subc:=subc;
      qi qua Qfrm4c.reg:=reg; qi qua Qfrm4c.aux.val:=aux;
      qi qua Qfrm4c.opr:=opr; qi qua Qfrm4c.nrep:=nrep;
      qi qua Qfrm4c.type:=type; qi.kind:=K_Qfrm4c; InsertQinstr(qi,qx);
end;

Visible Routine Qf5;
import range(0:MaxByte) fnc,subc,reg;
       range(0:MaxWord) aux; infix(MemAddr) addr;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm5);
      if qi=none then qi:=NEWOBX(size(Qfrm5));
%+D        ObjCount(K_Qfrm5):=ObjCount(K_Qfrm5)+1;
      else FreeObj(K_Qfrm5):=qi qua FreeObject.next endif;
      qi qua Qfrm5.fnc:=fnc;  qi qua Qfrm5.subc:=subc;
      qi qua Qfrm5.reg:=reg;  qi qua Qfrm5.aux:=aux;
      qi qua Qfrm5.dst:=none; qi qua Qfrm5.addr:=addr;
      qi qua Qfrm5.type:=cANY; qi.kind:=K_Qfrm5; AppendQinstr(qi);
end;
%page

Routine RemoveQinstr; import ref(Qpkt) qi;
begin
%+D   if listq1 > 1 then ListQinstr("Remove:   ",qi,false) endif;
%+D   if QinstrIsDeleted(qi)
%+D   then IERR("(Above) Q-Instruction is already DELETED");
%+D   else
           if qi=qfirst
           then qfirst:=qfirst.next;
                if qfirst=none then qlast:=none
                else qfirst.pred:=none endif;
           elsif qi=qlast then qlast:=qlast.pred; qlast.next:=none
           else qi.pred.next:=qi.next;
                qi.next qua Qpkt.pred:=qi.pred;
           endif;
           qcount:=qcount-1;
%+D   endif;
      qi.pred:=none; qi.next:=none;
end;

Visible routine deleteLastQ; begin DeleteQinstr(qlast) end;

Routine DeleteQinstr; import ref(Object) qi;
begin range(0:MaxByte) kind;
%+D   RST(R_DeleteQinstr);
%+D   if qi=none then IERR("DeleteQinstr(none)")
%+D   else
           RemoveQinstr(qi); kind:=qi.kind;
%+D        if kind < K_Max
%+D        then
                qi qua FreeObject.next:=FreeObj(kind); FreeObj(kind):=qi;
%+D             qi.kind := kind+128;
%+D        else IERR("DELETE(qi)  --  qi is already deleted") endif;
%+D   endif;
end;
%page

Routine DeleteQPosibJ; import ref(Qpkt) qi;
begin ref(Qfrm5)jmp; ref(Qfrm6) dst;
      infix(MemAddr) adr; infix(Fixup) Fx; infix(WORD) fix;
%+D   RST(R_DeleteQPosibJ);
      jmp:=none; dst:=none;
      case 0:qMXX (qi.fnc)
      when qJMP: jmp:=qi; dst:=jmp.dst;
           if dst <> none
           then if dst.fnc=qBDEST then -- NOTHING
                elsif dst=qi -- FDEST Not generated, Mark jmp Deleted
                then dst:=none; jmp.addr.kind:=0;
                     RemoveQinstr(jmp); jmp:=none;
                endif;
           endif;
%-E   when qJMPM,qJMPFM: jmp:=qi;
%+E   when qJMPM:        jmp:=qi;
      when qFDEST: jmp:=qi qua Qfrm6.jmp;
                   if jmp <> none then DeleteQPosibJ(jmp) endif;
                   jmp:=none; -- Prevent it from being deleted twice --
      when qBDEST:
%+C                IERR("Masseur.DeleteQPosibJ-3"); -- Not Implemented 
      when qLABEL: -- Nothing
      otherwise jmp:=qi endcase;  --- Default Case See Next Line !!!
      if jmp <> none then DeleteQinstr(jmp) endif;
      if dst <> none then DeleteQinstr(dst) endif;
end; -- DeleteQPosibJ

%page
%-V %-E Routine OprEQUAL; import infix(MemAddr) x,y; export Boolean res;
%-V %-E begin if    x.smbx   <> y.smbx   then res:=false
%-V %-E       elsif x.kind   <> y.kind   then res:=false
%-V %-E       elsif x.sbireg <> y.sbireg then res:=false
%-V %-E       elsif x.rela   <> y.rela   then res:=false
%-V %-E       else  res:=true endif;
%-V %-E end;

%-V %-E Routine OprNotEQUAL; import infix(MemAddr) x,y; export Boolean res;
%-V %-E begin if    x.smbx   <> y.smbx   then res:=true
%-V %-E       elsif x.kind   <> y.kind   then res:=true
%-V %-E       elsif x.sbireg <> y.sbireg then res:=true
%-V %-E       elsif x.rela   <> y.rela   then res:=true
%-V %-E       else  res:=false endif;
%-V %-E end;

Routine QinstrEqual; import ref(Qpkt) a,b; export boolean res;
begin
%+D   RST(R_QinstrEqual);
%+D   if listq1 > 2 then ListQinstr("QiEqual?  ",a,false) endif;
      res:=false;
      if a.fnc<>b.fnc   then goto E2 endif;
      if b.reg<>a.reg   then goto E4 endif;
      if a.subc<>b.subc then goto E3 endif;
      if b.kind<>a.kind then goto E1 endif;
      case K_Qfrm1:K_Qfrm6 (a.kind)
 when K_Qfrm1:
 when K_Qfrm2:  if a qua Qfrm2.aux<>b qua Qfrm2.aux     then goto E5  endif
 when K_Qfrm2b: if a qua Qfrm2.aux<>b qua Qfrm2.aux     then goto E6  endif
                if OprNE(a qua Qfrm2b.addr,b qua Qfrm2b.addr) then goto E7 endif
 when K_Qfrm3:
                if OprNE(a qua Qfrm3.opr,b qua Qfrm3.opr) then goto E8  endif
 when K_Qfrm4:
                if a qua Qfrm4.aux<>b qua Qfrm4.aux     then goto E10 endif
                if OprNE(a qua Qfrm3.opr,b qua Qfrm3.opr) then goto E9  endif
 when K_Qfrm4c:
               if b qua Qfrm4c.nrep<>a qua Qfrm4c.nrep then goto E16 endif
               if a qua Qfrm4.aux<>b qua Qfrm4.aux     then goto E15 endif
               if OprNE(a qua Qfrm3.opr,b qua Qfrm3.opr) then goto E14 endif
 when K_Qfrm4b:
               if a qua Qfrm4.aux<>b qua Qfrm4.aux        then goto E12 endif
               if OprNE(b qua Qfrm3.opr,a qua Qfrm3.opr)  then goto E11 endif
               if OprNE(a qua Qfrm4b.addr,b qua Qfrm4b.addr) then goto E13 endif
 when K_Qfrm5:
               if b qua Qfrm5.aux<>a qua Qfrm5.aux     then goto E18 endif
               if a qua Qfrm5.dst<>b qua Qfrm5.dst     then goto E19 endif
               if OprNE(a qua Qfrm5.addr,b qua Qfrm5.addr) then goto E17 endif
 when K_Qfrm6: if a qua Qfrm6.aux<>b qua Qfrm6.aux     then goto E20 endif
               if b qua Qfrm6.jmp<>a qua Qfrm6.jmp     then goto E21 endif
               if a qua Qfrm6.rela<>b qua Qfrm6.rela   then goto E22 endif
      endcase; res:=true;
E1:E2:E3:E4:E5:E6:E7:E8:E9:E10:E11:E12:E13:E14:E15:E16:E17:E18:E19:E20:E21:E22:
%+D   if res then
%+D      if listq1 > 2 then ListQinstr("QiEqualYES",b,false) endif;
%+D   else
%+D      if listq1 > 2 then ListQinstr("QiEqualNO!",b,false) endif;
%+D   endif
end; -- QinstrEqual
%page

Visible Routine ForwJMP; import range(0:20) subc;
export ref(Object) jmp;
begin Infix(WORD) smbx; smbx.val:=0;
      jmp:=FreeObj(K_Qfrm5);
      if jmp=none then jmp:=NEWOBX(size(Qfrm5));
%+D        ObjCount(K_Qfrm5):=ObjCount(K_Qfrm5)+1;
      else FreeObj(K_Qfrm5):=jmp qua FreeObject.next endif;
      jmp qua Qfrm5.fnc:=qJMP; jmp qua Qfrm5.subc:=subc;
      jmp qua Qfrm5.reg:=0;    jmp qua Qfrm5.aux:=0;
      jmp qua Qfrm5.addr:=NewFixAdr(CSEGID,smbx);
      jmp qua Qfrm5.dst:=jmp; jmp qua Qfrm5.type:=cANY;
      jmp.kind:=K_Qfrm5; AppendQinstr(jmp);
end;

Visible Routine DefFDEST; import ref(Qfrm5) jmp;
begin ref(Object) dst;
%+D   RST(R_DefFDEST);
%+C   if jmp=none then IERR("MASS.DefFDEST-1") endif;
%+C   if jmp.fnc <> qJMP then IERR("MASS.DefFDEST-2") endif;
      if jmp.addr.kind=0 then DELETE(jmp); -- JMP to this FDEST is deleted --
%+C   elsif jmp.addr.kind<>fixadr then IERR("MASS.DefFDEST-3")
      else dst:=FreeObj(K_Qfrm6);
           if dst=none then dst:=NEWOBX(size(Qfrm6));
%+D             ObjCount(K_Qfrm6):=ObjCount(K_Qfrm6)+1;
           else FreeObj(K_Qfrm6):=dst qua FreeObject.next endif;
           dst qua Qfrm6.fnc:=qFDEST; dst qua Qfrm6.subc:=0;
           dst qua Qfrm6.reg:=0; dst qua Qfrm6.rela.val:=0;
           dst qua Qfrm6.type:=cANY;
           dst qua Qfrm6.aux:=jmp.addr.fix.val;
           dst qua Qfrm6.jmp:=jmp; jmp.dst:=dst;
           dst.kind:=K_Qfrm6; AppendQinstr(dst);
     endif;
end;

%+S Routine insertFJUMP;
%+S import range(0:MaxByte) subc; ref(Qpkt) qx,qd; export ref(Object) dst;
%+S begin ref(Object) qi; Infix(WORD) smbx; smbx.val:=0;
%+S       dst:=FreeObj(K_Qfrm6);
%+S       if dst=none then dst:=NEWOBX(size(Qfrm6));
%+S %+D      ObjCount(K_Qfrm6):=ObjCount(K_Qfrm6)+1;
%+S       else FreeObj(K_Qfrm6):=dst qua FreeObject.next endif;
%+S       qi:=FreeObj(K_Qfrm5);
%+S       if qi=none then qi:=NEWOBX(size(Qfrm5));
%+S %+D      ObjCount(K_Qfrm5):=ObjCount(K_Qfrm5)+1;
%+S       else FreeObj(K_Qfrm5):=qi qua FreeObject.next endif;
%+S       qi qua Qfrm5.fnc:=qJMP;  qi qua Qfrm5.subc:=subc;
%+S       qi qua Qfrm5.reg:=0;  qi qua Qfrm5.aux:=0;
%+S       qi qua Qfrm5.dst:=none;
%+S       qi qua Qfrm5.type:=cANY; qi.kind:=K_Qfrm5;
%+S       qi qua Qfrm5.addr:=NewFixAdr(CSEGID,smbx);
%+S       qi qua Qfrm5.dst:=dst; qi qua Qfrm5.type:=cANY;
%+S       qi.kind:=K_Qfrm5;
%+S       dst qua Qfrm6.fnc:=qFDEST; dst qua Qfrm6.subc:=0;
%+S       dst qua Qfrm6.reg:=0; dst qua Qfrm6.rela.val:=0;
%+S       dst qua Qfrm6.type:=cANY; dst.kind:=K_Qfrm6;
%+S       dst qua Qfrm6.aux:=qi qua Qfrm5.addr.fix.val;
%+S       dst qua Qfrm6.jmp:=qi;
%+S  ---  insertQinstr(qi,qx);
%+S       qi qua Qpkt.isize:=0; qcount:=qcount+1;
%+S       qx.pred.next:=qi; qi qua Qpkt.pred:=qx.pred;
%+S       qi qua Qpkt.next:=qx; qx.pred:=qi;
%+S  ---  insertQinstr(dst,qd);
%+S       dst qua Qpkt.isize:=0; qcount:=qcount+1;
%+S       qd.pred.next:=dst; dst qua Qpkt.pred:=qd.pred;
%+S       dst qua Qpkt.next:=qd; qd.pred:=dst;
%+S %+D   if listq1 > 1 then ListQinstr("InsFJUMP: ",qi,false);
%+S %+D                      ListQinstr("  before: ",qx,false) endif;
%+S %+D   if listq1 > 1 then ListQinstr("InsFDEST: ",dst,false);
%+S %+D                      ListQinstr("  before: ",qd,false) endif;
%+S end;

Visible Routine DefBDEST; export ref(Object) dst;
begin dst:=FreeObj(K_Qfrm6);
      if dst=none then dst:=NEWOBX(size(Qfrm6));
%+D        ObjCount(K_Qfrm6):=ObjCount(K_Qfrm6)+1;
      else FreeObj(K_Qfrm6):=dst qua FreeObject.next endif;
      dst qua Qfrm6.fnc:=qBDEST; dst qua Qfrm6.subc:=0;
      dst qua Qfrm6.reg:=0; dst qua Qfrm6.rela.val:=0;
      dst qua Qfrm6.type:=cANY;
%+D   dst qua Qfrm6.aux:=LabelSequ:=LabelSequ+1;
      dst qua Qfrm6.jmp:=none;
      dst.kind:=K_Qfrm6; AppendQinstr(dst);
end;

Visible Routine BackJMP;
import range(0:20) subc; ref(Qfrm6) dst; export ref(Object) jmp;
begin jmp:=FreeObj(K_Qfrm5);
      if jmp=none then jmp:=NEWOBX(size(Qfrm5));
%+D        ObjCount(K_Qfrm5):=ObjCount(K_Qfrm5)+1;
      else FreeObj(K_Qfrm5):=jmp qua FreeObject.next endif;
      jmp qua Qfrm5.fnc:=qJMP; jmp qua Qfrm5.subc:=subc;
      jmp qua Qfrm5.reg:=0;    jmp qua Qfrm5.aux:=0;
      jmp qua Qfrm5.type:=cANY;
      jmp qua Qfrm5.addr:=noadr;
      jmp qua Qfrm5.dst:=dst;
      jmp.kind:=K_Qfrm5; AppendQinstr(jmp);
end;

Visible Routine DefLABEL;
import range(0:MaxByte) subc; range(0:MaxWord) fixval,smbx;
begin ref(Object) lab; infix(WORD) fix; infix(Fixup) Fx;
      lab:=FreeObj(K_Qfrm6);
      if lab=none then lab:=NEWOBX(size(Qfrm6));
%+D        ObjCount(K_Qfrm6):=ObjCount(K_Qfrm6)+1;
      else FreeObj(K_Qfrm6):=lab qua FreeObject.next endif;
      fix.val:=fixval; FIXTAB(fix.HI).elt(fix.LO).segid:=CSEGID;
      lab qua Qfrm6.fnc:=qLABEL; lab qua Qfrm6.subc:=subc;
      lab qua Qfrm6.reg:=0;      lab qua Qfrm6.aux:=fix.val;
      lab qua Qfrm6.type:=cANY;
      lab qua Qfrm6.smbx:=smbx;  lab qua Qfrm6.jmp:=none;
      lab.kind:=K_Qfrm6; AppendQinstr(lab);
end;
%page

Visible Routine qPOPKill;
%-E   import range(0:MaxWord) aux;
%+E   import integer          aux;
begin ref(Object) qi; qi:=FreeObj(K_Qfrm2);
      if qi=none then qi:=NEWOBX(size(Qfrm2));
%+D        ObjCount(K_Qfrm2):=ObjCount(K_Qfrm2)+1;
      else FreeObj(K_Qfrm2):=qi qua FreeObject.next endif;
      qi.kind:=K_Qfrm2; qi qua Qfrm2.fnc:=qPOPK;
      qi qua Qfrm2.subc:=qi qua Qfrm2.reg:=qi qua Qfrm2.type:=0;
      qi qua Qfrm2.aux.val:=aux; AppendQinstr(qi);
end;

macro StackModification(1)
begin     (
%-D %-E    if wAND(wOR(%1 .read,%1 .write),uSP )=0 then 0 else
%-D %+E    if wAND(wOR(%1 .read,%1 .write),uESP)=0 then 0 else
           StaxxModification(%1))
endmacro

Visible Routine FindPushx; import range(0:MaxWord) nwm; export ref(Qpkt) res;
--- utility for "spaceonstack" in parse
begin short integer t,n; ref(Qpkt) qi;
      res:=none; qi:=qlast; t:= nwm*AllignFac;
      repeat while qi <> none
      do case 0:qMXX (qi.fnc)
         when qFDEST,qBDEST,qLABEL,qENTER,qJMP,qJMPM,
%-E           qJMPFM,
              qRET,qIRET,qLEAVE: goto E1;
         endcase;
         n:=StackModification(qi); if n=qSP_ then goto E2 endif; t:=t-n;
         if t <= 0
         then if qi.fnc<>qADJST then res:=qi; goto E3 endif endif
         qi:=qi.pred;
      endrepeat;
E1:E2:E3:
%+D  if listq1 > 1 then ListQinstr("FindPushx:",res,false) endif;
end; -- FindPushx
%page

Routine Const87;
import range(0:6) fmf; infix(ValueItem) cnst;
export range(0:7) cn;
begin case 0:6 (fmf)
      when FMF_SINT:  if    cnst.wrd=0          then cn:=qFLDZ
                      elsif cnst.wrd=1          then cn:=qFLD1
                      else  cn:=0  endif;
      when FMF_INT:   if    cnst.int=0          then cn:=qFLDZ
                      elsif cnst.int=1          then cn:=qFLD1
                      else  cn:=0  endif;
      when FMF_REAL:  if    cnst.rev=0.0        then cn:=qFLDZ
                      elsif cnst.rev=1.0        then cn:=qFLD1
                  --- elsif cnst.rev='pi'       then cn:=qFLDPI
                  --- elsif cnst.rev='log2(10)' then cn:=qFLDL2T
                  --- elsif cnst.rev='log2(e)'  then cn:=qFLDL2E
                  --- elsif cnst.rev='log10(2)' then cn:=qFLDLG2
                  --- elsif cnst.rev='ln(2)'    then cn:=qFLDLN2
                      else  cn:=0  endif;
      when FMF_LREAL: if    cnst.lrv=0.0&&0     then cn:=qFLDZ
                      elsif cnst.lrv=1.0&&0     then cn:=qFLD1
                  --- elsif cnst.lrv='pi'       then cn:=qFLDPI
                  --- elsif cnst.lrv='log2(10)' then cn:=qFLDL2T
                  --- elsif cnst.lrv='log2(e)'  then cn:=qFLDL2E
                  --- elsif cnst.lrv='log10(2)' then cn:=qFLDLG2
                  --- elsif cnst.lrv='ln(2)'    then cn:=qFLDLN2
                      else  cn:=0  endif;
      endcase;
end;
%title
--
--                        Q1 --+--> Q2
--                             !
--                             M
--                        ------------
--
-- Utility Routines for Masseur:
--
-- Inspect a single instruction:
--------------------------------
-- RegsWrittenDies: (a:Qpkt,r:reg) ==> om_a_skriver_kun_r:boolean;
--
-- Search forward deciding a condition:
---------------------------------------
-- RegDies: (a:Qpkt,r:mask) ==> if_r_dies_in_a:boolean;  (in COASM)
--
-- Search backward for an instruction:
--------------------------------------
-- RegLastUsed:    (a:Qpkt,r:mask)                ==> b:ref(Qpkt);
-- RegLastWrite:   (a:Qpkt,r:mask)                ==> b:ref(Qpkt);
-- RegOneshot:     (a:Qpkt,r:mask)                ==> b:ref(Qpkt);
-- RegClosedGroup: (a:Qpkt,r:mask)                ==> b:ref(Qpkt);
-- FindPush:       (a:Qpkt)                       ==> b:ref(Qpkt);
-- SameMemLastUsed: (a:Qpkt)                      ==> b:ref(Qpkt);
--
-- Search intervall for an instruction:
---------------------------------------
-- RegsReadUnmodified:  (b:Qpkt,a:Qpkt)           ==> n:Qpkt;
-- RegNextWrite:        (b:Qpkt,a:Qpkt,r:mask)    ==> n:Qpkt;
--
-- Search intervall checking a condition:
-----------------------------------------
-- RegUnused:           (n:Qpkt,a:Qpkt,r:mask)    ==> boolean;
-- RegUnRead:           (n:Qpkt,a:Qpkt,r:mask)    ==> boolean;
-- RegUnWritten:        (n:Qpkt,a:Qpkt,r:mask)    ==> boolean;
-- StackEqual:          (n:Qpkt,a:Qpkt)           ==> boolean;
-- SameMemUsed:         (n:Qpkt,a:Qpkt)           ==> boolean;
-- SameMemWritten:      (b:Qpkt,a:Qpkt)           ==> boolean;

%page
%+D Routine mPRINT2; import infix(string) ms; ref(Qpkt) b,a;
%+D begin ref(Qpkt) qi; qi:=b;
%+D       outstring("=== Massage Scheme "); outstring(ms); printout(sysout);
%+D       repeat if qi=a then ListQinstr("a:    ",qi,false)
%+D           elsif qi=b then ListQinstr("b:    ",qi,false)
%+D           else  ListQinstr("      ",qi,false)  endif;
%+D       while qi <> a do qi:=qi.next endrepeat;
%+D end;

%+D Routine mPRINT3; import infix(string) ms; ref(Qpkt) c,b,a;
%+D begin ref(Qpkt) qi; qi:=c;
%+D       outstring("=== Massage Scheme "); outstring(ms); printout(sysout);
%+D       repeat if qi=a then ListQinstr("a:    ",qi,false)
%+D           elsif qi=b then ListQinstr("b:    ",qi,false)
%+D           elsif qi=c then ListQinstr("c:    ",qi,false)
%+D           else  ListQinstr("      ",qi,false)  endif;
%+D       while qi <> a do qi:=qi.next endrepeat;
%+D end;

%+D Routine mBEGIN; import infix(string) ms;
%+D begin outstring("=== Begin m"); outstring(ms); printout(sysout) end;

%+D Routine mTERM; import infix(string) ms; range(0:MaxByte) trm;
%+D begin outstring("=== End   m"); outstring(ms);
%+D       if trm<>0 then outstring("   Exit=E"); outword(trm) endif;
%+D       printout(sysout);
%+D end;

Routine fmfSize; import range(0:7) fmf; export range(0:10) res;
begin
%+D   if listq2 > 1 then                                   ---MY 12/11
%+D   outstring("fmfSize: "); outword(fmf); printout(sysout) endif;

      case 0:7 (fmf)
      when FMF_REAL: res:=4; when FMF_LREAL: res:=8;
      when FMF_INT:  res:=4; when FMF_SINT:  res:=2;
      when FMF_TEMP: res:=10
      endcase
end; -- fmfSize

--- %-D macro RegsWrittenDies(2)
--- %-D begin
--- %-D       RegDies(%1,wAND(wNOT(uMask(%2)),%1 .write));
--- %-D endmacro;

Routine RegsWrittenDies;
import ref(Qpkt) qi; range(0:255) rw; export Boolean res;
-- Check that all register written by qi except rw dies
begin
%+D   RST(R_RegsWrittenDies);
%+D   res:=RegDies(qi, wAND(wNOT(uMask(rw)),qi.write) );
%-D   res:=RegDies(qi,%wAND(wNOT(uMask(rw)),qi.write)%);
end;

Routine RegNextUsed;
import ref(Qpkt) b,a; range(0:MaxWord) rMask; export ref(Qpkt) n;
-- Find first 'n' in [b,a> which use any register in 'rMask'.
-- Otherwise: return n=a.
begin range(0:MaxWord) write; n:=b; repeat while n <> a
      do if n.fnc=qJMP then write:=0 else write:=n.write endif;
         if wAND(wOR(write,n.read),rMask) <> 0 then goto E endif;
         n:=n.next;
      endrepeat;
E:end;

Routine RegNextWrite;
import ref(Qpkt) b,a; range(0:MaxWord) rMask; export ref(Qpkt) n;
-- Find first 'n' in [b,a> which writes any register in 'rMask'.
-- Otherwise: return n=a.
begin range(0:MaxWord) write; n:=b; repeat while n <> a
      do if n.fnc=qJMP then -- OK
         elsif wAND(n.write,rMask) <> 0 then goto E endif;
         n:=n.next;
      endrepeat;
E:end;

Routine RegLastUsed;
import ref(Qpkt) qi; range(0:MaxWord) rMask; export ref(Qpkt) res;
begin range(0:MaxWord) write;
%+D   range(0:MaxWord) nPrev; nPrev:=0;
%+D   RST(R_RegLastUsed);
      repeat qi:=qi.pred while qi <> none
      do case 0:qMXX (qi.fnc)
         when qJMP: write:=0
         when qFDEST,qBDEST,qLABEL,qENTER,qJMPM,
%-E           qJMPFM,qDOS2,
              qCALL,qRET,qIRET,qLEAVE: res:=none; goto E1;
         otherwise write:=qi.write
         endcase;
         if wAND(wOR(qi.read,write),rMask) <> 0 then res:=qi; goto E2 endif;
%+D      nPrev:=nPrev+1;
      endrepeat;
      res:=none;
E1:E2:
%+D   if (TLIST>4) and (nPrev > 50)
%+D   then Ed(errmsg,"RegLastUsed:nPrev=");
%+D        EdWrd(errmsg,nPrev); WARNING("  ");
%+D   endif;
end;

Routine RegLastWrite;
import ref(Qpkt) qi; range(0:MaxWord) rMask; export ref(Qpkt) res;
begin
%+D   range(0:MaxWord) nPrev; nPrev:=0;
%+D   RST(R_RegLastWrite);
      repeat qi:=qi.pred while qi <> none
      do case 0:qMXX (qi.fnc)
         when qJMP: -- OK
         when qFDEST,qBDEST,qLABEL,qENTER,qJMPM,
%-E           qJMPFM,qDOS2,
              qCALL,qRET,qIRET,qLEAVE: goto E1;
         otherwise if wAND(qi.write,rMask) <> 0 then res:=qi; goto E2 endif;
         endcase;
%+D      nPrev:=nPrev+1;
      endrepeat;
E1:   res:=none;
E2:
%+D   if (TLIST>4) and (nPrev > 50)
%+D   then Ed(errmsg,"RegLastWrite:nPrev=");
%+D        EdWrd(errmsg,nPrev); WARNING("  ");
%+D   endif;
end;

Routine RegOneshot;
import ref(Qpkt) a; range(0:MaxWord) rMask; export ref(Qpkt) b;
-- Finn b slik at    o r skrives i b,
--                   o r d|r i a,
--                   o r ubrukt <b,a>,
-- eller returner at slik b ikke fins. --
begin
%+D   RST(R_RegOneShot);
      if RegDies(a,rMask)
      then b:=RegLastUsed(a,rMask);
           if b <> none
           then if wAND(b.write,rMask)<>rMask
                then b:=none endif;
           endif;
      else b:=none endif;
end;

Routine RegClosedGroup;
import ref(Qpkt) a; range(0:MaxWord) rMask; export ref(Qpkt) b;
-------------------------------------------------------------------------
--   A group of instructions (b,a) is said to be closed with regard    --
--   to a set of registers R iff R is dead in both b and a.            --
-------------------------------------------------------------------------
-- Find b such that  o All parts of R is written before read in (b,a>  --
--                   o All parts of R is written before read in (a,-]  --
-- otherwise return b = none                                           --
-------------------------------------------------------------------------
begin range(0:MaxWord) w; w:=0; b:=none;
      if rMask=0 then -- Nothing
      elsif RegDeadIn(a,rMask)
      then repeat a:=a.pred while a <> none
           do case 0:qMXX (a.fnc)
              when qFDEST,qBDEST,qLABEL,qENTER,qJMP,qJMPM,
%-E                qJMPFM,qDOS2,
                   qCALL,qRET,qIRET,qLEAVE: goto E1;
              endcase
              w:=wOR(a.write,w);
              if wAND(w,rMask)=rMask then b:=a; goto E2 endif;
              w:=wAND(w,wNOT(a.read));
           endrepeat;
      endif;
E1:E2:end;

Routine RegDeadIn;
import ref(Qpkt) qi; range(0:MaxWord) rMask; export Boolean res;
begin rMask:=wAND(rMask,wNOT(qi.write));
      if rMask=0 then res:=true
      else res:=CheckRegFree(qi.next,rMask) endif;
end;


--- Routine StackModification; import ref(Qpkt) a; export short integer res;
    Routine StaxxModification; import ref(Qpkt) a; export short integer res;
begin 

----- FORSLAG FRA MY: Bytt ut linja nedenfor med:         ---MY 10/12-86
----- if wAND(a.write,uSP)=0 then res:=0                  ---MY 10/12-86
%+D %-E if wAND(wOR(a.read,a.write),uSP)=0 then res:=0
%+D %+E if wAND(wOR(a.read,a.write),uESP)=0 then res:=0
%+D         else
%+D        RST(R_StackModification);
           res:=qSP_;
           case 0:qMXX (a.fnc)
           when qPUSHR,qPUSHC,qPUSHA: res:=   AllignFac
           when qPOPR:                res:= - AllignFac
           when qPUSHM:  res:=   wAllign(%a qua Qfrm4.aux.val%)
           when qPOPK:   res:= - wAllign(%a qua Qfrm2.aux.val%)
           when qPOPM:   res:= - wAllign(%a qua Qfrm4.aux.val%)
           when qDYADC:
%-E             if a.reg=qSP  then case 0:19 (a.subc)
%+E             if a.reg=qESP then case 0:19 (a.subc)
                   when qSUB,qSUBF: res:=   a qua Qfrm2.aux.val
                   when qADD,qADDF: res:= - a qua Qfrm2.aux.val
                endcase endif
           when qCALL:   if    a.subc = qEXIT then -- OK
                         else res:= -wAllign(%a qua Qfrm5.aux%) endif
           when qADJST:  res:=wAllign(%a qua Qfrm2.aux.val%)
           when qFPUSH:  case 0:6 (a.reg)
                         when FMF_SINT: res:=AllignFac
                         when FMF_INT,FMF_REAL: res:=4
                         when FMF_LREAL: res:=8
%-E                      otherwise res:=10 endcase;
%+E                      otherwise res:=12 endcase;
           when qFPOP:   case 0:6 (a.reg)
                         when FMF_SINT: res:= -AllignFac
                         when FMF_INT,FMF_REAL: res:= -4
                         when FMF_LREAL: res:= -8
%-E                      otherwise res:= -10 endcase;
%+E                      otherwise res:= -12 endcase;
           endcase;
%+D      endif;
end;


Routine FindPush2; import ref(Qpkt) qi; export ref(Qpkt) res;
--- set stackMod1==-stackModification(qi)
---     stackMod2== stackModification(res) iff res<>none
begin short integer s,t,n;
%+D   range(0:MaxWord) nPrev; nPrev:=0;
%+D   RST(R_FindPush2);
      res:=none; CallSeen:=false; -- EvalSeen:=false;
      stackMod1:=s:=t:=-StackModification(qi);
      repeat qi:=qi.pred while qi <> none
      do case 0:qMXX (qi.fnc)
         when qFDEST,qBDEST,qLABEL,qENTER,qJMP,qJMPM,
%-E           qJMPFM,
              qRET,qIRET,qLEAVE: res:=none; goto E1;
     --  when qEVAL: EvalSeen:=true;
         when qCALL: CallSeen:=true;
         endcase;
         n:=StackModification(qi); if n=qSP_ then goto E2 endif;
         t:=t-n;
         if t<s
         then if qi.fnc<>qADJST
              then
%+D                if listsw <> 0
%+D                then outstring("*** FindPush2: s="); outword(s);
%+D                     outstring(", t="); outword(t);
%+D                     outstring(", n="); outword(n); outimage;
%+D                endif;
                   if (s-t)=n then res:=qi; stackMod2:=n endif;
              endif;
              goto E3;
         endif
%+D      nPrev:=nPrev+1;
      endrepeat;
E1:E2:E3:
%+D   if (TLIST>4) and (nPrev > 50)
%+D   then Ed(errmsg,"FindPush2:nPrev=");
%+D        EdWrd(errmsg,nPrev); WARNING("  ");
%+D   endif;
%+D  if listq1 > 1 then ListQinstr("FindPush2:",res,false) endif;
end; -- FindPush2

%+D Routine FindPush; import ref(Qpkt) a; export ref(Qpkt) res;
%+D begin
%+D %+D   RST(R_FindPush);
%+D       res:=FindPush2(a);
%+D       if res<>none then
---          if (StackModification(a)+StackModification(res))<>0 then
%+D          if (stackMod2-stackMod1)<>0 then
%+D             IERR("MASS.FindPush"); res:=none
%+D          endif
%+D       endif
%+D end; -- FindPush

Routine StackEqual; import ref(Qpkt) n,a; export Boolean res;
begin short integer t,j;
%+D   RST(R_StackEqual);
      res:=false; t:=0;
      if (n.fnc=qADJST) or (a.fnc=qADJST) then goto E3 endif;
      repeat while n <> a
      do j:=StackModification(n); if j=qSP_ then goto E1 endif;
         t:=t+j; if t<0 then goto E2 endif;
         n:=n.next;
      endrepeat;
      res:= t=0;
E1:E2:E3:
-- %+D   if listsw <> 0
-- %+D   then outstring("*** StackEqual="); if res then outstring("True");
-- %+D        else outstring("False") endif; outimage;
-- %+D   endif;
end;

Routine StackEqual2; import ref(Qpkt) n,a; export Boolean res;
begin short integer t,j;
%+D   RST(R_StackEqual);
      res:=false; t:=0;
      if (n.fnc=qADJST) or (a.fnc=qADJST) then goto E3 endif;
      repeat
         j:=StackModification(n); if j=qSP_ then goto E1 endif;
         t:=t+j; if t>0 then goto E2 endif;
      while n <> a do n:=n.next endrepeat;
      res:= t=0;
E1:E2:E3:
-- %+D   if listsw <> 0
-- %+D   then outstring("*** StackEqual2="); if res then outstring("True");
-- %+D        else outstring("False") endif; outimage;
-- %+D   endif;
end;

%-E Routine SameNPXStack; import ref(Qpkt) b,a; export Boolean res;
%-E begin short integer t; t:=0;
%-E       repeat case 0:qMXX (b.fnc)
%-E              when qFDYAD: t:=t-1; if b.subc=qFCOM then t:=t-1 endif;
%-E              when qFDYADM: if b.subc=qFCOM then t:=t-1 endif;
%-E              when qFPUSH,qFSTP: t:=t-1
%-E              when qFPOP,qFLD,qFLDC,qFDUP,qFLDCK: t:=t+1
%-E              endcase;
%-E       while b <> a do b:=b.next endrepeat;
%-E       res:= t=0;
%-E end;

Routine RegsReadUnmodified; import ref(Qpkt) b,a; export ref(Qpkt) n;
-- Find first 'n' in <b,a> which writes something read by 'b'.
-- Otherwise: return n=a.
begin range(0:MaxWord) bread; n:=b;
%+D   RST(R_RegsReadUnmodified);
      if n=a then goto E1 endif; bread:=b.read;
%-E   if a.fnc=qPOPR then bread:=wAND(bread,wNOT(uSP)) endif;
%+E   if a.fnc=qPOPR then bread:=wAND(bread,wNOT(uESP)) endif;
      repeat n:=n.next while n <> a
      do if n.fnc=qJMP then -- OK
         elsif wAND(bread,n.write) <> 0 then goto E2 endif;
      endrepeat;
E1:E2:end;

Routine MaaaRegUnused; -- Try to Make register (r) Unused in [n,a>
import ref(Qpkt) n,a; range(0:nregs) r; export Boolean res;
begin if RegUnused(n,a,uMask(r)) then res:=true
      elsif MASSLV > 33
      then if wAND(n.read,uMask(r))<>0 then res:=false
           else res:=MakeRegUnused(n,a,r) endif;
      else res:=false endif;
end;

Routine RegUnused; -- Check register(s) Unused in [n,a>
import ref(Qpkt) n,a; range(0:MaxWord) rMask; export Boolean res;
begin range(0:MaxWord) write;
%+D   RST(R_RegUnused);
      repeat while n <> a
      do if n.fnc=qJMP then write:=0 else write:=n.write endif;
         if wAND(wOR(n.read,write),rMask) <> 0
         then res:=false; goto E endif;
         n:=n.next;
      endrepeat;
      res:=true;
E:end;

--- not used:
--- Routine MaaaRegUnRead; -- Try to Make register (r) Unread in [n,a>
--- import ref(Qpkt) n,a; range(0:nregs) r; export Boolean res;
--- begin if RegUnread(n,a,uMask(r)) then res:=true
--- ---   elsif MASSLV > 33
--- ---   then if wAND(n.read,uMask(r))<>0 then res:=false
--- ---        else res:=MakeRegUnused(n,a,r) endif;
---       else res:=false endif;
--- end;

Routine RegUnRead; -- Check register(s) Unread in [n,a>
import ref(Qpkt) n,a; range(0:MaxWord) rMask; export Boolean res;
begin 
%+D   RST(R_RegUnused);
      repeat while n <> a
      do if wAND(n.read,rMask) <> 0
         then res:=false; goto E endif;
         n:=n.next;
      endrepeat;
      res:=true;
E:end;

Routine MaaaRegUnWritten; -- Try to Make register (r) UnWritten in [n,a>
import ref(Qpkt) n,a; range(0:nregs) r; export Boolean res;
begin if RegUnWritten(n,a,uMask(r)) then res:=true
      elsif MASSLV > 33 then res:=MakeRegUnWritten(n,a,r) endif;
end;


Routine RegUnWritten; -- Check register(s) Unwritten in [n,a>
import ref(Qpkt) n,a; range(0:MaxWord) rMask; export Boolean res;
begin 
%+D   RST(R_RegUnused);
      if rMask=0 then res:=true
      else repeat while n <> a
           do if n.fnc=qJMP then -- OK
              elsif wAND(n.write,rMask) <> 0
              then res:=false; goto E endif;
              n:=n.next;
           endrepeat;
           res:=true;
      endif;
E:end;

Routine getOprRegs;
%-E import range(0:maxbyte) sbireg; export range(0:MaxWord) rMask;
%+E import infix(MemAddr) opr; export range(0:MaxWord) rMask;
begin
%-E   range(0:MaxByte) segreg,bireg;
%+E   range(0:nregs) r;
%-E   segreg:=bAND(sbireg,oSREG);
%-E   if    segreg=oES then rMask:=uES
%-E   elsif segreg=oDS then rMask:=uDS
%-E   else  rMask:=0 endif;
%-E   bireg:=bAND(sbireg,rmBIREG);
%-E   if bireg <> 0
%-E   then case 0:7 (bAND(bireg,7))
%-E        when 0: rMask:=wOR(rMask,wOR(uBX,uSI))
%-E        when 1: rMask:=wOR(rMask,wOR(uBX,uDI))
%-E        when 2: rMask:=wOR(rMask,wOR(uBP,uSI))
%-E        when 3: rMask:=wOR(rMask,wOR(uBP,uDI))
%-E        when 4: rMask:=wOR(rMask,uSI) when 5: rMask:=wOR(rMask,uDI)
%-E        when 6: rMask:=wOR(rMask,uBP) when 7: rMask:=wOR(rMask,uBX)
%-E        endcase;
%-E   endif;
%+E   r:=GetBreg(opr); if r=0 then rMask:=0 else rMask:=uMask(r) endif;
%+E   r:=GetIreg(opr); if r<>0 then rMask:=wOR(rMask,uMask(r)) endif;
end;
%title ***   M a k e    R e g i s t e r    U n u s e d   ***

Routine MakeRegUnused; -- Try to Make register (r) Unused in (b,a)
import ref(Qpkt) b,a; range(0:nregs) r; export Boolean res;
begin ref(Qpkt) bb,aa,n; range(0:nregs) r1; range(0:MaxWord) uR,uRx,uUsed;
      if RegUnused(b,a,uMask(r)) then res:=true; goto E1 endif;
      r:=WholeReg(r); uR:=uMask(r); uUsed:=0; res:=false;
%+E   if r=qESP then goto EXX endif;
      if wAND(a.write,uR)=uR then -- OK
      elsif CheckRegFree(a.next,wAND(wNOT(a.write),uR)) then -- OK
      else goto E2 endif;
      bb:=RegNextUsed(b,a,uR);
%+C   if bb=a then IERR("MakeRegUnused-1") endif;
      if wAND(bb.read,uR)<>0 then goto E3 endif;
      uRx:=wAND(uR,wNOT(bb.write));
      if uRx <> 0 --- Must also check that other part is first written after bb
      then n:=RegNextUsed(bb,a,uRx);
%+D        if listq1 > 1 then ListQinstr("n:    ",n,false) endif;
           if n <> a then if wAND(n.read,uRx)<>0 then goto E4 endif endif;
      endif;
%+D   if listq1 > 1 then ListQinstr("b:    ",b,false) endif;
%+D   if listq1 > 1 then ListQinstr("bb:   ",bb,false) endif;
      if wAND(a.read,uR)<>0 then aa:=a
      else aa:=RegLastUsed(a,uR); if aa=none then goto E5 endif endif;
%+D   if listq1 > 1 then ListQinstr("aa:   ",aa,false) endif;
%+D   if listq1 > 1 then ListQinstr("a:    ",a,false) endif;
%-E   if    r=qDS then res:=ChangeReg(qDS,qES,bb,aa)
%-E   elsif r=qES then res:=ChangeReg(qES,qDS,bb,aa)
%-E   else
           n:=bb; repeat uUsed:=wOR(uUsed,wOR(n.read,n.write));
           while n <> aa do n:=n.next endrepeat;
           uUsed:=wAND(wNOT(uUsed),uAX+uBX+uCX+uDX+uSI+uDI);
           repeat r1:=GetFreeReg(aa,uUsed) while r1 <> 0
           do if ChangeReg(r,r1,bb,aa) then res:=true; goto E6
              else uUsed:=wAND(uUsed,wNOT(uMask(r1))) endif;
           endrepeat;
%-E   endif;
%+E EXX:
E1:E2:E3:E4:E5:E6:end;

Routine MakeRegUnWritten; -- Try to Make register (r) Unwritten in [b,a>
import ref(Qpkt) b,a; range(0:nregs) r; export Boolean res;
begin ref(Qpkt) bb,aa,n; range(0:nregs) r1; range(0:MaxWord) uR,uRx,uUsed;
      if RegUnWritten(b,a,uMask(r)) then res:=true; goto E1 endif;
      r:=WholeReg(r); uR:=uMask(r); uUsed:=0; res:=false;
%+E   if r=qESP then goto EXX endif;
      if wAND(a.write,uR)=uR then -- OK
      elsif CheckRegFree(a.next,wAND(uR,wNOT(a.write))) then -- OK
      else goto E2 endif;
      bb:=RegNextWrite(b,a,uR);
%+C   if bb=a then IERR("MakeRegUnWritten-1") endif;
      uRx:=wAND(uR,wNOT(bb.write));
      if uRx <> 0 --- Must also check that other part is first written after bb
      then n:=RegNextUsed(bb.next,a,uRx);
%+D        if listq1 > 1 then ListQinstr("n:    ",n,false) endif;
           if n <> a then if wAND(n.read,uRx)<>0 then goto E3 endif endif;
      endif;
%+D   if listq1 > 1 then ListQinstr("bb:   ",bb,false) endif;
      if wAND(a.read,uR)<>0 then aa:=a
      else aa:=RegLastUsed(a,uR); if aa=none then goto E4 endif endif;
%+D   if listq1 > 1 then ListQinstr("aa:   ",aa,false) endif;
%-E   if    r=qDS then res:=ChangeReg(qDS,qES,bb,aa)
%-E   elsif r=qES then res:=ChangeReg(qES,qDS,bb,aa)
%-E   else
           n:=bb; repeat uUsed:=wOR(uUsed,wOR(n.read,n.write));
           while n <> aa do n:=n.next endrepeat;
           uUsed:=wAND(wNOT(uUsed),uAX+uBX+uCX+uDX+uSI+uDI);
           repeat r1:=GetFreeReg(aa,uUsed) while r1 <> 0
           do if ChangeReg(r,r1,bb,aa) then res:=true; goto E5
              else uUsed:=wAND(uUsed,wNOT(uMask(r1))) endif;
           endrepeat;
%-E   endif;
%+E EXX:
E1:E2:E3:E4:E5:end;
%title ***   R e g i s t e r     S u b s t i t u t i o n   ***
--- %-D macro SubstReg(3);
--- %-D begin (if WholeReg(%1)=%2 then SubxxReg(%1,%3) else %1) endmacro
--- %-D Routine SubxxReg; import range(0:nregs) r,     r2;
    Routine SubstReg; import range(0:nregs) r,whr1,r2;
    export range(0:nregs) res;
    begin
      if WholeReg(r)=whr1 then
           if    r <= qBL  then res:=LowPart(%r2%)
           elsif r <= qBH  then res:=HighPart(%r2%)
%+E        elsif r >= qEAX then res:=WholeReg(r2)
           else                 res:=WordReg(r2)   endif;
           if res<>r then Changeable:=true endif; -- makeregmap-flag
      else res:=r endif;
end;

%-D macro CheckSubstReg(3);
%-D begin if WholeReg(%1)=%2 then ChexxSubstReg(%1,%3) endif endmacro
%-D Routine ChexxSubstReg; import range(0:nregs) r,r2;
%+D Routine CheckSubstReg; import range(0:nregs) r,whr1,r2;
    begin
%+D   if WholeReg(r)=whR1 then
           if    r <= qBH
           then if not RegParts(WholeReg(r2)) then Changeable:=false endif
%+E        elsif r >= qEAX then
           elsif WordReg(r2)=0 then Changeable:=false endif
%+D   endif;
end;

Routine SubstOpr; import ref(Qpkt) b; range(0:nregs) whr1,r2;
begin range(0:nregs) ir,br;
%-E   range(0:MaxByte) sbireg,segreg,bireg,oldreg; boolean oldchg;
%+E   range(0:MaxByte) sibreg;
%-E   oldreg:=sbireg:=b qua Qfrm3.opr.sbireg; oldchg:=Changeable;
%-E   segreg:=bAND(sbireg,oSREG);
%-E   if segreg <> 0
%-E   then if    segreg=oES
%-E        then sbireg:=SetSBIreg(sbireg,SubstReg(qES,whr1,r2));
%-E        elsif segreg=oDS
%-E        then sbireg:=SetSBIreg(sbireg,SubstReg(qDS,whr1,r2));
%-E        endif;
%-E        b qua Qfrm3.opr.sbireg:=sbireg;
%-E   endif;
---   bireg:=bAND(b qua Qfrm3.opr.sbireg,rmBIREG);
%-E   bireg:=bAND(sbireg,                rmBIREG);
%-E   if bireg <> 0
%-E   then br:=GetBreg(b qua Qfrm3.opr); ir:=GetIreg(b qua Qfrm3.opr);
%-E        sbireg:=bAND(sbireg,oSREG);
%-E        if br <> 0 then sbireg:=SetSBIreg(sbireg,SubstReg(br,whr1,r2)) endif;
%-E        if ir <> 0 then sbireg:=SetSBIreg(sbireg,SubstReg(ir,whr1,r2)) endif;
%-E        b qua Qfrm3.opr.sbireg:=sbireg;
%-E   endif;
%-E   if sbireg = oldreg then Changeable:=oldchg endif;
%+E   sibreg:=b qua Qfrm3.opr.sibreg;
%+E   if sibreg <> NoIBREG
%+E   then br:=bOR(qEAX,bAND(sibreg,BaseREG));
%+E        ir:=bOR(qEAX,bSHR(bAND(sibreg,IndxREG),3));
%+E        if br=ir --- I.e. No Base Register ---
%+E        then if ir<>qESP then br:=ir:=SubstReg(ir,whr1,r2) endif;
%+E        else if (br<>ir) or (br=qESP) then br:=SubstReg(br,whr1,r2) endif;
%+E             if ir<>qESP then ir:=SubstReg(ir,whr1,r2) endif;
%+E        endif;
%+E        b qua Qfrm3.opr.sibreg:=bAND(sibreg,ssMASK)+
%+E                          bAND(br,BaseREG)+bAND(bSHL(ir,3),IndxREG);
%+E        Changeable:=true; -- makeregmap-flag
%+E   endif;
end;

%-E Routine CheckSubstOpr; import ref(Qpkt) b; range(0:nregs) r1,r2;
%-E begin range(0:MaxByte) sbireg,segreg; range(0:nregs) br,ir,rx;
%-E   sbireg:=b qua Qfrm3.opr.sbireg; segreg:=bAND(sbireg,oSREG);
%-E   if segreg <> 0
%-E   then if    segreg=oES
%-E        then if r1=qES then if r2<>qDS then goto F1 endif endif
%-E        elsif segreg=oDS
%-E        then if r1=qDS then if r2<>qES then goto F2 endif endif
%-E        endif;
%-E   endif;
%-E   if bAND(b qua Qfrm3.opr.sbireg,rmBIREG) <> 0
%-E   then br:=GetBreg(b qua Qfrm3.opr); ir:=GetIreg(b qua Qfrm3.opr);
%-E        if br <> 0 then br:=SubstReg(br,WholeReg(r1),r2) endif;
%-E        if ir <> 0 then ir:=SubstReg(ir,WholeReg(r1),r2) endif;
%-E        if (br=qSI) or (br=qDI) or (ir=qBX) or (ir=qBP)
%-E        then rx:=br; br:=ir; ir:=rx endif;
%-E        if (br=qBX) or (br=qBP) or (br=0)
%-E        then if ir=0 then elsif ir=qSI then elsif ir=qDI then -- ALL OK
%-E             else  Changeable:=false endif;
%-E        else F1:F2:  Changeable:=false endif;
%-E   endif;
%-E end;

Routine ChangeReg;
import range(0:nregs) r1,r2; ref(Qpkt) b,a;
export Boolean res;
begin ref(Qpkt) qi,next; range(0:nregs) r,aR,dR,whR1; range(0:MaxByte) s;
      qi:=b; Changeable:=(MASSLV>32); res:=false;

%+D   if listq1>1
%+D   then outstring("=== Change Reg "); edreg(sysout,r1);
%+D        outstring(" ==> "); edreg(sysout,r2); mPRINT2(" ===",b,a);
%+D   endif;

      if b=a
      then case 0:qMXX (b.fnc)
%-E        when qLOADSC: if b.subc <> r1 then goto A1 endif;
           when qPOPM:                                goto A2
%-E        when qPUSHC,qFPUSH,qFPOP:                  goto A3
%+E        when qFLD,qFLDC,qFST,qFSTP,qFDYAD,qFDYADM: goto A3
           endcase; Changeable:=false;
      elsif wAND(wOR(a.read,b.write),uMask(r2)) <> 0 then Changeable:=false
      elsif not RegUnused(b.next,a,uMask(r2)) then Changeable:=false
      else
%-E A1:
A2:A3:    if not CheckRegFree(a,uMask(r2)) then Changeable:=false endif;
      endif;

      if not changeable then goto E0 endif;
      whR1:=Wholereg(r1);
      repeat --- TEST IF SUBSTITUTION IS POSSIBLE ---
      case 0:qMXX (qi.fnc);
      when qPUSHM, ------ PUSHM   const opr ----------------- Format 4
           qMOVMC, ------ MOVMC   width const opr ----------- Format 4
                   ------ MOVMC   width fld opr addr -------- Format 4b
           qMONADM, ----- MONADM  subc width opr ------------ Format 3
           qDYADMC, ----- DYADMC  subc width const opr ------ Format 4
                    ----- DYADMC  subc width fld opr addr --- Format 4b
%-E        qJMPFM, ------ JMPFM   opr ----------------------- Format 3
           qJMPM: ------- JMPM    opr ----------------------- Format 3
%-E        CheckSubstOpr(qi,r1,r2);
      when qPUSHR, ------ PUSHR   reg ----------------------- Format 1
           qPOPR: ------- POPR    reg ----------------------- Format 1
           CheckSubstReg(qi.subc,whr1,r2);
      when qPUSHC: ------ PUSHC   reg const ----------------- Format 2
                   ------ PUSHC   reg fld addr -------------- Format 2b
%-E        if CPUID < iAPX186 then CheckSubstReg(qi.reg,r1,r2) endif;
      when qPUSHA, ------ PUSHA   reg opr ------------------- Format 3
           qLOADA, ------ LOADA   reg opr ------------------- Format 3
           qLOAD, ------- LOAD    subc reg ofst opr nrep ---- Format 4c
           qSTORE: ------ STORE   reg opr ------------------- Format 3
           CheckSubstReg(qi.reg,whr1,r2);
%-E        if Changeable then CheckSubstOpr(qi,r1,r2) endif;
      when qPOPM: ------- POPM    reg const opr ------------- Format 4
           if UnAlligned(%qi qua Qfrm4.aux.LO%)
           then CheckSubstReg(qi.reg,whr1,r2) endif;
%-E        if Changeable then CheckSubstOpr(qi,r1,r2) endif;
      when qLOADC: ------ LOADC   reg const ----------------- Format 2
                   ------ LOADC   reg fld addr -------------- Format 2b
%-E        if r2 >= qES then
%-E        if qi.reg=r1 then Changeable:=false endif endif;
           CheckSubstReg(qi.reg,whr1,r2);
%-E   when qLOADSC: ----- LOADSC  sreg reg fld addr --------- Format 2b
%-E        CheckSubstReg(qi.subc,whr1,r2);
%-E        CheckSubstReg(qi.reg,whr1,r2);
%-E   when qLDS: -------- LDS     reg ofst opr nrep --------- Format 4c
%-E        if (r1=qDS) then
%-E        if (r2 <> qES) then goto CF1 endif endif;
%-E        CheckSubstReg(qi.reg,whr1,r2);
%-E        if Changeable then CheckSubstOpr(qi,r1,r2) endif;
%-E   when qLES: -------- LES     reg ofst opr nrep --------- Format 4c
%-E        if (r1=qES) then
%-E        if (r2 <> qDS) then goto CF2 endif endif;
%-E        CheckSubstReg(qi.reg,whr1,r2);
%-E        if Changeable then CheckSubstOpr(qi,r1,r2) endif;
%+E   when qBOUND: ------ BOUND   reg opr ------------------- Format 3
%+E        CheckSubstReg(qi.reg,whr1,r2);
      when qXCHGM: ------ XCHGM   reg opr ------------------- Format 3
           if WAND(uMask(qi.reg),uMask(r1)) <> 0
           then if (qi=a) or (qi=b) then goto CF3 endif endif;
           CheckSubstReg(qi.reg,whr1,r2);
%-E        if Changeable then CheckSubstOpr(qi,r1,r2) endif;
      when qXCHG: ------- XCHG    reg reg2 ------------------ Format 2
           if (WAND(uMask(qi.reg),uMask(r1)) <> 0)
           or (WAND(uMask(qi qua Qfrm2.aux.val),uMask(r1)) <> 0)
           then if (qi=a) or (qi=b) then goto CF4 endif endif;
           goto MV1;
      when qMOV: -------- MOV     reg reg2 ------------------ Format 2
      MV1: CheckSubstReg(qi.reg,whr1,r2);
           if Changeable then CheckSubstReg(qi qua Qfrm2.aux.val,whr1,r2) endif;
      when qMONADR, ----- MONADR  subc reg ------------------ Format 2
           qDYADC, ------ DYADC   subc reg const ------------ Format 2
                   ------ DYADC   subc reg fld addr --------- Format 2b
           qCONDEC: ----- CONDEC  subc reg ------------------ Format 2
           if WAND(uMask(qi.reg),uMask(r1)) <> 0
           then if (qi=a) or (qi=b) then Changeable:=false endif endif;
           CheckSubstReg(qi.reg,whr1,r2);
      when qDYADR: ------ DYADR   subc reg reg2 ------------- Format 2
           if WAND(uMask(qi.reg),uMask(r1)) <> 0
           then if (qi=a) or (qi=b) then goto CF5 endif endif;
           CheckSubstReg(qi qua Qfrm2.aux.val,whr1,r2);
           CheckSubstReg(qi.reg,whr1,r2);
      when qSHIFT: ------ SHIFT   subc reg CL --------------- Format 2
           if WAND(uMask(qi.reg),uMask(r1)) <> 0
           then if (qi=a) or (qi=b) then Changeable:=false endif endif;
           if whr1=WholeReg(qCX) then Changeable:=false
           else CheckSubstReg(qi.reg,whr1,r2) endif;
      when qDYADM, ------ DYADM   subc reg opr -------------- Format 3
           qDYADMR: ----- DYADMR  subc reg opr -------------- Format 3
           if WAND(uMask(qi.reg),uMask(r1)) <> 0
           then if (qi=a) or (qi=b) then goto CF6 endif endif;
           CheckSubstReg(qi.reg,whr1,r2);
%-E        if Changeable then CheckSubstOpr(qi,r1,r2) endif;
      when qTRIADR: ----- TRIADR  subc reg ------------------ Format 2
           s:=RegSize(qi.reg); aR:=accreg(s); dR:=extreg(s);
           if whr1=WholeReg(aR) then Changeable:=false
        elsif whr1=WholeReg(dR) then Changeable:=false
           else CheckSubstReg(qi.reg,whr1,r2) endif;
      when qTRIADM: ----- TRIADM  subc width opr ------------ Format 3
           if qi.reg<qw_W then aR:=qAL; dR:=qAH else aR:=qAX; dR:=qDX endif;
           if whr1=WholeReg(aR) then Changeable:=false
        elsif whr1=WholeReg(dR) then Changeable:=false
%-E        else CheckSubstOpr(qi,r1,r2);
           endif;
      when qCWD: -------- CWD   width ----------------------- Format 1
%-E        aR:=qAX; dR:=qDX;
%+E        if qi.subc=qAL then aR:=qAL; dR:=qAH;
%+E        else aR:=qAX; dR:=qDX endif;
           if whr1=WholeReg(aR) then Changeable:=false
        elsif whr1=WholeReg(dR) then Changeable:=false endif;
      when qRSTRB, ------ RSTRB   subc dir rep -------------- Format 2
           qRSTRW: ------ RSTRB   subc dir rep -------------- Format 2
           if whr1=WholeReg(qCX) then Changeable:=false
%-E     elsif whr1=WholeReg(qES) then Changeable:=false
%-E     elsif whr1=WholeReg(qDI) then Changeable:=false
%+E     elsif whr1=WholeReg(qEDI) then Changeable:=false
           else case 0:6 (qi.subc)
           when qRMOV,qRCMP:
%-E             if whr1=WholeReg(qDS) then Changeable:=false
%-E          elsif whr1=WholeReg(qSI) then Changeable:=false endif;
%+E             if whr1=WholeReg(qESI) then Changeable:=false endif;
           when qZERO:
                if whr1=WholeReg(qAX) then Changeable:=false endif;
           when qRCMPS:
%-E             if whr1=WholeReg(qDS) then Changeable:=false
%-E          elsif whr1=WholeReg(qSI) then Changeable:=false
%+E             if whr1=WholeReg(qESI) then Changeable:=false
             elsif whr1=WholeReg(qAX) then Changeable:=false endif;
           when qRSCAS:
                if whr1=WholeReg(qAL) then Changeable:=false
             elsif whr1=WholeReg(qCX) then Changeable:=false endif;
           when qRSTOS:
                if whr1=WholeReg(qAL) then Changeable:=false endif;
           endcase endif;
      when qLAHF, ------- LAHF ------------------------------ Format 1
           qSAHF: ------- SAHF ------------------------------ Format 1
           if whr1=WholeReg(qAH) then Changeable:=false endif;
%-E   when qDOS2: ------- DOS2          --------------------- Format 1
%-E        if whr1=WholeReg(qAX) then Changeable:=false endif;
      when qENTER, ------ ENTER   const --------------------- Format 2
           qCALL, ------- CALL    subc pxlng addr ----------- Format 5
           qLEAVE, ------ LEAVE   const --------------------- Format 2
           qRET, -------- RET     const --------------------- Format 2
           qINT, -------- INT     const --------------------- Format 2
           qIRET: ------- IRET ------------------------------ Format 1
           Changeable:=false;
      when qFLD, -------- FLD     fmf opr ------------------- Format 3
           qFST, -------- FST     fmf opr ------------------- Format 3
           qFSTP: ------- FSTP    fmf opr ------------------- Format 3
%-E        CheckSubstOpr(qi,r1,r2);
%+E        if NUMID=WTLx167  --- ???????????
%+E        then if whr1=WholeReg(qEAX) then Changeable:=false endif;
%+E        endif;
      when qFLDC: ------- FLDC    sreg fmf lrv/rev/val ------ Format 3+
%-E        if whr1=WholeReg(qi.subc) then Changeable:=false endif;
%+E        if NUMID=WTLx167  --- ???????????
%+E        then if whr1=WholeReg(qEAX) then Changeable:=false endif;
%+E        endif;
%-E   when qFPUSH, ------ FPUSH   fSD fmf ------------------- Format 1
%-E        qFPOP: ------- FPOP    fSD fmf ------------------- Format 1
%-E        if whr1=WholeReg(qDI) then Changeable:=false endif;
      when qFDYAD: ------ FDYAD   subc ---------------------- Format 1
           if qi.subc = qFCOM
           then if whr1=WholeReg(qAX) then Changeable:=false endif;
           endif;
      when qFDYADM: ----- FDYADM  subc fmf opr -------------- Format 3
%-E        CheckSubstOpr(qi,r1,r2);
%+E        if NUMID=WTLx167  --- ???????????
%+E        then if whr1=WholeReg(qEAX) then Changeable:=false endif;
%+E        endif;
           if qi.subc = qFCOM
           then if whr1=WholeReg(qAX) then Changeable:=false endif;
           endif;
      endcase;
      if not Changeable then goto E1 endif;
      while qi <> a do qi:=qi.next endrepeat;

      qi:=b; res:=true;
      repeat next:=qi.next    --- PERFORM SUBSTITUTION: r1 ==> r2 ---
         Changeable:=false; --- used below as flag for call of makeregmap
      case 0:qMXX (qi.fnc);
      when qPUSHR: ------ PUSHR   reg ----------------------- Format 1
           if qi<>b then qi.subc:=SubstReg(qi.subc,whr1,r2) endif
      when qPOPR: ------- POPR    reg ----------------------- Format 1
           if qi<>a then qi.subc:=SubstReg(qi.subc,whr1,r2); endif;
      when qPUSHC: ------ PUSHC   reg const ----------------- Format 2
                   ------ PUSHC   reg fld addr -------------- Format 2b
%-E        if CPUID < iAPX186 then qi.reg:=SubstReg(qi.reg,whr1,r2); endif;
      when qPUSHA: ------ PUSHA   reg opr ------------------- Format 3
           qi.reg:=SubstReg(qi.reg,whr1,r2);
           if qi<>b then SubstOpr(qi,r1,r2) endif;
      when qLOADA: ------ LOADA   reg opr ------------------- Format 3
           if qi<>a then qi.reg:=SubstReg(qi.reg,whr1,r2); endif;
           if qi<>b then SubstOpr(qi,r1,r2); endif
      when qPOPK: ------- POPK    const --------------------- Format 2
      when qPOPM: ------- POPM    reg const opr ------------- Format 4
           if UnAlligned(%qi qua Qfrm4.aux.LO%)
           then qi.reg:=SubstReg(qi.reg,whr1,r2); endif;
           if qi<>b then SubstOpr(qi,r1,r2) endif
      when qLOADC: ------ LOADC   reg const ----------------- Format 2
                   ------ LOADC   reg fld addr -------------- Format 2b
           qi.reg:=SubstReg(qi.reg,whr1,r2);
%-E   when qLOADSC: ----- LOADSC  sreg reg fld addr --------- Format 2b
%-E        if qi<>a then qi.subc:=SubstReg(qi.subc,whr1,r2) endif;
%-E        qi.reg:=SubstReg(qi.reg,whr1,r2);
%-E   when qLDS: -------- LDS     reg ofst opr nrep --------- Format 4c
%-E        if qi<>a then if (r1=qDS) then qi.fnc:=qLES; Changeable:=true endif
%-E                      qi.reg:=SubstReg(qi.reg,whr1,r2) endif;
%-E        if qi<>b then SubstOpr(qi,r1,r2) endif;
%-E   when qLES: -------- LES     reg ofst opr nrep --------- Format 4c
%-E        if qi<>a then if (r1=qES) then qi.fnc:=qLDS; Changeable:=true endif
%-E                      qi.reg:=SubstReg(qi.reg,whr1,r2) endif;
%-E        if qi<>b then SubstOpr(qi,r1,r2) endif;
%+E   when qBOUND: ------ BOUND   reg opr ------------------- Format 3
%+E        if qi<>b then qi.reg:=SubstReg(qi.reg,whr1,r2);
%+E                      SubstOpr(qi,r1,r2); endif
      when qLOAD: ------- LOAD    subc reg ofst opr nrep ---- Format 4c
           if qi<>a then qi.reg:=SubstReg(qi.reg,whr1,r2) endif;
           if qi<>b then SubstOpr(qi,r1,r2) endif;
      when qSTORE: ------ STORE   reg opr ------------------- Format 3
           if qi<>b then qi.reg:=SubstReg(qi.reg,whr1,r2)
                         SubstOpr(qi,r1,r2); endif
      when qMOV: -------- MOV     reg reg2 ------------------ Format 2
           if qi<>a then qi.reg:=SubstReg(qi.reg,whr1,r2) endif;
           if qi<>b then qi qua Qfrm2.aux.val:=
                           SubstReg(qi qua Qfrm2.aux.val,whr1,r2) endif;
           if qi.reg=qi qua Qfrm2.aux.val
           then
%+E             if qi.subc = 0
%+E             then
                     DeleteQinstr(qi); changeable:=false; -- deleted!
%+E             endif;
           endif;
      when qXCHG: ------- XCHG    reg reg2 ------------------ Format 2
           qi.reg:=SubstReg(qi.reg,whr1,r2);
           qi qua Qfrm2.aux.val:=SubstReg(qi qua Qfrm2.aux.val,whr1,r2);
      when qDYADR: ------ DYADR   subc reg reg2 ------------- Format 2
           if qi<>b then qi qua Qfrm2.aux.val:=
                           SubstReg(qi qua Qfrm2.aux.val,whr1,r2) endif;
           qi.reg:=SubstReg(qi.reg,whr1,r2);
      when qMONADR, ----- MONADR  subc reg ------------------ Format 2
           qSHIFT, ------ SHIFT   subc reg CL --------------- Format 2
           qDYADC, ------ DYADC   subc reg const ------------ Format 2
                   ------ DYADC   subc reg fld addr --------- Format 2b
           qCONDEC: ----- CONDEC  subc reg ------------------ Format 2
           qi.reg:=SubstReg(qi.reg,whr1,r2);
      when qTRIADR: ----- TRIADR  subc reg ------------------ Format 2
           if qi<>b then qi.reg:=SubstReg(qi.reg,whr1,r2); endif
      when qXCHGM, ------ XCHGM   reg opr ------------------- Format 3
           qDYADM, ------ DYADM   subc reg opr -------------- Format 3
           qDYADMR: ----- DYADMR  subc reg opr -------------- Format 3
           qi.reg:=SubstReg(qi.reg,whr1,r2);
           if qi<>b then SubstOpr(qi,r1,r2) endif;
      when qPUSHM, ------ PUSHM   const opr ----------------- Format 4
           qDYADMC, ----- DYADMC  subc width const opr ------ Format 4
                    ----- DYADMC  subc width fld opr addr --- Format 4b
           qTRIADM, ----- TRIADM  subc width opr ------------ Format 3
           qJMPM, ------- JMPM    opr ----------------------- Format 3
%-E        qJMPFM, ------ JMPFM   opr ----------------------- Format 3
           qFLD, -------- FLD     fmf opr ------------------- Format 3
           qFST, -------- FST     fmf opr ------------------- Format 3
           qFSTP, ------- FSTP    fmf opr ------------------- Format 3
           qFDYADM, ----- FDYADM  subc fmf opr -------------- Format 3
           qMOVMC, ------ MOVMC   width const opr ----------- Format 4
                   ------ MOVMC   width fld opr addr -------- Format 4b
           qMONADM: ----- MONADM  subc width opr ------------ Format 3
           if qi<>b then SubstOpr(qi,r1,r2); endif
      endcase;
      if changeable then ModifyQinstr(qi) endif;
      while qi <> a do qi:=next endrepeat;
%-E CF1:CF2:
E0:E1:CF3:CF4:CF5:CF6: Changeable:=res;
end;
%title ***   M E M O R Y    H A N D L I G   ***

-- NOTE: The only Qinstr which access memory are of format 3,4 and 4b,
--       and Qfrm3 is common prefix for all of them.
--       I.e. opr := qi qua Qfrm3.opr  for all formats !!!

Routine SameMemPart;
import ref(Qfrm3) qi1,qi2; export Boolean res;
-- Check if 'qi1.opr' and 'qi2.opr' may access the same portion of memory.
-- res=false: Guaranteed no such access
-- res=true : Yes or Maybe or Dont Know.
-- NOTE: During compare between 'qi1.opr' and 'qi2.opr' we known that all
--       registers used by both operands have the same content.
begin infix(WORD) segid1,segid2; infix(MemAddr) op1,op2;
      infix(Fixup) FX1,FX2; short integer disp;
      res:=false;
      case 0:cMAX (qi1.type)
      when cVAL: case 0:cMAX (qi2.type)
                 when cOBJ,cSTP,cADR:    goto EE1; endcase;
      when cOBJ: case 0:cMAX (qi2.type)
                 when cVAL,cSTP:         goto EE2; endcase;
      when cSTP: case 0:cMAX (qi2.type)
                 when cVAL,cOBJ:         goto EE3; endcase;
      when cADR: case 0:cMAX (qi2.type)
                 when cVAL:              goto EE4; endcase;
      endcase;
      res:=true; op1:=qi1.opr; op2:=qi2.opr;
      case 0:adrMax (op1.kind)
      when segadr: segid1:=op1.segmid;
%+C        if segid1.val=0 then IERR("MASSAGE:SameMemPart-2") endif;
           case 0:adrMax (op2.kind)
           when reladr: -- Param etc. OK, else DONT KNOW
%-E             res:=bAND(op2.sbireg,biBIREG) <> biBP;
%+E             res:=bAND(op2.sibreg,BaseREG) <> bEBP;
           when locadr: res:=false; -- Guaranteed no such access
           when extadr: res:=false; -- Guaranteed no such access
           when segadr: segid2:=op2.segmid;
%+C             if segid2.val=0 then IERR("MASSAGE:SameMemPart-3") endif
                if segid1 <> segid2 then res:=false; goto E1 endif;
     S1:S2:S3:  --- In Same Logical Segment, Check for Registers ---
%-E             if bAND(bOR(op1.sbireg,op2.sbireg),rmBIREG) <> 0
%-E             then goto E2 endif -- res:=true; goto E2 endif;
%+E             if op1.sibreg <> NoIBREG then res:=true; goto E3 endif;
%+E             if op2.sibreg <> NoIBREG then res:=true; goto E4 endif;
                --- In Same Logical Segment, Without Registers ---
                disp:=op2.rela.val-op1.rela.val;
                res:=(disp < AllignFac) and (disp > -AllignFac);
           when fixadr: Fx2:=FIXTAB(op2.fix.HI).elt(op2.fix.LO);
                segid2:=Fx2.segid;
%+C             if segid2.val=0 then IERR("MASSAGE:SameMemPart-4") endif
                if segid1 <> segid2 then res:=false; goto E5 endif;
                if Fx2.Matched then op2.rela:=Fx2.rela; goto S1 endif
                -- res:=true; -- Dont Know
           endcase;
      when reladr:
%-E        if bAND(op1.sbireg,biBIREG)=biBP
%+E        if bAND(op1.sibreg,BaseREG)=bEBP
           then case 0:adrMax (op2.kind)
                when segadr: res:=false; -- Guaranteed no such access
                when reladr: -- Param etc. rela dependent, else OK
%-E                  if bAND(op2.sbireg,biBIREG)=biBP
%-E                  then disp:=op2.rela.val-op1.rela.val;
%-E                       if    disp>= AllignFac then res:=false
%-E                       elsif disp<=-AllignFac then res:=false endif
%-E                  --   res:=(disp<AllignFac) and (disp> -AllignFac);
%-E                  elsif GetSreg(op2)=qSS then -- res:=true -- Dont Know
%-E                  else res:=false endif;
%+E                  if bAND(op2.sibreg,BaseREG)=bEBP
%+E                  then disp:=op2.rela.val-op1.rela.val;
%+E                       res:=(disp<AllignFac) and (disp> -AllignFac);
%+E                  else res:=true;
-- %+E                       res:=false; -- AD'HOC TEST ?????
%+E                  endif;
                when locadr: res:=false; -- Guaranteed no such access
                when extadr: res:=false; -- Guaranteed no such access
                when fixadr: res:=false; -- Guaranteed no such access
                endcase;
%-E        elsif GetSreg(op2)=qSS
%-E        then
%-E             -- res:=true;  -- Dont Know                  -- HER: NY  NY  NY
%-E             if op2.kind=extadr then res:=false endif; -- AD'HOC TEST ?????
%-E        else case 0:adrMax (op2.kind)
%-E             when segadr: -- res:=true;  -- Dont Know
%-E             when reladr: -- Param etc. OK, else DONT KNOW
%-E                  if bAND(op2.sbireg,biBIREG)=biBP then res:=false
%-E                  elsif OprRegs(op1)=OprRegs(op2)
%-E                  then disp:=op2.rela.val-op1.rela.val;
%-E                       if    disp>= AllignFac then res:=false
%-E                       elsif disp<=-AllignFac then res:=false endif
%-E                  --   res:=(disp<AllignFac) and (disp> -AllignFac);
%-E                  -- else res:=true;
%-E                  endif;
%-E             when locadr: res:=false; -- Guaranteed no such access
%-E             when extadr: -- res:=true;  -- Dont Know
%-E                          res:=false; -- AD'HOC TEST ?????
%-E             when fixadr: -- res:=true;  -- Dont Know
%-E             endcase;
%+E        else case 0:adrMax (op2.kind)
-- %+E             when reladr: -- Param etc. OK, else DONT KNOW -- AD'HOC ?????
-- %+E                  res:=bAND(op2.sibreg,BaseREG) = bEBP;    -- AD'HOC ?????
-- %+E             when locadr: res:=false; -- Local variable    -- AD'HOC ?????
%+E             when extadr: res:=true;  -- Dont Know
%+E                          res:=false; -- AD'HOC TEST ?????
%+E             otherwise res:=true;  -- Dont Know
%+E             endcase;
           endif;
      when locadr:
           case 0:adrMax (op2.kind)
           when segadr: res:=false; -- Guaranteed no such access
           when reladr:
%-E             if GetSreg(op2)=qSS then -- res:=true -- Dont Know
%-E             else res:=false endif; -- Guaranteed no such access
%+E             res:=bAND(op2.sibreg,BaseREG) <> bEBP;
           when locadr:
                disp:=(op2.rela.val-op2.loca)-(op1.rela.val-op1.loca);
                if    disp>= AllignFac then res:=false
                elsif disp<=-AllignFac then res:=false endif
           --   res:=(disp<AllignFac) and (disp> -AllignFac);
           when extadr: res:=false; -- Guaranteed no such access
           when fixadr: res:=false; -- Guaranteed no such access
           endcase;
      when extadr:
           case 0:adrMax (op2.kind)
           when segadr: res:=false; -- Guaranteed no such access
           when reladr: -- Param etc. OK, else DONT KNOW
-- ??? %-E      res:=bAND(op2.sbireg,biBIREG) <> biBP;
-- ??? %+E      res:=bAND(op2.sibreg,BaseREG) <> bEBP;
                res:=false; -- Guaranteed no such access --- AD'HOC TEST ?????
           when locadr: res:=false; -- Guaranteed no such access
           when extadr:
                if op1.smbx <> op2.smbx then res:=false
                else --- In Same Object, Check for Registers ---
%-E                  if bAND(bOR(op1.sbireg,op2.sbireg),rmBIREG) <> 0
%+E                  if (op1.sibreg <> NoIBREG) or (op2.sibreg<>NoIBREG)
                     then -- res:=true;  -- Dont Know
                     else --- In Same Object, Without Registers ---
                          disp:=op2.rela.val-op1.rela.val;
                          if    disp>= AllignFac then res:=false
                          elsif disp<=-AllignFac then res:=false endif
                     --   res:=(disp<AllignFac) and (disp> -AllignFac);
                     endif;
                endif;
           when fixadr: res:=false; -- Guaranteed no such access
           endcase;
      when fixadr: Fx1:=FIXTAB(op1.fix.HI).elt(op1.fix.LO);
           segid1:=Fx1.segid;
%+C        if segid1.val=0 then IERR("MASSAGE:SameMemPart-5") endif
           case 0:adrMax (op2.kind)
           when reladr: -- Param etc. OK, else DONT KNOW
%-E             res:=bAND(op2.sbireg,biBIREG) <> biBP;
%+E             res:=bAND(op2.sibreg,BaseREG) <> bEBP;
           when locadr: res:=false; -- Guaranteed no such access
           when extadr: res:=false; -- Guaranteed no such access
           when segadr:
                segid2:=op2.segmid;
%+C             if segid2.val=0 then IERR("MASSAGE:SameMemPart-6") endif
                if segid1 <> segid2 then res:=false; goto E6 endif;
                if Fx1.Matched then op2.rela:=Fx2.rela; goto S2 endif
                -- res:=true; -- Dont Know
           when fixadr: Fx2:=FIXTAB(op2.fix.HI).elt(op2.fix.LO);
                segid2:=Fx2.segid;
%+C             if segid2.val=0 then IERR("MASSAGE:SameMemPart-7") endif
                if segid1 <> segid2 then res:=false; goto E7 endif;
                if Fx1.Matched
                then op1.rela:=Fx1.rela;
                     if Fx2.Matched
                     then op2.rela:=Fx2.rela; goto S3 endif
                endif;
                -- res:=true; -- Dont Know
           endcase;
      endcase;
%-E E2:
%+E E3:E4:
E1:E5:E6:E7:
EE1:EE2:EE3:EE4:
%+D if listq1 > 1 then ListSameMemPart(qi1,qi2,res) endif;
end;

%page
Routine SameMemUsed; import ref(Qpkt) n,a; export Boolean res;
begin range(0:MaxWord) rMask; rMask:=OprRegs(a qua Qfrm3.opr);
      res:=true;
      repeat while n <> a
      do if wAND(n.write,rMask) <> 0 then goto E1 endif;
         if wAND(wOR(n.read,n.write),uM) = 0 then -- OK
         else case 0:K_Qfrm6 (n.kind)
              when K_Qfrm3,K_Qfrm4,K_Qfrm4b,K_Qfrm4c:
                   if SameMemPart(n,a) then goto E3 endif;
              otherwise goto E2 endcase
---      else if    n.kind=K_Qfrm3  then -- OK
---           elsif n.kind=K_Qfrm4  then -- OK
---           elsif n.kind=K_Qfrm4b then -- OK
---           elsif n.kind=K_Qfrm4c then -- OK
---           else goto E2 endif;
---           if SameMemPart(n,a) then goto E3 endif;
         endif;
         n:=n.next;
      endrepeat;
      res:=false;
E1:E2:E3:end;

Routine SameMemWritten; import ref(Qpkt) n,a; export Boolean res;
begin range(0:MaxWord) rMask; rMask:=OprRegs(a qua Qfrm3.opr);
      res:=true;
      repeat while n <> a
      do if wAND(n.write,rMask) <> 0 then goto E1 endif;
         if wAND(n.write,uM) = 0 then -- OK
         else case 0:K_Qfrm6 (n.kind)
              when K_Qfrm2: if (n.fnc=qRSTRW) or (n.fnc=qRSTRW)
                            then if a qua Qfrm3.opr.kind <> extadr
                                 then goto E2 endif;
                            endif;
              when K_Qfrm3,K_Qfrm4,K_Qfrm4b,K_Qfrm4c:
                   if SameMemPart(n,a) then goto E3 endif;
              otherwise goto E4 endcase;
         endif;
         n:=n.next;
      endrepeat;
      res:=false;
E1:E2:E3:E4:end;

Routine SameMemLastUsed; import ref(Qpkt) a; export ref(Qpkt) b;
begin range(0:MaxWord) rMask; rMask:=OprRegs(a qua Qfrm3.opr); b:=a;
      repeat b:=b.pred while b <> none
      do case 0:qMXX (b.fnc)
%-E      when qJMP,qJMPM,qJMPFM:  -- OK
%+E      when qJMP,qJMPM:         -- OK
         when qFDEST,qBDEST,qLABEL,qENTER,qCALL,
              qRET,qIRET,qLEAVE: b:=none; goto E2;
         otherwise if wAND(b.write,rMask) <> 0 then b:=none; goto E1 endif;
         endcase;
         if wAND(wOR(b.read,b.write),uM) = 0 then -- OK
         else case 0:8 (b.kind)
              when K_Qfrm2: if (b.fnc=qRSTRW) or (b.fnc=qRSTRW)
                            then if a qua Qfrm3.opr.kind <> extadr
                                 then goto E3 endif;
                            endif;
              when K_Qfrm3,K_Qfrm4,K_Qfrm4b,K_Qfrm4c:
                   if SameMemPart(b,a) then goto E4 endif;
              otherwise goto E5 endcase;
         endif;
      endrepeat; b:=none;
E1:E2:E3:E4:E5:end;
%title ***   S K A L    F J E R N E S   ***
%+D Routine ListSameMemPart;
%+D import ref(Qfrm3) qi1,qi2; Boolean res1;
%+D begin Boolean res2; infix(MemAddr) op1,op2;
%+D       op1:=qi1.opr; op2:=qi2.opr;
%+D %-E   res2:=OldSameMemPart(op1,op2);
%+DE      res2:=res1;
%+D       Ed(errmsg,"*** SameMemPart("); EdOpr(errmsg,op1);
%+D       EdChar(errmsg,','); EdOpr(errmsg,op2);
%+D       if res1 then Ed(errmsg,") -- YES")
%+D       else Ed(errmsg,") -- NO") endif;
%+D       if res2 <> res1
%+D       then if res2 then Ed(errmsg,"/OLD(YES)")
%+D            else Ed(errmsg,"/OLD(NO)") endif;
%+D       endif;
%+D       printout(errmsg);
%+D end;

%+D %-E Routine OldSameMemPart;
%+D %-E import infix(MemAddr) op1,op2; export Boolean res;
%+D %-E begin range(0:MaxWord) rela,rela2,segid,segid2;
%+D %-E   res:=true;
%+D %-E   segid:=AdrSegid(op1); segid2:=AdrSegid(op2);
%+D %-E   if segid2=0   then -- Nothing -- in dynamic mem.
%+D %-E   elsif segid=0 then -- Nothing -- in dynamic mem.
%+D %-E   elsif segid2 <> segid then res:=false
%+D %-E   elsif bAND(op1.sbireg,rmBIREG)=bAND(op2.sbireg,rmBIREG)
%+D %-E   then if op1.kind<>op2.kind then goto E2 endif;
%+D %-E        case 0:adrMax (op1.kind)
%+D %-E        when segadr,reladr: ;
%+D %-E        when locadr: if op1.loca<>op2.loca then goto E3 endif
%+D %-E        when extadr: if op1.smbx<>op2.smbx then goto E4 endif
%+D %-E        when fixadr: if op1.fix<>op2.fix then goto E5 endif
%+D %-E        otherwise goto E6 endcase;
%+D %-E        rela:=op1.rela.val; rela2:=op2.rela.val;
%+D %-E        if rela= rela2    then goto E7 endif;
%+D %-E        if rela=(rela2-1) then goto E8 endif;
%+D %-E        if rela=(rela2+1) then goto E9 endif
%+D %-E   else goto E10 endif
%+D %-E   res:=false
%+D %-E E2:E3:E4:E5:E6:E7:E8:E9:E10:end;
%title

Routine CheckScope; import ref(Qpkt) a; range(0:MaxWord) uR;
begin ref(Qpkt) b;
      if CheckRegFree(a.next,uR)
      then L1: b:=a; if wAND(wOR(a.read,a.write),uR) <> 0
           then if QinstrIsDeleted(b) then goto E1 endif
           else b:=RegLastUsed(b,uR); if b=none then goto E2 endif endif;
           if wAND(b.write,uM) <> 0  then goto E3 endif;
           if wAND(b.write,uR) = 0 then goto E4 endif;
           if CheckRegFree(b.next,b.write)
           then
%+D             if listq1>1 then mPRINT2("NoScope",b,a) endif;
                uR:=wAND(uR,wNOT(b.write)); RepDelete(b);
                if uR <> 0 then goto L1 endif;
           endif;
      endif;
E1:E2:E3:E4:end

Routine RepDelete; import ref(Qpkt) qi;
begin ref(Qpkt) a; range(0:MaxWord) rMask,m;
      a:=qi.pred; rMask:=qi.read; DeleteQinstr(qi);
      if a=none then goto E1 endif;
%-E   if wAND(rMask,uAX+uBX+uCX+uDX) <> 0
%-E   then m:=wAND(rMask,uAX); if m<>0 then CheckScope(a,m) endif;
%-E        m:=wAND(rMask,uBX); if m<>0 then CheckScope(a,m) endif;
%-E        m:=wAND(rMask,uCX); if m<>0 then CheckScope(a,m) endif;
%-E        m:=wAND(rMask,uDX); if m<>0 then CheckScope(a,m) endif;
%-E   endif;
%-E   if wAND(rMask,uSI+uDI+uDS+uES) <> 0
%-E   then if wAND(rMask,uSI)=uSI then CheckScope(a,uSI) endif;
%-E        if wAND(rMask,uDI)=uDI then CheckScope(a,uDI) endif;
%-E        if wAND(rMask,uDS)=uDS then CheckScope(a,uDS) endif;
%-E        if wAND(rMask,uES)=uES then CheckScope(a,uES) endif;
%-E   endif;
%+E   if wAND(rMask,uEAX+uEBX+uECX) <> 0
%+E   then m:=wAND(rMask,uEAX); if m<>0 then CheckScope(a,m) endif;
%+E        m:=wAND(rMask,uEBX); if m<>0 then CheckScope(a,m) endif;
%+E        m:=wAND(rMask,uECX); if m<>0 then CheckScope(a,m) endif;
%+E   endif;
%+E   if wAND(rMask,uEDX+uESI+uEDI) <> 0
%+E   then m:=wAND(rMask,uEDX); if m<>0 then CheckScope(a,m) endif;
%+E        if wAND(rMask,uESI)=uESI then CheckScope(a,uESI) endif;
%+E        if wAND(rMask,uEDI)=uEDI then CheckScope(a,uEDI) endif;
%+E   endif;
E1:end
%title
--    OPR:
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b2:LOADSC sr2 r2 const   LOADSC sr2 r2 const  o sr1<>defsr(rb,ri)
--    .                     .                    o sr2=defsr(rb,ri)
-- b1:LOADSC sr1 r1 const  (LOADSC sr1 r1 const) o sr1 unmodified <b1,a>
--    .                -->  .                    o sr2 unmodified <b2,a>
--    .                     .                    o b2.const.s=b1.const.s
-- a: .. (sr1,rb,ri,d) ..   .. (sr2,rb,ri,d) ..  o (Maybe delete b1)
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: LES r opr             LDS r opr            o DS=defsr(rb,ri)
--    .                -->  .                    o ES oneshot (b,a)
-- a: .. (ES,rb,ri,d) ..    .. (DS,rb,ri) ..     o DS unused <b,a>
--                                               o DS dies in a.pred
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: MOV sr1,sr2            MOV sr1,sr2         o sr1,sr2 are segregs
--    .                -->  .                    o sr1 unwritten <b,a>
-- a: .. (sr1,rb,ri,d) ..    .. (sr2,rb,ri) ..   o sr2 unwritten <b,a>
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: MOV ri1,ri2           MOV ri1,ri2          o ri1 unwritten <b,a>
--    .                -->  .                    o ri2 unwritten <b,a>
-- a: .. (rS,rb,ri1,d) ..  .. (rS,rb,ri2) ..     o
------------------------------------------------------------------------
-------------------- 32 BIT MODE ONLY ----------------------------------
-- b: MOV rb1,rb2           MOV rb1,rb2  (*)     o (*) May be deleted
--    .                -->  .                    o rb1 unwritten <b,a>
-- a: .. (rb1+s*ri) ..      .. (rb2,s*ri) ..     o rb2 unwritten <b,a>
------------------------------------------------------------------------
-------------------- 32 BIT MODE ONLY ----------------------------------
-- b: MOV ri1,ri2           MOV ri1,ri2  (*)     o (*) May be deleted
--    .                -->  .                    o ri1 unwritten <b,a>
-- a: .. (rb+s*ri1) ..      .. (rb,s*ri2) ..     o ri2 unwritten <b,a>
------------------------------------------------------------------------
-------------------- 32 BIT MODE ONLY ----------------------------------
-- b: ADD ri,ri             |                    o ri unused <b,a>
--    .                -->  .                    o ri dies in a
-- a: .. (rb+ri*s) ..       .. (rb,ri*2s) ..     o s=1,2,4
------------------------------------------------------------------------
-------------------- 32 BIT MODE ONLY ----------------------------------
-- b: ADD ri,ri             |                    o ri unused <b,c>
--    .                -->  .                    o ri unused <c,a>
-- c: .. (r1+ri*s) ..       .. (r1,ri*2s) ..     o s=1,2,4
--    .                -->  .                    o ri dies in a
-- a: .. (r2+ri*s) ..       .. (r2,ri*2s) ..     o ++ ????????
------------------------------------------------------------------------
    Routine mOPR; import ref(Qfrm3) a; -- a has opr part.
    begin ref(Qpkt) b,bb; range(0:nregs) rb1,rb2,ri1,ri2;
%+E       ref(Qfrm3) c; range(0:MaxByte) subc,scale,scl; integer idx;
%-E       ref(Qpkt) b1,b2; range(0:nregs) sr1,sr2;
%-E       range(0:MaxWord) bsegid;
%-E %+D   RST(R_mOPR);
%+E       rb1:=GetBreg(a.opr); if rb1=0 then goto II1 endif;
%+E LB1:LB2:b:=RegLastWrite(a,uMask(rb1)); if b=none then goto II2 endif;
%+E       if b.fnc=qLOADC
%+E       then
--  %+ED       WARNING("mOPR: Constant Base-Register");
%+E       elsif b.fnc=qMOV
%+E       then rb2:=b qua Qfrm2.aux.val;
%+E            if rb2=qESP then goto II3 endif;
%+E            if b.subc <> 0 then goto II4 endif;
%+E            if MakeRegUnWritten(b,a,rb2)
%+E            then
%+E %+D             if listq1>1 then mPRINT2("OPR(1)",b,a) endif;
%+E                 a.opr.sibreg:=SetBreg(a.opr.sibreg,rb2);
%+E                 ModifyQinstr(a);
%+E                 if CheckRegFree(b.next,uMask(rb1))
%+E                 then DeleteQinstr(b) endif;
%+E                 rb1:=rb2; goto LB1;
%+E            elsif wAND(wAND(a.read,a.write),uMask(rb2))=0
%+E            then
%+E %+D             if listq1>1 then mPRINT2("OPR(2)",b,a) endif;
%+E                 a.opr.sibreg:=SetBreg(a.opr.sibreg,rb2);
%+E                 ModifyQinstr(a);
%+E                 if CheckRegFree(b.next,uMask(rb1))
%+E                 then bb:=RegNextWrite(b.next,a,uMask(rb2));
%+E                      if bb <> none
%+E                      then if ChangeReg(rb2,rb1,bb,a)
%+E                           then a.opr.sibreg:=SetBreg(a.opr.sibreg,rb2);
%+E                                ModifyQinstr(a);
%+E                                DeleteQinstr(b); rb1:=rb2; goto LB2;
%+E                           endif;
%+E                      endif;
%+E                 endif;
%+E %+D             if listq1>1 then mPRINT2("OPR(3)",b,a) endif;
%+E                 a.opr.sibreg:=SetBreg(a.opr.sibreg,rb1);
%+E                 ModifyQinstr(a);
%+E            endif;
%+E       endif;
%+E II1:II2:II3:II4:
%+E       ri1:=GetIreg(a.opr); if ri1=0 then goto EE1 endif;
%+E LL1:LL2:LL3:LL4:
%+E       b:=RegLastWrite(a,uMask(ri1)); if b=none then goto EE2 endif;
%+E       if b.fnc=qLOADC
%+E       then idx:=b qua Qfrm2.aux.val; scale:=bSHR(a.opr.sibreg,6);
%+E            repeat while scale <> 0
%+E            do scale:=scale-1; idx:=idx+idx endrepeat;
%+E %+D        if listq1>1 then mPRINT2("OPR(4)",b,a) endif;
%+E            a.opr.rela.val:=a.opr.rela.val+idx;
%+E            a.opr.sibreg:=bOR(bAND(a.opr.sibreg,BaseREG),NoIREG);
%+E            ModifyQinstr(a);
%+E            if CheckRegFree(b.next,uMask(ri1)) then DeleteQinstr(b) endif;
%+E       elsif b.fnc=qDYADR
%+E       then subc:=b.subc;
%+E            if (subc=qADD) or (subc=qADDM) or (subc=qADDF)
%+E            then if b qua Qfrm2.aux.val <> ri1 then goto EE3 endif;
%+E                 scale:=bSHR(a.opr.sibreg,6);
%+E                 if scale > 3 then goto EE4 endif;
%+E                 if not RegDies(a,uMask(ri1)) then goto EE5 endif;
%+E                 if MaaaRegUnused(b.next,a,ri1)
%+E                 then
%+E %+D                  if listq1>1 then mPRINT2("OPR(5)",b,a) endif;
%+E                      a.opr.sibreg:=bOR(bSHL(scale+1,6),
%+E                                bAND(a.opr.sibreg,BaseREG+IndxREG) )
%+E                      ModifyQinstr(a); DeleteQinstr(b); goto LL1;
%+E                 else --- NOT SAFE !!!!!!!!!!!
%+E                      c:=RegLastUsed(a,uMask(ri1));
%+E                      --- Check that c has Operand ---
%+E                      if c.kind < K_Qfrm3   then goto EE6 endif;
%+E                      if c.kind > K_Qfrm4c  then goto EE7 endif;
%+E                      if c.fnc =  qFLDC     then goto EE8 endif;
%+E
%+E                      if GetIreg(c.opr) <> ri1 then goto EE9 endif;
%+E                      if  MaaaRegUnused(b.next,c,ri1)
%+E                      and MaaaRegUnused(c.next,a,ri1) then -- OK
%+E                      else goto EE10 endif;
%+E                      scl:=bSHR(c.opr.sibreg,6);
%+E                      if scl > 3 then goto EE11 endif;
%+E %+D                  if listq1>1 then mPRINT2("OPR(6)",b,a) endif;
%+E                      a.opr.sibreg:=bOR(bSHL(scale+1,6),
%+E                                bAND(a.opr.sibreg,BaseREG+IndxREG) )
%+E                      c.opr.sibreg:=bOR(bSHL(scl+1,6),
%+E                                bAND(c.opr.sibreg,BaseREG+IndxREG) )
%+E                      ModifyQinstr(c); ModifyQinstr(a);
%+E                      DeleteQinstr(b); goto LL2;
%+E                 endif;
%+E            endif;
%+E       elsif b.fnc=qMOV
%+E       then ri2:=b qua Qfrm2.aux.val;
%+E            if b.subc <> 0 then goto EE12 endif;
%+E            if MakeRegUnWritten(b,a,ri2)
%+E            then
%+E %+D             if listq1>1 then mPRINT2("OPR(7)",b,a) endif;
%+E                 a.opr.sibreg:=SetIreg(a.opr.sibreg,ri2);
%+E                 ModifyQinstr(a);
%+E                 if CheckRegFree(b.next,uMask(ri1))
%+E                 then DeleteQinstr(b) endif;
%+E                 ri1:=ri2; goto LL3;
%+E            elsif wAND(wAND(a.read,a.write),uMask(ri2))=0
%+E            then
%+E %+D             if listq1>1 then mPRINT2("OPR(8)",b,a) endif;
%+E                 a.opr.sibreg:=SetIreg(a.opr.sibreg,ri2);
%+E                 ModifyQinstr(a);
%+E                 if CheckRegFree(b.next,uMask(ri1))
%+E                 then bb:=RegNextWrite(b.next,a,uMask(ri2));
%+E                      if bb <> none
%+E                      then if ChangeReg(ri2,ri1,bb,a)
%+E                           then
%+E %+D                            if listq1>1 then mPRINT2("OPR(9)",b,a) endif;
%+E                                a.opr.sibreg:=SetIreg(a.opr.sibreg,ri2);
%+E                                ModifyQinstr(a);
%+E                                DeleteQinstr(b); ri1:=ri2; goto LL4;
%+E                           endif;
%+E                      endif;
%+E                 endif;
%+E %+D             if listq1>1 then mPRINT2("OPR(10)",b,a) endif;
%+E                 a.opr.sibreg:=SetIreg(a.opr.sibreg,ri1);
%+E                 ModifyQinstr(a);
%+E            endif;
%+E       endif;

%-E       if a.fnc=qLOADA then goto C00 elsif a.fnc=qPUSHA then goto C01 endif;
%-E ----- **********************************************************
%-E       sr1:=GetSreg(a.opr);
%-E       b:=RegLastWrite(a,uMask(sr1)); if b=none then goto CCx endif;
%-E       if b.fnc=qMOV
%-E       then sr2:=b qua Qfrm2.aux.val; if sr2<qES then goto CCx2 endif;
%-E %+D        if listq1>1 then mPRINT2("HER:OPR-x1",b,a) endif;
%-E            if MaaaRegUnWritten(b.next,a,sr2)
%-E            then
%-E %+D             if listq1>1 then mPRINT2("OPR(x14)",b,a) endif;
%-E                 a.opr.sbireg:=SetSBIreg(a.opr.sbireg,sr2);
%-E                 ModifyQinstr(a);
%-E                 if RegDies(b,uMask(sr1)) then DeleteQinstr(b) endif;
%-E            endif;
%-E            sr1:=GetSreg(a.opr); -- moved from below
%-E       endif;
%-E     CCx2: --- CCx moved to end, b=none above implies b1=none below!!!
%-E ----- **********************************************************
---       sr1:=GetSreg(a.opr); -- moved
%-E       b1:=RegLastWrite(a,uMask(sr1)); if b1=none then goto E3 endif;
%-E       sr2:=GetDefaultSreg(a.opr);
%-E       if sr1=sr2 then goto C1 endif;
%-E       if b1.fnc<>qLOADSC then goto BB2 endif;
%-E       b2:=RegLastWrite(a,uMask(sr2)); if b2=none then goto B3 endif;
%-E       if b2.fnc<>qLOADSC then goto B4 endif;
%-E       bsegid:=AdrSegid(b1 qua Qfrm2b.addr);
%-E       if bsegid=0 then goto B5 endif;
%-E       if bsegid <> AdrSegid(b2 qua Qfrm2b.addr) then goto B6 endif;
%-E %+D   if listq1>1 then mPRINT2("OPR(11)",b2,a) endif;
%-E       a.opr.sbireg:=SetSBIreg(a.opr.sbireg,sr2); ModifyQinstr(a);
%-E       if RegDies(b1,uMask(sr1)) then if RegDies(b1,uMask(b1.reg))
%-E       then DeleteQinstr(b1) endif endif;
%-E       goto E2;
%-E BB2:B3:B4:B5:B6:
%-E ----- **********************************************************
%-E       if sr1<>qES then goto C20 elsif sr2<>qDS then goto C21 endif;
%-E       b:=RegLastWrite(a,uES); if b=none then goto C3 endif;    -- ????
%-E       if b.fnc=qLES
%-E       then if wAND(a.write,uES)<>0 then -- OK
%-E            elsif not RegDies(a,uES) then goto C4 endif;
%-E            if not RegDies(a.pred,uDS) then goto C5 endif;
%-E            if not MaaaRegUnused(b.next,a,qDS) then goto C6 endif;
%-E %+D        if listq1>1 then mPRINT2("OPR(12)",b,a) endif;
%-E            if not ChangeReg(qES,qDS,b,a) then goto C7 endif;
%-E %+D        if listq1>1 then mPRINT2("OPR(12)-2",b,a) endif;
%-E            ReMasseur(b);
%-E       elsif b.fnc=qMOV                                         -- ????
%-E       then if b qua Qfrm2.aux.val <> qDS then goto C8 endif;   -- ????
%-E %+D        if listq1>1 then mPRINT2("HER:OPR-1",b,a) endif;    -- ????
%-E            if MaaaRegUnWritten(b.next,a,qDS)                   -- ????
%-E            then                                                -- ????
%-E %+D             if listq1>1 then mPRINT2("OPR(14)",b,a) endif; -- ????
%-E                 a.opr.sbireg:=SetSBIreg(a.opr.sbireg,qDS);     -- ????
%-E                 ModifyQinstr(a);                               -- ????
%-E                 if RegDies(b,uES) then DeleteQinstr(b) endif;  -- ????
%-E            endif;                                              -- ????
%-E       endif;                                                   -- ????
%-E C00:C01:C1:C20:C21:C3:C4:C5:C6:C7:C8:
%-E LL1:
%-E ---   ***********************************************
%-E       rb1:=GetBreg(a.opr); if rb1=0  then goto D1 endif;
%-E       ri1:=GetIreg(a.opr); if ri1<>0 then goto D2 endif;
%-E       b:=RegLastWrite(a,uMask(rb1)); if b=none then goto D3 endif;
%-E       if b.fnc=qMOV
%-E       then ri2:=b qua Qfrm2.aux.val;
%-E            if ri2=qSI then elsif ri2=qDI then -- OK
%-E            else goto D4 endif;
%-E            if MaaaRegUnWritten(b.next,a,ri2)
%-E            then
%-E %+D             if listq1>1 then mPRINT2("OPR(15)",b,a) endif;
%-E                 a.opr.sbireg:=RemSBIreg(a.opr.sbireg,rb1);
%-E                 a.opr.sbireg:=SetSBIreg(a.opr.sbireg,ri2);
%-E                 ModifyQinstr(a);
%-E                 if RegDies(b,uMask(rb1)) then DeleteQinstr(b) endif;
%-E            endif;
%-E       endif;
%-E D1:D2:D3:D4:
%-E ---   ***********************************************
%-E       ri1:=GetIreg(a.opr); if ri1=0 then goto E4 endif;
%-E       b:=RegLastWrite(a,uMask(ri1)); if b=none then goto E5 endif;
%-E       if b.fnc=qMOV
%-E       then if ri1=qSI then ri2:=qDI else ri2:=qSI endif;
%-E            if b qua Qfrm2.aux.val <> ri2 then goto E6 endif;
%-E            if MaaaRegUnWritten(b.next,a,ri2)
%-E            then
%-E %+D             if listq1>1 then mPRINT2("OPR(16)",b,a) endif;
%-E                 a.opr.sbireg:=SetSBIreg(a.opr.sbireg,ri2);
%-E                 ModifyQinstr(a);
%-E                 if RegDies(b,uMask(ri1)) then DeleteQinstr(b) endif;
%-E            endif;
%-E       elsif b.fnc=qLOADC
%-E       then if b.kind <> K_Qfrm2 then goto E7 endif;
%-E %+D        if listq1>1 then mPRINT2("OPR(17)",b,a) endif;
%-E            a.opr.rela.val:=a.opr.rela.val+b qua Qfrm2.aux.val;
%-E            a.opr.sbireg:=RemSBIreg(a.opr.sbireg,ri1); ModifyQinstr(a);
%-E            if CheckRegFree(b.next,uMask(ri1)) then DeleteQinstr(b) endif;
%-E            goto LL1;
%-E       endif;
%-E    CCx: -- moved pj
%-E E2:E3:E4:E5:E6:E7:
%+E EE1:EE2:EE3:EE4:EE5:
%+E EE6:EE7:EE8:EE9:EE10:EE11:EE12:
    end; -- mOPR
%page
--    PUSHR:
------------------------------------------------------------------------
-- b: POPR r               |               o r oneshot (b,a)
--    .                    .               o stack(b)=stack(a)
--    .                    .               o
-- a: PUSHR r              |               o
------------------------------------------------------------------------
-- b: MOV subc r r2        |               o r oneshot (b,a)
--    .                    .               o r2 unmodified <b,n>
--    .            -->  n: PUSHR r2        o stack(n)=stack(a)
--    .                    .               o samepart (r,r2)
-- a: PUSHR r              |               o b.subc=0
------------------------------------------------------------------------
-- b: LOAD subc r opr nrep |               o r oneshot (b,a)
--    .                    .               o R(opr) unmodified <b,n>
--    .            -->  n: PUSHM s(r) opr  o stack(n)=stack(a)
--    .                    .               o b.subc=0
-- a: PUSHR r              |               o b.nrep=0
------------------------------------------------------------------------
-------------------- 32 BIT MODE ONLY ------ NY SKAL SKRIVES SENERE ------------
--------------------------------------------------------------------------------
-- b: LOAD subc r opr nrep ofst
--                 -->     LOAD subc r opr nrep-1 ofst o r oneshot (b,a)
--    .                    .                           o R(opr) unmodified <b,n>
--    .            -->  n: PUSHM s(r) [r]+ofst         o stack(n)=stack(a)
--    .                    .                           o b.subc=0
-- a: PUSHR r              |                           o b.nrep<>0
--------------------------------------------------------------------------------
Routine mPUSHR; import ref(Qpkt) a;
begin ref(Qpkt) b,n; range(0:nregs) r,r2; range(0:qMXX) bf;
%+D   RST(R_mPUSHR);
      r:=a.subc; b:=RegOneshot(a,uMask(r));
      if b=none then goto E1 endif;
      bf:=b.fnc;
      if bf=qMOV
      then r2:=b qua Qfrm2.aux.val;
           if not SamePart(r,r2) then goto E2 endif
      elsif bf=qPOPR
      then if StackEqual2(b,a)
           then DeleteQinstr(a); DeleteQinstr(b) endif;
           goto Ex1;
      elsif bf<>qLOAD then goto E3
%+E   elsif b qua Qfrm4c.nrep <> 0 then goto E8
      endif
%+E   if b.subc<>0 then goto E7 endif
      if b.reg<>r
      then if (b.reg=WholeReg(r)) and (r=LowPart(%b.reg%))
           then if not RegDies(b,uMask(HighPartL(r)))
                then goto E6 endif
           else goto E4 endif
      endif;
      n:=RegsReadUnmodified(b,a);
      if not StackEqual(n,a) then goto E5 endif;
      if bf=qMOV then n:=InsertQf1(n,qPUSHR,r2,a.type)
      else n:=InsertQf4(n,qPUSHM,0,0,a.type,RegSize(r),b qua Qfrm3.opr)
      endif;
      DeleteQinstr(a); DeleteQinstr(b); ReMasseur(n);
%+E E7:E8:
Ex1:E1:E2:E3:E4:E5:E6:end; -- mPUSHR
%page
--    POPK:
------------------------------------------------------------------------
-- c: load r data          |               o stack(b)=stack(a)
--    .                    .               o stack ulest indirekte <b,a>
-- b: PUSHR r      -->     |               o r engangs (c,b)
--    .                    .               o WR(c)-r d|r i c
-- a: POPK size            |
------------------------------------------------------------------------
-- b: push data            |               o stack(b)=stack(a)
--    .            -->     .               o stack ulest indirekte <b,a>
-- a: POPK size            |
------------------------------------------------------------------------
%+D Routine mPOPK; import ref(Qpkt) a;
%+D begin ref(Qpkt) b;
%+D %+D   RST(R_mPOPK);
%+D       b:=FindPush(a);
%+D       if b <> none
%+D       then
%+D %+D        if listq1>1 then mPRINT2("POPK(1)",b,a) endif;
%+D            DeleteQinstr(a); RepDelete(b);
%+D       endif;
%+D end; -- POPK
%page
--    POPR:
------------------------------------------------------------------------
-- b: PUSHC r2 const       |               o stack(b)=stack(a)
--    .                    .               o stack ulest indirekte <b,a>
--    .            -->     .               o r2 d|r i b
--    .                    .               o r1 is not segreg
-- a: POPR r1           a: LOADC r1 const
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: PUSHC r2 const       |               o stack(b)=stack(a)
--    .                    .               o stack unread indirect <b,a>
--    .            -->  n: PUSH SS         o r2 dies in b
--    .                 n: POPR r1         o r1 is segreg
--    .                    .               o Segid(const)=DGROUP
-- a: POPR r1              |               o r2 unmodified <b,n>
--                                         o r1 unused <n,a>
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: PUSHC r2 const       |               o stack(b)=stack(a)
--    .                    .               o stack unread indirect <b,a>
--    .            -->  n: LOADSC r1 r2 const  o r2 dies in b
--    .                    .               o r1 is segreg
-- a: POPR r1              |               o r2 unmodified <b,n>
--                                         o r1 unused <n,a>
------------------------------------------------------------------------
-- b: PUSHR r2             |               o stack(b)=stack(a)
--    .                    .               o stack ulest indirekte <b,a>
--    .            -->  n: MOV r1,r2       o r2 uendret <b,n>
--    .                    .               o r1 ubrukt <n,a>
-- a: POPR r1              |               o s=('S',' ')
------------------------------------------------------------------------
-- b: PUSHA r2 opr         |               o stack(b)=stack(a)
--    .                    .               o stack ulest inderekte <b,a>
--    .            -->  n: LOADA r1 opr    o r2 d|r i b
--    .                    .               o R(opr) uendret <b,n>
-- a: POPR r1              |               o r1 ubrukt <n,a>
------------------------------------------------------------------------
-- b: PUSHM size opr       |               o stack(b)=stack(a)
--    .                    .               o stack ulest indirekte <b,a>
--    .            -->  n: LOAD r1 opr     o M uendret <b,n>
--    .                    .               o R(opr) uendret <b,n>
-- a: POPR r1              |               o r1 ubrukt <n,a>
------------------------------------------------------------------------
%+D Visible
Routine mPOPR; import ref(Qpkt) a;
begin ref(Qpkt) b,n,b1; range(0:qMXX) fnc;
      infix(MemAddr) opr,adr; range(0:nregs) r1,r2;
%+D   RST(R_mPOPR);
      b:=FindPush2(a); if b=none then goto E1 endif; fnc:=b.fnc;
---   if (StackModification(a)+StackModification(b))<>0
      if stackMod2 <> stackMod1
      then if fnc=qFPUSH
           then
%+D             WARNING("MASS.mPOPR -- FPUSH");
                goto E8x;
           elsif fnc<>qPUSHM
           then
%+D             WARNING("MASS.mPOPR.1");
                goto E8;
           endif
      endif;
      r1:=a.subc; if fnc=qPUSHR then r2:=b.subc else r2:=b.reg endif;
      if (fnc=qPUSHC)
%-E   and (r1<qES) -- i.e. r1 is not segreg
      then
%-E        if not RegDies(b,uMask(r2)) then goto E2 endif;
%+D        if listq1>1 then mPRINT2("POPR(1)",b,a) endif;
           if b.kind=K_Qfrm2 then
              n:=InsertQf2(a,qLOADC,0,r1,a.type,b qua Qfrm2.aux.val)
           else -- b.kind=K_Qfrm2b
              n:=InsertQf2b(a,qLOADC,0,r1,a.type,b qua Qfrm2b.aux.val,
                            b qua Qfrm2b.addr)
           endif
      else
           n:=RegsReadUnmodified(b,a);
           if MakeRegUnused(n,a,r1)    then n:=RegsReadUnmodified(b,a);
           elsif MakeRegUnused(b,a,r1) then n:=b -- OK
           else
%-E              mPOPR2(a,n,b);
                 goto E3;
           endif;
%+D        if QinstrIsDeleted(n) then IERR("mPOPR.3") endif;
           if fnc=qPUSHR
           then if r1=r2 then n:=none
                else if RegSize(r1) <> RegSize(r2)
                     then
%+D                       WARNING("Masseur.mPOPR.2");
                          goto E9;
                     endif;
%+D                  if listq1>1 then mPRINT2("POPR(2)",b,a) endif;
                     n:=InsertQf2(n,qMOV,0,r1,a.type,r2)
                endif
%-E        elsif fnc=qPUSHC
%-E        then adr:=b qua Qfrm2b.addr;
%-E %+D         if listq1>1 then mPRINT2("POPR(3)",b,a) endif;
%-E             if AdrSegid(adr) = DGROUP.val
%-E             then n:=InsertQf1(n,qPOPR,r1,cOBJ);
%-E                  n:=InsertQf1(n,qPUSHR,qSS,cOBJ);
%-E             else n:=InsertQf2b(n,qLOADSC,r1,r2,a.type,0,adr) endif;
           elsif fnc=qPUSHA
           then if not RegDies(b,uMask(r2)) then goto E6 endif;
%+D             if listq1>1 then mPRINT2("POPR(4)",b,a) endif;
                n:= InsertQf3(n,qLOADA,0,r1,a.type,b qua Qfrm3.opr)
           elsif fnc=qPUSHM
           then -- if EvalSeen then goto E5 endif;
%-E             if mPOPR2(a,n,b) then goto E10 endif;
%+D             if listq1>1 then mPRINT2("POPR(5)",b,a) endif;
                opr:=b qua Qfrm3.opr;
                n:=InsertQf4c(n,qLOAD,0,r1,a.type,0,opr,0);
                if (StackModification(a)+StackModification(b))<>0
                then b qua Qfrm4.aux.val:=b qua Qfrm4.aux.val-AllignFac;
                     b qua Qfrm4.opr.rela.val:=
                                 b qua Qfrm4.opr.rela.val+AllignFac;
                     ModifyQinstr(b); goto D1
                endif
           else goto E4 endif
      endif;
      DeleteQinstr(b);
D1:   DeleteQinstr(a); if n<>none then ReMasseur(n) endif;
%-E E2:E10:
E1:E3:E4:   E6:E8:E8x:E9:
end; -- mPOPR
%page

--    POPR2:
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- c: PUSHM 2 opr            |              v stack(b)=stack(a)
--    .                      .              v R(opr) unmodified <c,b>
--    .                      .              v M(opr) unmodified <c,b>
-- b: LOAD rX opr-2  -->     |              o rS in (DS,ES)
--    .                   n: Lsr rX opr-2   o n=b+1
--    .                      .              o rS unused <n,a>
-- a: POPR rS                |
------------------------------------------------------------------------
%-E %+D Visible
%-E Routine mPOPR2; import ref(Qpkt) a,b,c; export Boolean success;
%-E begin ref(Qpkt) n; range(0:nregs) rS,rX; infix(MemAddr) opr;
%-E %+D   RST(R_mPOPR2);
%-E       success:=false;
%-E       rS:=a.subc; if rS<>qDS then if rS<>qES then goto E1 endif endif;
%-E       if b.fnc<>qLOAD then goto E2 endif;
%-E       rX:=b.reg; if WholeReg(rX)<>rX then goto E30
%-E                  elsif rX>=qES then goto E31 endif;
%-E       n:=b.next; if not MaaaRegUnused(n,a,rS) then goto E4 endif;
%-E       n:=b.next; --- Old n may be deleted during register substitution
%-E       opr:=c qua Qfrm4.opr; opr.rela.val:=opr.rela.val-2;
%-E       if OprNE(b qua Qfrm3.opr,opr) then goto E5 endif;
%-E       n:=InsertQf4c(n,if rS=qDS then qLDS else qLES,0,rX,cOBJ,0,opr,0);
%-E       DeleteQinstr(a); DeleteQinstr(b); DeleteQinstr(c); ReMasseur(n);
%-E       success:=true;
%-E E1:E2:E30:E31:E4:E5:end; -- mPOPR2
%page
--    POPM:
------------------------------------------------------------------------
-- b: PUSHR r              |             o stack(b)=stack(a)
--    .                    .             o
--    .            -->  n: STORE r opr   o size(r)<=c
--    .                    .             o r unmodified <b,n>
-- a: POPM rL c opr       (POPM rL c' o')o R(opr) unmodified <n,a>
--                                       o M unused <n,a>
--                                       o c=size(r): delete a
------------------------------------------------------------------------
------------------------------------------------------------------------
-- b: FPUSH fSD fmf        |                o stack(b)=stack(a)
--    .                    .                o stack ulest indirekte <b,a>
--    .                    .                o size(fmf)=c
-- a: POPM c opr   -->  n: FSTP fSD fmf opr o
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: PUSHM c ob        b: PUSHR ob.sreg o stack(b)=stack(a)
--    |                    PUSHA rX ob   o stack ulest indirekte <b,a>
--    .                    .             o c>4*AllignFac
--    .            -->     .             o M uendret <b,a>
--    .                    .             o rX ledig i b+1
-- a: POPM rL c oa      a: PUSHR oa.sreg o (DI,ES,SI,DS,CX) ledig i a+1
--    |                    LOADA DI oa
--    |                    POPR  ES
--    |                    POPR  SI
--    |                    POPR  DS
--    |                    LOADC CX c/2
--    |                    RSTRW RMOV
------------------------------------------------------------------------
-------------------- 32 BIT MODE ONLY ----------------------------------
-- b: PUSHM c ob        b: PUSHA rE ob   o stack(b)=stack(a)
--    |                    .             o stack ulest indirekte <b,a>
--    .            -->     .             o c>4*AllignFac
--    .                    .             o M uendret <b,a>
-- a: POPM rL c oa      a: LOADA EDI oa  o rE ledig i b+1
--    |                    POPR  ESI     o (EDI,ESI,ECX) ledig i a+1
--    |                    LOADC ECX c/4
--    |                    RSTRW RMOV
------------------------------------------------------------------------
%+D Visible
Routine mPOPM; import ref(Qpkt) a;
begin ref(Qpkt) b,aa(4),bb,n; range(0:MaxWord) i,j,nb,c,s,u;
      range(0:nregs) r,rX; infix(MemAddr) opr; range(0:MaxByte) bf;
%-D   ref(Qpkt) ReMaX,ReMaY; -- used by RepMasseur macro
%+D   RST(R_mPOPM);
AGAIN: b:=FindPush2(a);
      j:=0; s:=0; aa:=a; opr:=a qua Qfrm4.opr; --- P.g.a  FPUSH
      if b=none --- May Be FPUSH ---
      then repeat i:=j; -- nb:=aa(i) qua Qfrm4.aux.val;
           while i < ((8/AllignFac)-1)
           do j:=i+1; aa(j):=aa(i).pred;
              if aa(j)=none then goto E5 endif;
              if aa(j).fnc <> qPOPM then goto E6 endif;
              nb:=aa(i) qua Qfrm4.aux.val; s:=s+nb
              opr.rela.val:=opr.rela.val-nb;
              if OprNE(%aa(j) qua Qfrm3.opr%,opr) then goto L1 endif;
              b:=FindPush2(aa(j)); if b <> none then goto LL endif;
           endrepeat;
L1:        goto E1;
      endif;
LL:   bf:=b.fnc; c:=a qua Qfrm4.aux.val; -- if EvalSeen then goto E7 endif;
      if bf=qPUSHR
      then r:=b.subc; s:=RegSize(r); if s>c then goto E2 endif;
           if s=1 then if c<>s
           then
%+D             WARNING("Masseur.mPOPM.2");
                goto E19;
           endif endif;
           n:=RegNextWrite(b.next,a,uMask(r));
           opr:=a qua Qfrm4.opr;
           if SameMemUsed(n,a) then goto E3 endif;
%+D        if listq1>1 then mPRINT2("POPM(1)",b,a) endif;
           n:= InsertQf3(n,qSTORE,0,r,a.type,opr);
           if c>s then
              opr.rela.val:=opr.rela.val+s;
              aa:=InsertQf4(a,qPOPM,0,a.reg,a.type,c-s,opr)
           endif;
           DeleteQinstr(a); DeleteQinstr(b); ReMasseur(n);
           if c>s then a:=aa; goto AGAIN endif;
      elsif bf=qFPUSH
      then if FmfSize(b.reg) <> (s+aa(j) qua Qfrm4.aux.val) then goto E10 endif;
%+D        if listq1>1 then mPRINT2("POPM(2)",b,a) endif;
           n:=InsertQf3(aa(j),qFSTP,b.subc,b.reg,a.type,opr);
           repeat DeleteQinstr(aa(j)) while j<>0 do j:=j-1 endrepeat;
           DeleteQinstr(b); ReMasseur(n);
      elsif bf=qPUSHM
      then if b qua Qfrm4.aux.val<>c then goto E16 endif;
           if c <= (4*AllignFac) then goto E8 endif;
%-E %-D    if RegDies(a,%wOR(wOR(wOR(wOR(uDI,uES),uSI),uDS),uCX)%) then -- OK
%-E %+D    if RegDies(a, wOR(wOR(wOR(wOR(uDI,uES),uSI),uDS),uCX) ) then -- OK
%+E %-D    if RegDies(a,%wOR(wOR(uEDI,uESI),uECX)%) then -- OK
%+E %+D    if RegDies(a, wOR(wOR(uEDI,uESI),uECX) ) then -- OK
           else goto E9 endif;
           if not RegUnWritten(b.next,a,uM) then goto E14 endif;
%-E        if RegDies(b,uSI) then rX:=qSI
%+E        if RegDies(b,uESI) then rX:=qESI
           else rX:= RegAvailable(b); if rX=0 then goto E15 endif endif;
           opr:=b qua Qfrm4.opr;
%+D        if listq1>1 then mPRINT2("POPM(3)",b,a) endif;
%+D        if UnAlligned(%c%) then IERR("Masseur.mPOPM.3") endif;
%-E        bb:=InsertQf1(b,qPUSHR,GetSreg(opr),cOBJ);
           bb:=InsertQf3(b,qPUSHA,0,rX,cADR,opr); DeleteQinstr(b);
           opr:=a qua Qfrm4.opr;
%-E        aa:=InsertQf1(a,qPUSHR,GetSreg(opr),cOBJ);
%-E        aa:=InsertQf3(a,qLOADA,0,qDI,cADR,opr);
%-E        aa:=InsertQf1(a,qPOPR,qES,cOBJ);
%-E        aa:=InsertQf1(a,qPOPR,qSI,cADR);
%-E        aa:=InsertQf1(a,qPOPR,qDS,cOBJ);
%-E        aa:=InsertQf2(a,qLOADC,0,qCX,cVAL,c/2);
%+E        aa:=InsertQf3(a,qLOADA,0,qEDI,cADR,opr);
%+E        aa:=InsertQf1(a,qPOPR,qESI,cADR);
%+E        aa:=InsertQf2(a,qLOADC,0,qECX,cVAL,c/4);
           aa:=InsertQf2(a,qRSTRW,qRMOV,qCLD,a.type,qREP);
           DeleteQinstr(a);
%+D        if listq1>1 then mPRINT2("POPM(3)-xx",bb,aa) endif;
           RepMasseur(bb);
      endif; --E7: 
E1:E2:E3:E5:E6:   E8:E9:E10:E14:E15:E16:E19:end;
%page
--    LOADC:
------------------------------------------------------------------------
-- b: LOADC r c               LOADC r c           o r unmodified <b,a>
--    .                  -->  .
-- a: LOADC r c               |
------------------------------------------------------------------------
%+D Visible
Routine mLOADC; import ref(Qpkt) a;
begin ref(Qpkt) b; range(0:nregs) r;
%+D   RST(R_mLOADC);
      r:=a.reg;
      b:=RegLastWrite(a,uMask(r)); if b=none then goto E1 endif;
      if b.fnc<>qLOADC then goto E2 endif;
      if b.reg<>r then goto E4 endif;
      if b.kind<>a.kind then goto E3 endif;
      if b qua Qfrm2.aux <> a qua Qfrm2.aux then goto E5 endif;
      if a.kind=K_Qfrm2b then
         if OprNE(b qua Qfrm2b.addr,a qua Qfrm2b.addr) then goto E6 endif
      endif;
      DeleteQinstr(a);
E1:E2:E3:E4:E5:E6:end; -- mLOADC
%page
--    LOADSC:
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: LOADSC sr rb const      LOADSC sr rb const  o sr unmodified <b,a>
--    .                       .                   o b.const.s=a.const.s
--   (PUSHR sr)              (PUSHR sr)           o ra dies in a
--    .                  -->  .
--   (POPR sr)               (POPR sr)
--    .                       .
-- a: LOADSC sr ra const      |
------------------------------------------------------------------------
%-E %+D Visible
%-E Routine mLOADSC; import ref(Qfrm2b) a;
%-E begin ref(Qfrm2b) b; range(0:nregs) sr; range(0:MaxWord) asegid;
%-E %+D   RST(R_mLOADSC);
%-E       if not RegDies(a,uMask(a.reg)) then goto E1 endif;
%-E       b:=a; sr:=a.subc;
%-E       repeat b:=RegLastWrite(b,uMask(sr));
%-E              if b=none then goto E2 endif;
%-E       while b.fnc=qPOPR do
%-E             b:=FindPush(b); if b=none then goto E3 endif; sr:=b.subc
%-E       endrepeat;
%-E       if b.fnc<>qLOADSC then goto E40 elsif b.subc<>sr then goto E41 endif;
%-E       asegid:=AdrSegid(a.addr);
%-E       if asegid <> 0
%-E       then if asegid = AdrSegid(b.addr) then DeleteQinstr(a) endif;
%-E       endif;
%-E E1:E2:E3:E40:E41:end;
%page
--    LSR:   
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: Lsr r opr nrep ofst     Lsr r opr nrep ofst   o r unmodified <b,a>
--    .                  -->  .                     o sr unmodified <b,a>
--    .                       .                     o R(opr) unmodified [b,a>
-- a: Lsr r opr nrep ofst     |                     o a.opr=b.opr
--                                                  o a.nrep=b.nrep
--                                                  o a.ofst=b.ofst
--    .                                             o M(opr) unmodified <b,a>
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: Lsr r1 opr nrep ofst    Lsr r1 opr nrep ofst  o R(opr) unmodified [b,a>
--    .                       .                     o sr unmodified <b,a>
--    .                       .                     o r1 unmodified <b,n>
--    |                --> m: MOV r,r1              o r unused <m,a>
--    .                       .                     o a.opr=b.opr
-- a: Lsr r opr nrep ofst     |                     o a.nrep=b.nrep
--                                                  o a.ofst=b.ofst
--    .                                             o M(opr) unmodified <b,a>
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: Lsr1 r opr nrep ofst    .                     o R(opr) unmodified [b,a>
--    .                       .                     o sr1 unmodified <b,n>
--    |                --> n: MOV sr,sr1            o sr unused <n,a>
--    .                       .                     o r unmodified <b,a>
--    .                       .                     o a.opr=b.opr
-- a: Lsr r opr nrep ofst     |                     o a.nrep=b.nrep
--                                                  o a.ofst=b.ofst
--    .                                             o M(opr) unmodified <b,a>
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: Lsr1 r1 opr nrep ofst   .                     o R(opr) unmodified [b,a>
--    .                       .                     o sr1 unmodified <b,n>
--    |                --> n: MOV sr,sr1            o sr unused <n,a>
--    .                       .                     o r1 unmodified <b,n>
--    |                --> m: MOV r,r1              o r unused <m,a>
--    .                       .                     o a.opr=b.opr
-- a: Lsr r opr nrep ofst     |                     o a.nrep=b.nrep
--                                                  o a.ofst=b.ofst
--    .                                             o M(opr) unmodified <b,a>
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: Lsr1 r1 oprb nrep ofst   Lsr r1 oprb nrep+1 ofst  o r unused <b,n>
--    .                        .                     o r1 unused <n,a>
--    |                 --> n: MOV  r,r1             o sr  unused <b,a>
--    .                        .                     o sr1 unused <b,a>
-- a: Lsr r sr1:[r1]+ofst 0 0  |                     o b.nrep=0 or a.ofst=b.ofst
------------------------------------------------------------------------
%-E %+D Visible
%-E Routine mLSR; import ref(Qfrm4c) a; export Boolean res;
%-E begin ref(Qfrm4c) b; ref(Qpkt) n,m,x,y; range(0:nregs) sr,r,sr1,r1;
%-E       infix(MemAddr) opr; range(0:MaxWord) uMsk; Boolean FirstTry;
%-E %-D   ref(Qpkt) ReMaX,ReMaY; -- used by RepMasseur macro
%-E       b:=a; r:=a.reg; opr:=a qua Qfrm3.opr; res:=false; FirstTry:=true;
%-E       if a.fnc=qLDS then sr:=qDS else sr:=qES endif;
%-E  L1:L2:L3:
%-E       b:=SameMemLastUsed(b); if b=none then goto E1 endif;
%-E       if b.fnc=qLDS then goto Lds1 elsif b.fnc=qLES
%-E       then Lds1: if OprNE(opr,b qua Qfrm3.opr) then goto E2 endif;
%-E            if b.nrep <> a.nrep
%-E            then if FirstTry then FirstTry:=false; goto L2 endif;
%-E                 goto E3
%-E            endif;
%-E            if b.aux  <> a.aux
%-E            then if FirstTry then FirstTry:=false; goto L3 endif;
%-E                 goto E4
%-E            endif;
%-E       elsif wAND(b.write,uM) <> 0 then goto E5 ---- USIKKER PAA DENNE
%-E       else goto L1 endif
%-E       r1:=b.reg; if b.fnc=qLDS then sr1:=qDS else sr1:=qES endif;
%-E       if sr <> sr1
%-E       then
%-E %+D        if listq1>1 then mPRINT2("LSR(T0)",b,a) endif;
%-E            if MakeRegUnWritten(b,a,sr1)     --- VERY TRICKY !!!!!!!
%-E            then
%-E %+D             if listq1>1 then mPRINT2("LSR(T1)",b,a) endif;
%-E                 r1:=b.reg; if b.fnc=qLDS then sr1:=qDS else sr1:=qES endif;
%-E            endif;
%-E       endif;
%-E       if sr=sr1
%-E       then if MakeRegUnWritten(b.next,a,sr)
%-E            then if r=r1
%-E                 then if MakeRegUnWritten(b.next,a,r)
%-E                      then
%-E %+D                       if listq1>1 then mPRINT2("LSR(1)",b,a) endif;
%-E                           DeleteQinstr(a); res:=true;
%-E                      endif
%-E                 else m:=RegNextWrite(b.next,a,uMask(r1));
%-E                      if MakeRegUnused(m,a,r) 
%-E                      then
%-E %+D                       if listq1>1 then mPRINT2("LSR(2)",b,a) endif;
%-E                           m:=InsertQf2(m,qMOV,0,r,cOBJ,r1);
%-E                           DeleteQinstr(a); res:=true;
%-E                           RepMasseur(m); --- ReMasseur(m);
%-E                      endif
%-E                 endif;
%-E            endif;
%-E       else
%-E            n:=RegNextWrite(b.next,a,uMask(sr1));
%-E            if MakeRegUnused(n,a,sr) 
%-E            then if r=r1
%-E                 then if MakeRegUnWritten(b.next,a,r)
%-E                      then
%-E %+D                       if listq1>1 then mPRINT2("LSR(3)",b,a) endif;
%-E                           n:=InsertQf2(n,qMOV,0,sr,cOBJ,sr1);
%-E                           DeleteQinstr(a); res:=true;
%-E                           RepMasseur(n); --- ReMasseur(n);
%-E                      endif
%-E                 else m:=RegNextWrite(b.next,a,uMask(r1));
%-E                      if MakeRegUnused(m,a,r) 
%-E                      then
%-E %+D                       if listq1>1 then mPRINT2("LSR(4)",b,a) endif;
%-E                           n:=InsertQf2(n,qMOV,0,sr,cOBJ,sr1);
%-E                           m:=InsertQf2(m,qMOV,0,r,cOBJ,r1);
%-E                           DeleteQinstr(a); res:=true;
%-E ---                       ReMasseur(n); ReMasseur(m);
%-E                           x:=b; repeat while (x<>n) and (x<>m)
%-E                           do x:=x.next endrepeat; RepMasseur(x)
%-E                      endif
%-E                 endif;
%-E            endif;
%-E       endif;
%-E       goto FIN1;
%-E E1:E2:E3:E4:E5:
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: Lsr1 r1 oprb nrep ofst   Lsr r1 oprb nrep+1 ofst  o r unused <b,n>
--    .                        .                     o r1 unused <n,a>
--    |                 --> n: MOV  r,r1             o sr  unused <b,a>
--    .                        .                     o sr1 unused <b,a>
-- a: Lsr r sr1:[r1]+ofst 0 0  |                     o b.nrep=0 or a.ofst=b.ofst
------------------------------------------------------------------------
%-E       if a.nrep <> 0 then goto EE1 endif;
%-E       if a.aux.val <> 0 then goto EE2 endif;
%-E       if a.opr.kind <> reladr then goto EE3 endif;
%-E       if GetIreg(a.opr) <> 0   then goto EE4 endif;
%-E       r1:=GetBreg(a.opr); sr1:=GetSreg(a.opr);
%-E       uMsk:=wOR(uMask(sr1),uMask(r1));
%-E       b:=RegLastWrite(a,uMsk); if b=none then goto EE5 endif;
%-E       if    b.fnc=qLDS then if sr1<>qDS then goto EE6 endif
%-E       elsif b.fnc=qLES then if sr1<>qES then goto EE7 endif;
%-E       else goto EE8 endif;
%-E       if not RegUnused(b.next,a,wOR(uMask(sr),uMask(sr1)))
%-E       then goto EE9 endif;
%-E       if r=r1
%-E       then L4: n:=none;
%-E            if not RegUnused(b.next,a,uMask(r)) then goto EE10 endif;
%-E       elsif ChangeReg(r1,r,b,a) then r1:=r; goto L4;
%-E       else n:=RegNextUsed(b.next,a,uMask(r1));
%-E            if not RegUnused(n,a,uMask(r)) then goto EE11 endif;
%-E       endif;
%-E       if b.nrep=0 then b.nrep:=1; b.aux:=a.opr.rela
%-E       else if b.aux <> a.opr.rela then goto EE12 endif;
%-E            b.nrep:=b.nrep+1;
%-E       endif;
%-E %+D   if listq1>1 then mPRINT2("LSR(5)",b,a) endif;
%-E       if n<>none then n:=InsertQf2(n,qMOV,0,r,cOBJ,r1) endif;
%-E       if sr=qDS then b.fnc:=qLDS else b.fnc:=qLES endif;
%-E       ModifyQinstr(b); DeleteQinstr(a); ReMasseur(b);
%-E       if n<>none then ReMasseur(n) endif;
%-E       res:=true;
%-E FIN1:
%-E EE1:EE2:EE3:EE4:EE5:EE6:EE7:EE8:EE9:EE10:EE11:EE12:
%-E end;
%page
--    LOAD:
------------------------------------------------------------------------
-------------------- 16 BIT MODE ONLY ----------------------------------
-- b: LOAD r oprb                |             o sr in (ES,DS)
-- a: LOAD sr opra   -->         Lsr r oprb    o r is not segreg
--                                             o oprb=opra-2
------------------------------------------------------------------------
-- b: <mov> r1 opr (nrep ofst)   <mov> r1 opr  o R(opr) unmodified <b,a>
--    .                          .             o M(opr) unmodified <b,a>
--    .                  -->  n: MOV r r1      o r1 out W(b) if r1 in opr
--    .                          .             o <mov> in (LOAD,STORE)
-- a: LOAD r opr nrep ofst       |             o samepart (r,r1)
--                                             o r1 unmodified <b,n>
--                                             o r unused <n,a>
--                                             o mov=LOAD: b.nrep=a.nrep
--                                             o mov=LOAD: b.ofst=a.ofst
--                                             o mov=STORE: a.nrep=0
------------------------------------------------------------------------
-- b: STORE r1 G@TMPQNT          |             o R(opr) unmodified <b,a>
--    .                          .             o M(opr) unmodified <b,a>
--    .                  -->  n: MOV r r1      o r1 out W(b) if r1 in opr
--    .                          .             o samepart (r,r1)
-- a: LOAD r G@TMPQNT nrep ofst  |             o a.nrep=0
--                                             o r1 unmodified <b,n>
--                                             o r unused <n,a>
------------------------------------------------------------------------
-------------------- 32 BIT MODE ONLY ----------------------------------
-- b: LOAD r opr nrep ofst    LOAD r opr nrep+1 ofst  o r unused <b,a>
--    .                  -->  .                     o b.nrep=0
--    .                       .                     o    or   a.ofst=b.ofst
-- a: LOAD r [r]+ofst 0 0     |                     o
------------------------------------------------------------------------
%+D Visible
Routine mLOAD; import ref(Qpkt) a;
begin ref(Qpkt) b,n; range(0:nregs) sr,r,r1;
      infix(MemAddr) opr; range(0:255) u;
%+E   range(0:5) nTry;
      sr:=a.reg;
%-E   if sr<>qDS then if sr<>qES then goto C1 endif endif;
%-E   b:=a.pred; if b=none then goto E1 endif;
%-E   if b.fnc<>qLOAD then goto C2 endif;
%-E   r:=b.reg;
%-E   if r<>qBX then if r<>qSI then if r<>qDI then goto C3 endif endif endif
%-E   opr:=a qua Qfrm3.opr; opr.rela.val:=opr.rela.val-2;
%-E   if OprEQ(b qua Qfrm3.opr,opr)
%-E   then
%-E %+D    if listq1>1 then mPRINT2("LOAD(1)",b,a) endif;
%-E        n:= InsertQf4c(a,if sr=qDS then qLDS else qLES,0,r,cOBJ,0,opr,0);
%-E        DeleteQinstr(a); DeleteQinstr(b); ReMasseur(n); goto E2
%-E   endif;
%-E C1:C2:C3:
%+E   if a.subc<>0 then goto E1 endif;  -- TEMP CORR ??????????????????
      r:=sr; opr:=a qua Qfrm3.opr;
%+E   if a qua Qfrm4c.nrep <> 0 then goto D1 endif;
%+E   if a qua Qfrm4c.aux.val <> 0 then goto D2 endif;
%+E   if opr.kind <> reladr then goto D3 endif;
%+E   if GetIreg(opr) <> 0   then goto D4 endif;
%+E   if GetBreg(opr) <> r   then goto D5 endif;
%+E   b:=RegLastUsed(a,uMask(r)); if b=none then goto D6 endif;
%+E   if b.fnc <> qLOAD then goto D7 endif;
%+E   if b.reg <> r then goto D8 endif;
%+E   if b qua Qfrm4c.nrep=0
%+E   then b qua Qfrm4c.nrep:=1; b qua Qfrm4c.aux:=opr.rela
%+E   else if b qua Qfrm4c.aux <> opr.rela then goto D9 endif;
%+E        b qua Qfrm4c.nrep:=b qua Qfrm4c.nrep+1;
%+E   endif;
%+E %+D    if listq1>1 then mPRINT2("LOAD(1)",b,a) endif;
%+E   ModifyQinstr(b); DeleteQinstr(a); ReMasseur(b); goto E2;
%+E D1:D2:D3:D4:D5:D6:D7:D8:D9:
      b:=a;
%+E   nTry:=4;
%+E L2:L3:
 L1:  b:=SameMemLastUsed(b); if b=none then goto Ex2 endif;
      if b.fnc=qLOAD
      then if OprNE(opr,b qua Qfrm3.opr) then goto Ex6 endif;
%+E        if b qua Qfrm4c.nrep <> a qua Qfrm4c.nrep
%+E        then if nTry <> 0 then nTry:=nTry-1; goto L2 endif;
%+E             goto Ex3
%+E        endif;
%+E        if b qua Qfrm4c.aux  <> a qua Qfrm4c.aux  
%+E        then if nTry <> 0 then nTry:=nTry-1; goto L3 endif;
%+E             goto Ex4
%+E        endif;
      elsif wAND(b.write,uM) <> 0
      then if b.fnc=qSTORE
           then if OprNE(opr,b qua Qfrm3.opr) then goto Ex7 endif;
%+E             if a qua Qfrm4c.nrep <> 0 then goto Ex5 endif;
           else goto Ex8 endif
      else goto L1 endif
%+E   if b.subc<>0 then goto E2b endif;  -- TEMP CORR ??????????????????
      r1:=b.reg;
      if r=r1
      then if MakeRegUnWritten(b.next,a,r)
           then
%+D             if listq1>1 then mPRINT2("LOAD(2)",b,a) endif;
                if b.fnc=qSTORE then if OprEQ(opr,TMPQNT)
                then DeleteQinstr(b) endif endif;
                DeleteQinstr(a);
           endif
      elsif SamePart(r,r1)
      then n:=RegNextWrite(b.next,a,uMask(r1));
           if MakeRegUnused(n,a,r) 
           then
%+D             if listq1>1 then mPRINT2("LOAD(3)",b,a) endif;
                n:=InsertQf2(n,qMOV,0,r,a.type,r1);
                if b.fnc=qSTORE then if OprEQ(opr,TMPQNT)
                then DeleteQinstr(b) endif endif;
                DeleteQinstr(a); ReMasseur(n)
           endif
      endif;
%+E Ex3:Ex4:Ex5:
    Ex2:Ex6:Ex7:Ex8:
%+E E2b:
   E1:E2:
end; -- mLOAD
%page
--    LOADA:
------------------------------------------------------------------------
-- a: LOADA r disp  -->    LOADC r disp
------------------------------------------------------------------------
-- a: LOADA r r2    -->    MOV r r2
------------------------------------------------------------------------
-- b: LOADA r opr          LOADA r opr     o r unmodified <b,a>
--    .                    .               o R(opr) unmodified <b,a>
--    .             -->    .
--    .                    .
-- a: LOADA r opr          |
------------------------------------------------------------------------
%+D Visible
Routine mLOADA; import ref(Qpkt) a;
begin ref(Qpkt) b,n; infix(MemAddr) aopr;
      range(0:nregs) r,br,ir; range(0:MaxWord) rela; boolean reloc;
%+D   RST(R_mLOADA);
      r:=a.reg; aopr:=a qua Qfrm3.opr;
      br:=GetBreg(aopr); ir:=GetIreg(aopr); rela:=aopr.rela.val;
      if aopr.kind=locadr
      then rela:=rela-aopr.loca; reloc:=false;
      else reloc:=aopr.kind<>reladr endif;
      if (br=0) and (ir=0)
      then if reloc
%-E        then n:=InsertQf2b(a,qLOADC,0,r,cOBJ,F_OFFSET,aopr);
%+E        then n:=InsertQf2b(a,qLOADC,0,r,cOBJ,0,aopr);
           else n:=InsertQf2(a,qLOADC,0,r,cOBJ,rela) endif;
           DeleteQinstr(a); ReMasseur(n)
      elsif ((not reloc) and (br=0) or (ir=0)) and (rela=0)
      then n:=InsertQf2(a,qMOV,0,r,cADR,br+ir); DeleteQinstr(a); ReMasseur(n)
      else b:=RegLastWrite(a,uMask(r));
           if b <> none
           then if b.fnc <> qLOADA then goto E1 endif;
                if b.reg <> r then goto E2 endif;
                if OprNE(aopr,b qua Qfrm3.opr) then goto E3 endif;
                if RegsReadUnmodified(b,a)=a then DeleteQinstr(a) endif
           endif
      endif;
E1:E2:E3:end;
%page
--    MOV:
------------------------------------------------------------------------
-- a: MOV subc r1 r1  -->  |
------------------------------------------------------------------------
-- b: MOV subc r1 r2       MOV subc r1 r2  o r1 uendret <b,a>
--    .                    .               o r2 uendret (b,a>
--    .            -->     .               o a.subc=b.subc
--    .                    .
-- a: MOV subc r1 r2       |
------------------------------------------------------------------------
-- b: load subc r2 data    |               o r2 engangs (b,a)
--    .                    .               o R(data) uendret <b,a>
--    .        -->  n: load a'subc r1 data o r1 ubrukt <n,a>
--    .                    .               o b=(LOADC,LOADA,MOV,LOAD,POPR)
-- a: MOV subc r1 r2       |               o b=LOAD: M uendret <b,n>
--                                         o b=POPR: stack(n)=stack(a)
--                                         o b.subc=0, r1 not segreg
------------------------------------------------------------------------
-- b: DYADR y r2 r1        |               o r2 oneshot (b,a)
--    .                    .               o r1 unmodified <b,a>
--    .            -->  n: DYADR y r1 r2   o y<>SUB,CMP,SUBM,SBB,DECO,SUBF,SBBF
--    .                    .               o F unused <b,n>
-- a: MOV subc r1 r2       |               o r1 unused <n,a>
--                                         o subc=0, r1 not segreg
------------------------------------------------------------------------
--    |                    MOV r1 r2       o r2 oneshot (b,a)
-- b: MONADR m r2       b: MONADR m r1     o r1 unused <b-1,a>
--    .            -->     .               o MOV in b-1 is Masseurd
-- a: MOV subc r1 r2       |
--                                         o subc=0, r1 not segreg
------------------------------------------------------------------------
--    |                    MOV r1 r2       o r2 oneshot (b,a)
-- b: DYADk y r2 d      b: DYADk y r1 d    o r1 unused <b-1,a>
--    .            -->     .               o k in ('R','C','M')
-- a: MOV subc r1 r2       |               o k='R': d<>r1
--                                         o MOV in b-1 is Masseurd
--                                         o subc=0, r1 not segreg
------------------------------------------------------------------------
%+D Visible
Routine mMOV; import ref(Qpkt) a;
begin ref(Qpkt) b,n,t; range(0:nregs) r1,r2,rd;
      range(0:qMXX) op;
%+E   range(0:nregs) br1;
      range(0:255) sc;
%+D   RST(R_mMOV);
      success:=false; r1:=a.reg; r2:=a qua Qfrm2.aux.val;
%+E   if a.subc<>0 then r1:=WholeReg(r1) endif;
      if r1=r2
      then if not trial then DeleteQinstr(a) endif; goto D1 endif;
      b:=RegLastWrite(a,uMask(r1));
      if b<>none
      then if b.fnc=qMOV
           then
%-E             if b.reg=r1
%+E             br1:=b.reg;
%+E             if b.subc<>0 then br1:=WholeReg(br1) endif;
%+E             if (br1=r1) and (b.subc=a.subc)
                then if b qua Qfrm2.aux.val=r2
                     then if RegUnWritten(b,a,uMask(r2))
                          then if not trial then DeleteQinstr(a) endif;
                               goto D2;
                          endif;
                     endif;
                endif;
           endif;
      endif;
----  ******************************************************************
      b:=RegClosedGroup(a,uMask(r2));
      if b<>none then if ChangeReg(r2,r1,b,a) then goto D3 endif endif;
----  ******************************************************************
%-E   if r1 >= qES then goto Ex1 endif;
      b:=RegOneshot(a,uMask(r2));
%+E   if b=none
%+E   then if a.subc <> 0
%+E        then if r1 <> WholeReg(r2) then
%+ED                                       WARNING("HER: GOT IT")
%+E             else b:=RegLastUsed(a,uMask(r2));
%+E                  if b <> none
%+E                  then if wAND(b.write,uMask(r2))<>uMask(r2)
%+E                       then b:=none endif;
%+E                  endif;
%+E             endif;
%+E        endif;
           if b=none then goto E1 endif;
%+E   endif;

      op:=b.fnc;
      if op=qPOPR then if b.subc <> r2 then goto E2a endif;
      elsif b.reg <> r2 then goto E2 endif;
      case 0:qMXX (op)
      when qLOADC,qLOADA,qMOV,qLOAD,qPOPR:
         n:=RegsReadUnmodified(b,a);
         if not MaaaRegUnused(n,a,r1) then goto E3 endif;
         if op=qPOPR then if not StackEqual(n,a) then goto E4 endif endif
         case 0:qMXX (op)
            when qLOADC:
%+E              if a.subc<>0 then goto Ex1 endif; -- TEMP ????
               if b.kind=K_Qfrm2 then
                  n:= InsertQf2(n,qLOADC,0,r1,a.type,b qua Qfrm2.aux.val)
               else -- K_Qfrm2b
                  n:= InsertQf2b(n,qLOADC,0,r1,a.type,b qua Qfrm2b.aux.val,
                                  b qua Qfrm2b.addr)
               endif;
            when qLOADA:
%+E              if a.subc<>0 then goto Ex2 endif; -- TEMP ????
                 n:=InsertQf3(n,qLOADA,0,r1,a.type,b qua Qfrm3.opr);
            when qMOV:
%+E              if b.subc<>0 then goto Ex3 endif; -- TEMP ????
                 n:=InsertQf2(n,qMOV,a.subc,a.reg,a.type,b qua Qfrm2.aux.val);
            when qLOAD:
---  %+E              if b.subc<>0 then goto Ex4 endif; -- TEMP ????
                 n:=InsertQf4c(n,qLOAD,a.subc,a.reg,a.type,b qua Qfrm4c.aux.val,
                                       b qua Qfrm3.opr,b qua Qfrm4c.nrep);
            when qPOPR:
%+E              if a.subc<>0 then goto Ex5 endif; -- TEMP ????
                 n:=InsertQf1(n,qPOPR,r1,a.type)
         endcase;
      when qMONADR,qDYADR,qDYADC,qDYADM:
%+E      if a.subc<>0 then goto Ex6 endif; -- TEMP ????
         sc:=b.subc;
         if op=qDYADR then rd:=b qua Qfrm2.aux.val;
            if rd=r2 then rd:=r1
            elsif rd=r1 then
               case 0:19 (sc)
               when qSUB,qSUBM,qSUBF,qSBB,qSBBF,qDECO,qCMP: goto E5 endcase;
               n:= RegLastUsed(a,uMask(r1));
               if n<>b then
                  if n=none then goto E6 endif;
                  if RegLastUsed(n,uF) <> b then goto E7 endif;
                  if RegLastUsed(n,uMask(r1)) <> b then goto E7x endif
               endif;
               n:= InsertQf2(n,qDYADR,sc,r1,a.type,r2);
               goto A1
            endif
         endif;
         if not MaaaRegUnused(b,a,r1) then goto E10 endif;
         t:=InsertQf1(b,qPOPR,r2,a.type); n:=InsertQf2(t,qMOV,0,r1,a.type,r2);
         ReMasseur(n); DeleteQinstr(t);
         if not success then DeleteQinstr(n); goto E8 endif;
         if    op=qMONADR then n:=InsertQf2(b,qMONADR,sc,r1,a.type,0)
         elsif op=qDYADR  then n:=InsertQf2(b,qDYADR,sc,r1,a.type,rd)
         elsif op=qDYADM  then n:=InsertQf3(b,qDYADM,sc,r1,a.type,
                                                              b qua Qfrm3.opr)
         else --  qDYADC
              if b.kind=K_Qfrm2
              then n:=InsertQf2(b,qDYADC,sc,r1,a.type,b qua Qfrm2.aux.val)
              else --   K_Qfrm2b
                   n:=InsertQf2b(b,qDYADC,sc,r1,a.type,b qua Qfrm2b.aux.val,
                                                b qua Qfrm2b.addr)
              endif
         endif
      otherwise goto E9 endcase;
A1:   DeleteQinstr(a); DeleteQinstr(b); ReMasseur(n);
D1:D2:D3:success:=true;
%-E Ex1:
--- %+E Ex1:Ex2:Ex3:Ex4:Ex5:Ex6:
%+E Ex1:Ex2:Ex3:Ex5:Ex6:
E1:E2a:E2:E3:E4:E5:E6:E7:E7x:E8:E9:E10:end;
%page
--    STORE:
--------------------------------------------------------------------
-- b: LOAD r opr nrep ofst |               o r oneshot (b,a)
--    .            -->     .               o R(opr) unmodified <b,a>
-- a: STORE r opr          |               o M(opr) unmodified <b,a>
--                                         o b.nrep=0
--------------------------------------------------------------------
-- b: LOADC r c            |               o r oneshot (b,a)
--    .            -->     .
-- a: STORE r opr       a: MOVMC w c opr
--------------------------------------------------------------------
-- b: MOV r r2             |               o r oneshot (b,a)
--    .                    .               o r2 unmodified <b,n>
--    .            -->  n: STORE t r2' a   o R(opr) unmodified <n,a>    --MY
--    .                    .               o M unused <n,a>
--    .                    .               o whole(r1)=r or r1=r        --MY
-- a: STORE r1 opr         |               o r2' = r2 with size as r1   --MY
--------------------------------------------------------------------
-- b: POPR r            b: POPM 0 2:4 opr  o r oneshot (b,a)
--    .            -->     .               o size(r)=AllignFac
--    .                    .               o M unused <b,a>
-- a: STORE r opr          |               o R(opr) unmodified <b,a>
--------------------------------------------------------------------
-- b: POPR r               |               o r oneshot (b,a)
--    .            -->     .               o size(r)=AllignFac
-- a: STORE r opr       a: POPM 0 2:4 opr  o stack(b)=stack(a)
--------------------------------------------------------------------
-- c: LOAD r opr nrep ofst |               o r oneshot (b,a)
--    .                    .               o r unused <c,b>
-- b: MONADR m r           |               o R(opr) unmodified <c,a>
--    .                    .               o M unmodified <c,n>
--    .            -->  n: MONADM m opr    o M unused <n,a>
--    .                    .               o F unused <b,n>
-- a: STORE r opr          |               o c.nrep=0
--------------------------------------------------------------------
-- c: LOAD r opr nrep ofst |               o r oneshot (b,a)
--    .                    .               o r unused <c,b>
-- b: DYADC y r c          |               o R(opr) unmodified <c,a>
--    .                    .               o M unmodified <c,n>
--    .            -->  n: DYADMC y w c opro M unused <n,a>
--    .                    .               o F unused <b,n>
-- a: STORE r opr          |               o y not in <qINCO,qDECO>
--                                         o c.nrep=0
--------------------------------------------------------------------
-- c: LOAD r opr nrep ofst |               o r oneshot (b,a)
--    .                    .               o r unused <c,b>
-- b: DYADR y r r2         |               o R(opr) unmodified <c,a>
--    .                    .               o M unmodified <c,n>
--    .           -->  n: DYADMR y r2' opr o M unused <n,a>             --MY
--    .                    .               o F unused <b,n>
--    .                    .               o y not in <qINCO,qDECO>
--    .                    .               o r2 unused <b,n>
--    .                    .               o whole(r1)=r or r1=r        --MY
-- a: STORE r1 opr         |               o r2' = r2 with size as r1   --MY
--                                         o c.nrep=0, r <> r2
--------------------------------------------------------------------
%+D Visible
Routine mSTORE; import ref(Qpkt) a;
begin ref(Qpkt) b,c,n; range(0:nregs) r,r2;
      infix(MemAddr) opr; range(0:qMXX) bf; range(0:MaxWord) uMsk;
%+D   RST(R_mSTORE);
   r:=a.reg; b:=RegOneshot(a,uMask(r)); if b=none then goto E1 endif;
   opr:= a qua Qfrm3.opr; bf:=b.fnc;
   if bf=qMONADR then goto M1 elsif bf=qDYADC then goto M2 elsif bf=qDYADR then
M1:M2:c:=RegLastUsed(b,uMask(r)); if c=none then goto E2 endif;
      if c.fnc <> qLOAD then goto E3 endif;
%+E   if c qua Qfrm4c.nrep<>0 then goto Ex2 endif;
      if r <> c.reg then goto E4 endif;
      if OprNE(opr,c qua Qfrm3.opr) then goto E5 endif;
      if RegsReadUnmodified(c,a) <> a then goto E6 endif;
      if RegUnRead(b.next,a,uM) then n:=b
      else n:=a;
         if not RegUnused(b.next,a,uF) then goto E7 endif;
         if bf=qDYADR then r2:=b qua Qfrm2.aux.val;
            if not MaaaRegUnWritten(b,a,r2) then goto E8 endif
         endif;
      endif;
      if    bf=qMONADR
      then
%+D        if listq1>1 then mPRINT3("STORE(1)",c,b,a) endif;
           n:=InsertQf3(n,qMONADM,b.subc,r,a.type,opr);
      elsif bf=qDYADR 
      then if (b.subc=qINCO) or (b.subc=qDECO) then goto E18 endif;
           r2:=b qua Qfrm2.aux.val;               --MY
           if r=r2 then goto E20 endif;           --MY
%+E        if r<qEAX then r2:=r2-8 endif;         --MY
           if r<qAX then r2:=bAND(r2,7) endif;    --MY
%+D        if listq1>1 then mPRINT3("STORE(2)",c,b,a) endif;
           n:=InsertQf3(n,qDYADMR,b.subc,r2,a.type,opr); --MY
      else -- bf=qDYADC
           if (b.subc=qINCO) or (b.subc=qDECO) then goto E19 endif;
%+D        if listq1>1 then mPRINT3("STORE(3)",c,b,a) endif;
           if b.kind=K_Qfrm2
           then n:=InsertQf4(n,qDYADMC,b.subc,r,a.type,b qua Qfrm2.aux.val,opr)
           else -- b.kind=K_Qfrm2b
                n:=InsertQf4b(n,qDYADMC,b.subc,r,a.type,b qua Qfrm2.aux.val,
                                                 opr,b qua Qfrm2b.addr);
         endif
      endif;
      DeleteQinstr(a); RepDelete(b); ReMasseur(n); goto E9;
   elsif bf=qLOAD then
%+D   if listq1>1 then mPRINT2("STORE(4)",b,a) endif;
%+E   if b.subc<>0 then goto Ex3 endif; -- TEMP ????
%+E   if b qua Qfrm4c.nrep<>0 then goto Ex4 endif;
      if OprNE(opr,b qua Qfrm3.opr) then goto E14 endif;
      if SameMemWritten(b,a) then goto E15 endif;
      DeleteQinstr(a); RepDelete(b); goto E16
   elsif bf=qLOADC then n:=a
   elsif bf=qMOV then
%+E   if b.subc<>0 then goto Ex5 endif; -- TEMP ????
      n:= RegsReadUnmodified(b,a)
   elsif bf=qPOPR then
%-E   if r<qAX  then goto E10 endif; -- size(r)<>2
%+E   if r<qEAX then goto E10 endif; -- size(r)<>4
      if StackEqual(b.next,a) then n:=a else n:=b.next endif
   else goto E11
   endif;
   if not RegUnWritten(n,a,OprRegs(opr)) then goto E12 endif;
   if not RegUnused(n,a,uM) then goto E13 endif;
%+D if listq1>1 then mPRINT2("STORE(5)",b,a) endif;
   if    bf=qMOV   then r2:=b qua Qfrm2.aux.val;                  --MY
%+E                     if r<qEAX then r2:=r2-8 endif;            --MY
                        if r<qAX then r2:=bAND(r2,7) endif;       --MY
                        n:=InsertQf3(n,qSTORE,0,r2,a.type,opr)    --MY
   elsif bf=qPOPR  then n:=InsertQf4(n,qPOPM,0,0,a.type,AllignFac,opr)
   else -- bf=qLOADC
      if b.kind=K_Qfrm2 then
         n:=InsertQf4(a,qMOVMC,0,r,a.type,b qua Qfrm2.aux.val,opr)
      else -- b.kind=k_Qfrm2b
         n:=InsertQf4b(a,qMOVMC,0,r,a.type,b qua Qfrm2b.aux.val,opr,
                       b qua Qfrm2b.addr)
      endif
   endif;
   DeleteQinstr(a); DeleteQinstr(b); ReMasseur(n);
%+E Ex2:Ex3:Ex4:Ex5:
E1:E2:E3:E4:E5:E6:E7:E8:E9:E10:
E11:E12:E13:E14:E15:E16:E18:E19:E20:
end; -- mSTORE
%page
--    MONADR:
-----------------------------------------------------------------------
-- b: LOADC r c           |              o r ubrukt <b,a>  m<>NEGM
--    .           -->     .
-- a: MONADR m r       a: LOADC r m(c)
-----------------------------------------------------------------------
%+D Visible
Routine mMONADR; import ref(Qpkt) a;
begin ref(Qpkt) b,n; range(0:nregs) r;
%-E   short integer ci; range(0:MaxWord) cw;
%+E   integer ci;
%+D   RST(R_mMONADR);
      r:=a.reg; b:= RegLastUsed(a,uMask(r));
      if b=none then goto E1 endif;
      if b.fnc<>qLOADC then goto E2 endif;
      if b.reg<>r then goto E3 endif;
      if b.kind<>k_Qfrm2 then goto E4 endif;
%-E   cw:= b qua Qfrm2.aux.val; ci:=cw;
%+E   ci:= b qua Qfrm2.aux.val;
      case 0:14 (a.subc)
      when qNOT:         ci:= -ci-1;
      when qNEG,qNEGF:   ci:= -ci;
      when qINC,qINCF:   ci:= ci+1;
      when qDEC,qDECF:   ci:= ci-1;
      when qSHL1,qSHL1F: ci:= ci+ci;
      when qSHR1,qSHR1F: ci:= wSHR(ci,1);
      when qSAR1,qSAR1F: ci:= ci/2;
      otherwise goto E5 endcase;
%-E   cw:=ci; n:= InsertQf2(a,qLOADC,0,r,a.type,cw);
%+E   n:= InsertQf2(a,qLOADC,0,r,a.type,ci);
      DeleteQinstr(a); DeleteQinstr(b); ReMasseur(n);
E1:E2:E3:E4:E5:end; -- mMONADR
%page
--    tryreverse:
------------------------------------------------------------------------
-- c: load r1 d             load r2 d           v bin in (DYADR,TRIADR)
--    .                     .                   v f is commutative
--    .                     .                   o (r1) simplerthan (r2)
-- b: (r2,Rb,Db):=Fb(Lb)    (r2,Rb,Dc):=Fb(Lb)  o r1 unused <c,a>
--    .                -->  MOV r1 r2           o r2 oneshot (b,a)
--    .                     .                   o c<b: r2 unused <c,b>
--    .                     .                   o b<c: r1 unused <b,c>
-- a: bin f r1 r2           bin f r1 r2         o MOV in b+1 is Masseurd
------------------------------------------------------------------------

%+D Visible
Routine QinstrBefore; import ref(Qpkt) a,b,c; export Boolean res;
begin
%+D   range(0:MaxWord) nPrev; nPrev:=0;
%+D   RST(R_QinstrBefore);
      repeat a:=a.pred while a<>b do
         if a=c then res:=true; goto E endif
%+D      nPrev:=nPrev+1;
      endrepeat; res:=false
E:
%+D   if (TLIST>4) and (nPrev > 50)
%+D   then Ed(errmsg,"QinstrBefore:nPrev=");
%+D        EdWrd(errmsg,nPrev); WARNING("  ");
%+D   endif;
end;

%+D Visible
Routine TryReverse; import ref(Qpkt) a; range(0:255) r1,r2,lkconst;
begin ref(Qpkt) b,c,t,n; range(0:255) lk1,lk2;
%+D   RST(R_TryReverse);
RETRY:
   c:= RegLastUsed(a,uMask(r1));
%-D if c=none then goto E1 endif;
%+D if c=none then if listq1>2 then mTERM("TryReverse",1) endif; goto E1 endif;
   b:= RegOneshot(a,uMask(r2));
%-D if b=none then goto E2 endif;
%+D if b=none then if listq1>2 then mTERM("TryReverse",2) endif; goto E2 endif;
   case 0:qMXX (c.fnc)
      when qLOADC: lk1:= lkconst -- 1 or 6
      when qLOAD:  lk1:= 2
%+E        if c.subc<>0 then goto Ex1 endif; -- TEMP ????
      when qMOV:   if c qua Qfrm2.aux.val<>r2 then lk1:=3 else lk1:=5 endif
%+E        if c.subc<>0 then goto Ex2 endif; -- TEMP ????
      when qPOPR:  lk1:= 4
      otherwise    lk1:= 7
   endcase;
   if c.reg <> r1
%-D then goto E3 endif;
%+D then if listq1>2 then mTERM("TryReverse",3) endif; goto E3 endif;
   case 0:qMXX (b.fnc)
      when qLOADC: lk2:= lkconst -- 1 or 6
      when qLOAD:  lk2:= 2
%+E        if b.subc<>0 then goto Ex3 endif; -- TEMP ????
      when qMOV:   if b qua Qfrm2.aux.val<>r1 then lk2:=3 else lk2:=5 endif
%+E        if b.subc<>0 then goto Ex4 endif; -- TEMP ????
      when qPOPR:  lk2:= 4
      otherwise    lk2:= 7
   endcase;
   if (lk1>5) or (lk1>=lk2)
%-D then goto E4 endif;
%+D then if listq1>2 then mTERM("TryReverse",4) endif; goto E4 endif;
   if QinstrBefore(a,b,c) then -- b<c:
      if not (RegUnused(b.next,c,uMask(r1))
          and RegUnRead(c,c.next,uMask(r1)))
%-D   then goto E5 endif
%+D   then if listq1>2 then mTERM("TryReverse",5) endif; goto E5 endif;
   else -- c<b:
      if not (RegUnused(c.next,b,uMask(r2))
          and RegUnRead(b,b.next,uMask(r2)))
%-D   then goto E6 endif
%+D   then if listq1>2 then mTERM("TryReverse",6) endif; goto E6 endif;
   endif;
   t:=InsertQf1(b.next,qPOPR,r2,c.type); n:=InsertQf2(t,qMOV,0,r1,c.type,r2);
   trial:=false; ReMasseur(n); DeleteQinstr(t);
   if not success then DeleteQinstr(n);
%+D   if listq1>2 then mTERM("TryReverse",7) endif;
      goto E7
   endif;
   if c.fnc=qPOPR then c.subc:=r2 else c.reg:=r2 endif; ModifyQinstr(c);
   ReMasseur(c); reversed:= not reversed; goto RETRY;
%+E Ex1:Ex2:Ex3:Ex4:
E1:E2:E3:E4:E5:E6:E7:end; -- TryReverse
%page
--    DYADR:
------------------------------------------------------------------------
-- b: LOADC r data         |               o r unused <b,a>
--    .                    .               o F dead in a
--                                         o b.nrep=0
-- a: ADD r r      -->     LOADC r 2*data  o
------------------------------------------------------------------------
-- b: LOADC r data         LOADC r data    o r unmodified <b,a>
--    .                    .               o F dead in a
--                                         o b.nrep=0
-- a: ADD r r      -->     LOADC r 2*data  o
------------------------------------------------------------------------
-- b: load r2 data nrep of |               o r1<>r2
--    .                    .               o r2 engangs <b,a>
--    .            -->  n: DYADk y r1 data o b=LOADC(k:=C),MOV(k:=R),LOAD(k:=M)
--    .                    .               o RR(b) uendret <b,n>
-- a: DYADR y r1 r2        |               o r1,F ubrukt <n,a>
--                                         o b.nrep=0
------------------------------------------------------------------------
-- b: load r2 data nrep of .               o
--    .           |        .               o r1 engangs <b,a>
--    .           |        .               o b=LOADC,MOV,LOAD
--    .           \-->     load r1 ...     o
-- a: DYADR y r1 r2        DYADR y r1 r2   o r1   ubrukt [b,a>
------------------------------------------------------------------------
%+D Visible
Routine mDYADR; import ref(Qpkt) a;
begin ref(Qpkt) b,n; range(0:255) r1,r2,ob,on,y; range (0:maxWord) rMask;
%-D   ref(Qpkt) ReMaX,ReMaY; -- used by RepMasseur macro
%+D   RST(R_mDYADR);
      r1:=a.reg; r2:=a qua Qfrm2.aux.val;
      b:=RegLastWrite(a,uMask(r1));
      if b <> none
      then ob:=b.fnc;
           if r1=r2
           then if a.subc=qADD then goto A1 elsif a.subc=qADDM then goto A2
                elsif a.subc=qADDF
                then A1:A2: if RegDies(a,uF)
                     then if ob = qLOADC
                          then if b.reg <> r1 then goto E8 endif;
                               if b.kind <> K_Qfrm2 then goto E7 endif;
%+D                            if listq1>1 then mPRINT2("DYADR(1)",b,a) endif;
                               InsertQf2(a,qLOADC,0,r1,a.type,
                                                       (b qua Qfrm2.aux.val)*2)
                               DeleteQinstr(a);
                               if CheckRegFree(b.next,uMask(r1))
                               then DeleteQinstr(b)
                               else RepMasseur(b.next) endif;
                          endif;
                     endif;
                endif;
                goto E1
           endif;
           if b.next<>a
           then if ob=qLOAD then rMask:=wOR(oprRegs(b qua Qfrm4.opr),uM)
                elsif ob=qMOV then rMask:=uMask(b qua Qfrm2.aux.val)
                elsif ob=qLOADC then rMask:=0 else goto NX1 endif
                if RegUnused(b.next,a,uMask(r1))
                then if regUnWritten(b.next,a,rMask)
                     then
%+D                       if listq1>1 then mPRINT2("DYADR(3)",b,a) endif;
                          moveQinstr(b,a);
                endif endif;
           endif
      endif;
 NX1: if RegSize(r1)<>RegSize(r2)
      then
%+D        IERR("Masseur.mDYADR");
           goto E6;
      endif;
      y:=a.subc;
      case 0:19 (y)
      when qSUB,qSUBM,qSUBF,qSBB,qSBBF,qDECO,qCMP: -- Nothing
      otherwise TryReverse(a,r1,r2,1) endcase;
      b:=RegOneshot(a,uMask(r2)); if b=none then goto E2 endif;
      ob:=b.fnc;
      if ob=qLOADC then on:=qDYADC elsif ob=qMOV then on:=qDYADR
%+E        if b.subc<>0 then goto Ex1 endif; -- TEMP ????
      elsif ob=qLOAD then on:=qDYADM
%+E        if b.subc<>0 then goto Ex2 endif; -- TEMP ????
%+E        if b qua Qfrm4c.nrep<>0 then goto Ex3 endif;
      else goto E3 endif;
      n:=RegsReadUnmodified(b,a);
      if not MaaaRegUnused(n,a,r1) then goto E4 endif;
      if not RegUnused(n,a,uF) then goto E5 endif;
%+D   if listq1>1 then mPRINT2("DYADR(2)",b,a) endif;
      if on=qDYADC then
         if b.kind=K_Qfrm2 then
            n:= InsertQf2(n,qDYADC,y,r1,a.type,b qua Qfrm2.aux.val)
         else -- K_Qfrm2b
            n:= InsertQf2b(n,qDYADC,y,r1,a.type,b qua Qfrm2b.aux.val,
                            b qua Qfrm2b.addr)
         endif
      elsif on=qDYADR then
         n:= InsertQf2(n,qDYADR,y,r1,a.type,b qua Qfrm2.aux.val)
      else -- qDYADM
         n:= InsertQf3(n,qDYADM,y,r1,a.type,b qua Qfrm3.opr)
      endif;
      DeleteQinstr(a); DeleteQinstr(b);
      ReMasseur(n);
%+E Ex1:Ex2:Ex3:
E1:E2:E3:E4:E5:E6:E7:E8:end;
%page
--    DYADC:
------------------------------------------------------------------------
-- a: DYADC AND r 0 -->    LOADC r 0        o F dead
------------------------------------------------------------------------
-- a: DYADC y r 0   -->    |                o F dead
--                                          o y out (AND,CMP,ADDM,SUBM,
--                                                   ADC,SBB,ADCF,SBBF)
------------------------------------------------------------------------
-- a: DYADC ADD r 1 -->    MONADR INC r
------------------------------------------------------------------------
-- a: DYADC SUB r 1 -->    MONADR DEC r
------------------------------------------------------------------------
-- a: DYADC ADD r -1-->    MONADR DEC r
------------------------------------------------------------------------
-- a: DYADC SUB r -1-->    MONADR INC r
------------------------------------------------------------------------
-- b: LOADC r c1           |                o r unused <b,a>
--    .             -->    .                o F not dead in a: OR in a+1
-- a: DYADC y r c          LOADC r y(c,c1)
--    |                   (DYADR OR r r)
------------------------------------------------------------------------
-- b: LOAD r opr nrep ofst |                o r engangs (b,a)
--    .                    .                o RR(b) uendret <b,n>
--    .             --> n: DYADMC CMP width const opr
--    .                    .                o F ubrukt <n,a>
-- a: DYADC CMP r const    |
------------------------------------------------------------------------
-- b: DYADk y r data       DYADk y r data   o r unmodified <b,a>
--    .             -->    .                o F unmodified <b,a>
-- a: DYADC CMPf r 0       |                o y <> CMPf
------------------------------------------------------------------------
-- b: MONADR m r           MONADR m r       o r unmodified <b,a>
--    .             -->    .                o F unmodified <b,a>
-- a: DYADC CMPf r 0       |                o m <> NOT
------------------------------------------------------------------------
%+D Visible
Routine mDYADC; import ref(Qfrm2) a;
begin ref(Qpkt) b,n,p; range(0:19) y; range(0:nregs) r; range(0:8) m;
      boolean fdies;
%-E   short integer ci,c1;
%+E   integer ci,c1;
%+D   RST(R_mDYADC);
---   if a.kind=K_Qfrm2b then goto E1 endif;
      y:=a.subc; r:=a.reg; ci:=a.aux.val; n:=none; p:=none; m:=0;
      fdies:=RegDies(a,uF);
      if (ci=0) and fdies
      then case 0:19 (y)
           when qAND: n:=InsertQf2(a,qLOADC,0,r,a.type,0)
           when qOR,qXOR,qINCO,qDECO,qADD,qSUB,qADDF,qSUBF: DeleteQinstr(a)
           endcase; goto M1
      elsif ci=1
      then case 0:19 (y) when qADD: m:=qINC; when qADDF: m:=qINCF;
                         when qSUB: m:=qDEC; when qSUBF: m:=qDECF;
           endcase
      elsif ci=-1
      then case 0:19 (y) when qADD: m:=qDEC; when qADDF: m:=qDECF;
                         when qSUB: m:=qINC; when qSUBF: m:=qINCF;
           endcase
      endif;
      if m<>0
      then n:=InsertQf2(a,qMONADR,m,r,a.type,0); DeleteQinstr(a);goto M2 endif
      b:=RegLastUsed(a,uMask(r)); if b=none then goto E2 endif;
      if b.fnc=qLOADC then if b.kind=K_qfrm2
      then if b.reg=r
           then c1:=b qua Qfrm2.aux.val;
                case 0:19 (y)
                when qAND: ci:=wAND(ci,c1); when qOR: ci:=wOR(ci,c1);
                when qXOR: ci:=wAND(wOR(ci,c1),-(wAND(ci,c1))-1);
                when qADD,qADDF: ci:=ci+c1; when qSUB,qSUBF: ci:=c1-ci;
                when qCMP: ci:=c1-ci;
                   -------------------------------------------------------
                   goto EEX; --- Midlertidig rettelse ---MY 15/12-86   ---
                   --- CMP kan ikke erstattes med en OR fordi OR       ---
                   --- aldri setter Carry-flaget, og vi kan ikke vite  ---
                   --- om det er en av relasjonene >, >=, <, <=        ---
                   -------------------------------------------------------
                   --- if fdies
                   --- then if RegDies(a,uMask(r)) then DeleteQinstr(b) endif;
                   ---      DeleteQinstr(a); goto E3
                   --- endif; if not RegDies(a,uMask(r)) then goto E4 endif
                   -------------------------------------------------------
                otherwise goto EEX1  --------------------------- MY 3/3-87
                endcase;
                n:=InsertQf2(a,qLOADC,0,r,a.type,ci);
                if not fdies then p:=InsertQf2(a,qDYADR,qORM,r,a.type,r) endif;
                DeleteQinstr(a); DeleteQinstr(b); goto M3
           endif;
      endif endif;
      if y=qCMP
      then if b.reg=r
           then if b.fnc=qLOAD
                then
%+E                  if b.subc<>0 then goto Ex1 endif; -- TEMP ????
%+E                  if b qua Qfrm4c.nrep<>0 then goto Ex2 endif;
                     if not RegDies(a,uMask(r)) then goto E4b endif
                     n:=RegsReadUnmodified(b,a);
                     if not RegUnused(n,a,uF) then goto E5 endif;
                     n:=InsertQf4(n,qDYADMC,y,r,a.type,ci,b qua Qfrm3.opr);
                     DeleteQinstr(a); DeleteQinstr(b); goto M4
                elsif ci=0
                then if RegLastWrite(a,uF) = b
                     then if (b.fnc=qDYADR) or (b.fnc=qDYADC) or (b.fnc=qDYADM)
                          then if b.subc<>qCMP then DeleteQinstr(a) endif
                          elsif b.fnc=qMONADR
                          then if b.subc<>qNOT then DeleteQinstr(a) endif endif;
                     endif
                endif
           endif
      endif;
      goto E6;
M1:M2:M3:M4:
      if n<>none then ReMasseur(n); if p<>none then ReMasseur(p) endif endif;
EEX: -------------------- Midlertidig rettelse ---MY 15/12-86       ---
EEX1: --------------------------------------------MY 3/3-87         ---
%+E Ex1:Ex2:
--- E1:
   E2:      E4b:E5:E6:end; -- mDYADC
%page
--    TRIADR:
-----------------------------------------------------------------------
-- b: load r data (nrep)  |               o r is rX, r<>aX
--    .                   .               o r oneshot (b,a)
--    .           -->     .               o b=MOV(k:=R),LOAD(k:=M)
--    .                   .               o R(b) unmodified <b,a>
-- a: TRIADR t r       a: TRIADk t data
-----------------------------------------------------------------------
-- b2:LOADC r c2          |               o if r<>AX: r oneshot(b2,a)
--    .                   .               o AX unused <b1,a>
-- b1:LOADC AX c1         |               o F dead in a
--    .           -->     .
-- a: TRIADR MUL r     a: LOADC c1*c2
-----------------------------------------------------------------------
-- b2:LOADC r c2          |               o if r<>AX: r oneshot(b2,a)
--    .                   .               o F dead in a
-- b1:LOADC AX c1         |               o DX unused <c,a>
-- c: DX:=0/CWD           |               o c.fnc in (CWD, LOADC DX 0)
--    .           -->     .               o c.fnc=LOADC: AX unused <b1,a>
-- a: TRIADR dm r      a: LOADC c1 dm c2  o c.fnc=CWD: AX unused <b1,c>,<c,a>
-----------------------------------------------------------------------
%+D Visible
Routine mTRIADR; import Ref(Qpkt) a;
begin ref(Qpkt) b,n,b1,b2,c,cc; range(0:nregs) r; range(0:15) t;
      range(0:qMXX) bfnc,nfnc; range(0:MaxWord) c1w,c2w;
%-E   short integer c1,c2;
%+E   integer c1,c2;
%+D   RST(R_mTRIADR);
      r:=a.reg; t:=a.subc; if r<>WholeReg(r) then goto E1 endif;
      if r=qAX then goto CCC1 endif;
      case 0:15 (t)
         when qWMUL,qWMULF,qIMUL,qIMULF: TryReverse(a,qAX,r,6)
      endcase;
      b:= RegOneshot(a,uMask(r)); if b=none then goto CCC2 endif;
      bfnc:=b.fnc;
      if bfnc=qMOV then nfnc:=qTRIADR
      elsif bfnc=qLOAD
      then nfnc:=qTRIADM
%+E        if b qua Qfrm4c.nrep<>0 then goto Ex1 endif;
      else goto CCC3 endif;
%+E   if b.subc<>0 then goto Ex2 endif; -- TEMP ????
      if RegsReadUnmodified(b,a) <> a then goto E2 endif;
      if nfnc=qTRIADR
      then n:= InsertQf2(a,qTRIADR,t,b qua Qfrm2.aux.val,a.type,0)
      else n:= InsertQf3(a,qTRIADM,t,r,a.type,b qua Qfrm3.opr) endif;
      DeleteQinstr(a); DeleteQinstr(b); ReMasseur(n); goto E3;
CCC1:CCC2:CCC3:
      if not RegDies(a,uF) then goto E4 endif; c:=none;
%-E   b1:=RegLastUsed(a,uAX); if b1=none then goto E5 endif;
%+E   b1:=RegLastUsed(a,uEAX); if b1=none then goto E5 endif;
      if b1.fnc=qCWD
      then cc:=b1;
%-E        b1:=RegLastUsed(cc,uAX);
%+E        b1:=RegLastUsed(cc,uEAX);
           if b1=none then goto E6 endif
      endif;
      if b1.fnc<>qLOADC then goto E7 endif;
      if b1.reg<>qAX then goto E8 endif;
      if b1.kind<>K_Qfrm2 then goto E9 endif; c1:=b1 qua Qfrm2.aux.val;
      if r=qAX then b2:=b1
      else b2:=RegOneshot(a,uMask(r)); if b2=none then goto E10 endif
      endif;
      if b2.fnc<>qLOADC then goto E11 endif;
      if b2.reg<>r then goto E12 endif;
      if b2.kind<>K_Qfrm2 then goto E13 endif;
      c2:=b2 qua Qfrm2.aux.val; r:=qAX;
      case 0:15 (t)
      when qIMUL,qIMULF: c1:=c1*c2
      when qWMUL,qWMULF: c1w:=c1; c2w:=c2; c1w:=c1w*c2w; c1:=c1w
      otherwise -- some DIV or MOD:
%-E      c:=RegLastUsed(a,uDX); if c=none then goto E14 endif;
%+E      c:=RegLastUsed(a,uEDX); if c=none then goto E14 endif;
         if c.fnc=qCWD
         then if c<>cc then goto E15 endif;
              if (t=qIDIV) or (t=qIDIVF) then c1:=c1/c2
              elsif (t=qIMOD) or (t=qIMODF) then c1:=c1 rem c2; r:=qDX
              else goto E16 endif
         elsif (c.fnc=qLOADC) and (c.kind=K_Qfrm2)
         then if (c.reg=qDX) and (c qua Qfrm2.aux.val=0)
              then c1w:=c1; c2w:=c2;
                   if (t=qWDIV) or (t=qWDIVF) then c1w:=c1w/c2w
                   elsif (t=qWMOD) or (t=qWMODF)
                   then c1w:=c1w rem c2w; r:=qDX
                   else goto E17 endif; c1:=c1w
              else goto E19 endif
         else goto E18 endif;
      endcase;
      n:=Insertqf2(a,qLOADC,0,r,a.type,c1);
      if b2<>b1 then DeleteQinstr(b2) endif; DeleteQinstr(b1);
      if c<>none then DeleteQinstr(c) endif; DeleteQinstr(a); ReMasseur(n)
%+E Ex1:Ex2:
E1:E2:E3:E4:E5:E6:E7:E8:E9:E10:E11:E12:E13:E14:E15:E16:E17:E18:E19:
end; -- mTRIADR
%page
--    TRIADM:
-----------------------------------------------------------------------
-- a1:LOADC AX 1            |
-- a: TRIADM MUL opr  -->   LOAD AX,opr
-----------------------------------------------------------------------
--    LOADC AX c            LOADC AX c        o R(opr) unmodified <b,a>
-- b: TRIADM MUL opr        TRIADM MUL opr    o M(OPR) unmodified <b,a>
--   (MOV ir AX)           (MOV ir AX)        o stack(b)=stack(a)
--    .                     PUSHR ir/AX
--    .               -->   .
--    .                     .
--    LOADC AX c            POPR AX
-- a: TRIADM MUL opr        |
-----------------------------------------------------------------------
--    LOADC AX c            LOADC AX c        o R(opr) unmodified <b,a>
-- b: TRIADM MUL opr        TRIADM MUL opr    o M(OPR) unmodified <b,a>
--   (MOV ir AX)           (MOV ir AX)        o ir unmodified <b+1,n>
--    .                     .                 o AX unused <n,a-1>
--    .               --> n:MOV AX ir/AX
--    .                     .
--    LOADC AX c            |
-- a: TRIADM MUL opr        |
-----------------------------------------------------------------------
%+D Visible
Routine mTRIADM; import ref(Qpkt) a;
begin ref(Qpkt) a1,b,b1,n,m; range(0:15) subc;
      infix(MemAddr) opr; range(0:nregs)r;
%+D   range(0:MaxWord) nPrev; nPrev:=0;
%+D   RST(R_mTRIADM);
      subc:=a.subc; n:=none;
      case 0:15 (subc) when qWMUL,qWMULF,qIMUL,qIMULF:;
      otherwise goto E1 endcase;
      a1:=a.pred; if a1=none then goto E7 endif;
      if a1.fnc<>qLOADC then goto E2 endif;
      if a1.reg<>qAX then goto E3 endif;
      if a1.kind<>K_Qfrm2 then goto E4 endif;
      opr:=a qua Qfrm3.opr;
      if a1 qua Qfrm2.aux.val=1
      then n:=InsertQf4c(a1,qLOAD,0,qAX,a.type,0,opr,0); goto D4 endif;
      b:=a1;
      repeat b:=b.pred while b <> none
      do case 0:qMXX (b.fnc)
         when qFDEST,qBDEST,qLABEL,qENTER,qJMP,qJMPM,
%-E           qJMPFM,
              qRET,qIRET,qLEAVE: goto E8;
         endcase;
%+D      nPrev:=nPrev+1;
         if b.fnc<>qTRIADM then goto R1 endif;
         if b.subc<>subc then goto R2 endif;
         if OprNE(opr,b qua Qfrm3.opr) then goto R3 endif;
         b1:=b.pred; if b1=none then goto E5 endif;
         if b1.fnc<>qLOADC then goto R4 endif;
         if b1.reg<>qAX then goto R5 endif;
         if b1.kind<>K_Qfrm2 then goto R6 endif;
         if b1 qua Qfrm2.aux <> a1 qua Qfrm2.aux then goto R7 endif;
         if SameMemWritten(b,a) then goto R8 endif;
         n:=b.next; r:=qAX;
%-E      if MaaaRegUnWritten(n,a1,qAX) then n:=none; goto D1 endif;
%+E      if MaaaRegUnWritten(n,a1,qEAX) then n:=none; goto D1 endif;
         if n.fnc=qMOV
         then
%+E           if b.subc<>0 then goto Ex1 endif; -- TEMP ????
              if n qua Qfrm2.aux.val=qAX then r:=n.reg; n:=n.next endif;
         endif;
         if StackEqual(n,a1)
         then n:=InsertQf1(n,qPUSHR,r,a.type);
              n:=InsertQf1(a1,qPOPR,qAX,a.type); goto D2
         endif;
         if r<>qAX
         then
%-E           m:=RegLastUsed(a1,uAX); m:=m.next;
%+E           m:=RegLastUsed(a1,uEAX); m:=m.next;
              if MaaaRegUnWritten(n,m,r)
              then n:=InsertQf2(m,qMOV,0,qAX,a.type,r); goto D3 endif
         endif;
   R1:R2:R3:R4:R5:R6:R7:R8:endrepeat; goto E6;
D1:D2:D3:D4:DeleteQinstr(a); DeleteQinstr(a1);
      if n<>none then ReMasseur(n) endif
%+E Ex1:
E1:E2:E3:E4:E5:E6:E7:E8:
%+D   if (TLIST>4) and (nPrev > 50)
%+D   then Ed(errmsg,"mTRIADM:nPrev=");
%+D        EdWrd(errmsg,nPrev); WARNING("  ");
%+D   endif;
end; -- mTRIADM
%page
--    FPOP:
------------------------------------------------------------------------
-- b: FPUSH fSD fmf        |                   o stack(b)=stack(a)
--    .                    .                   o stack ulest indirekte <b,a>
--    .                    .                   o a.fmf=b.fmf
-- a: FPOP fSD fmf         |                   o a.fSD=b.fSD
--    .                    .                   o No Call in <b,a>
------------------------------------------------------------------------
-- b: FLD fSD fmf opr      |                   o stack87(b)=stack87(c)
--    .                    .                   o R(opr) uendret <b,a>
--    .                    .                   o M uendret <b,a>
-- c: FPUSH fSD fmf        |                   o stack(c)=stack(a)
--    .                    .                   o stack ulest indirekte <c,a>
--    .                    .                   o
-- a: FPOP fSD fmf    -->  FLD a.fSD b.fmf opr o
------------------------------------------------------------------------
-- b: FLDC fSD fmf val     |                   o stack87(b)=stack87(c)
--    .                    .                   o
--    .                    .                   o
-- c: FPUSH fSD fmf        |                   o stack(c)=stack(a)
--    .                    .                   o stack ulest indirekte <c,a>
--    .                    .                   o
-- a: FPOP fSD fmf    -->  FLDC a.fSD b.fmf val o
------------------------------------------------------------------------
-- b: PUSHM size opr       |                   o stack(b)=stack(a)
--    .                    .                   o stack ulest indirekte <b,a>
--    .                    .                   o size=size(fmf)
--    .                    .                   o R(opr) uendret <b,a>
-- a: FPOP fSD fmf    -->  FLD fSD fmf opr     o M uendret <b,a>
------------------------------------------------------------------------
-- b: PUSHC r const        |                   o stack(b)=stack(a)
--    .                    .                   o stack ulest indirekte <b,a>
--    .            -->     .                   o r d|r i b
--    .                    .                   o size=size(fmf)
-- a: FPOP fSD fmf    -->  FLDC fSD fmf val    o
------------------------------------------------------------------------

------------------------------------------------------------------------
-- b: PUSHR r2             |               o stack(b)=stack(a)           ?????
--    .                    .               o stack ulest indirekte <b,a> ?????
--    .            -->  n: MOV r1,r2       o r2 uendret <b,n>            ?????
--    .                    .               o r1 ubrukt <n,a>             ?????
-- a: FPOP fSD fmf         |               o                             ?????
------------------------------------------------------------------------

%+D Visible
Routine mFPOP; import ref(Qpkt) a;
begin ref(Qpkt) b(4),n; range(0:MaxByte) fnc,fmf,fSD;
      short integer k; range(0:MaxWord) i,j,s,nb; range(0:7) cn;
      infix(MemAddr) opr,tmp; infix(ValueItem) cnst;
%+D   RST(R_mPOPR);
      b:=FindPush2(a); if b=none then goto E1 endif;
      fnc:=b.fnc; n:=none; b(1):=none; b(2):=none; b(3):=none;
      fSD:=a.subc; fmf:=a.reg;
      if fnc=qFPUSH
      then if (b.reg<>fmf)
%-E        or (not SameNPXStack(b,a))
%+E        or (b.subc<>fSD)
           then b(1):=b; k:=0;
                repeat b:=b.pred while b <> none
                do case 0:qMXX (b.fnc)
                   when qFDEST,qBDEST,qLABEL,qENTER,qJMP,qJMPM,
%-E                     qJMPFM,
                        qRET,qIRET,qLEAVE: goto E2;
                   when qFPOP,qFDUP,qFLD,qFLDC,qFLDCK:
                                         if k=0 then goto D1 endif; k:=k-1
                   when qFPUSH,qFSTP: k:=k+1
                   when qFMONAD,qFDYADM: if k=0 then goto T1 endif
                   when qFDYAD:          if k=0 then goto T2 endif; k:=k+1
                   when qFST:            if k=0 then goto T3 endif;
                   endcase
                endrepeat; T1:T2:T3: goto E3;
D1:             if b.fnc = qFLD
                then n:=RegsReadUnmodified(b,a); if n <> a then goto E4 endif;
                     n:=InsertQf3(a,qFLD,fSD,b.reg,a.type,b qua Qfrm3.opr)
%+E             elsif b.fnc = qFLDC
%+E             then n:=InsertQf3b(a,qFLDC,fSD,b.reg,a.type,b qua Qfrm3.val)
                elsif b.fnc=qFLDCK then n:=InsertQf1(a,qFLDCK,b.subc,a.type)
                elsif b.fnc=qFPOP  then n:=InsertQf1b(a,qFPOP,fSD,b.reg,a.type)
                elsif b.fnc=qFDUP  then n:=InsertQf1(a,qFDUP,fSD,a.type)
                else goto E5 endif;
           elsif CallSeen then goto E6 endif;
      elsif fnc=qPUSHM
      then s:=FmfSize(fmf); j:=0;
           opr:=b qua Qfrm3.opr; tmp:=opr;
           repeat i:=j; nb:=b(i) qua Qfrm4.aux.val;
           while nb < s
           do s:=s-nb; j:=i+1;
              b(j):=b(i).pred; if b(j)=none then goto E7 endif;
              if b(j).fnc <> qPUSHM then goto E8 endif;
              tmp.rela.val:=tmp.rela.val+nb;
              if OprNE(%b(j) qua Qfrm3.opr%,tmp)
              then
%+D                WARNING("MASS.mFPOP  -- PUSHM.1");
                   goto E9;
              endif;
           endrepeat;
           if nb <> s
           then
%+D             WARNING("MASS.mFPOP  -- PUSHM.2");
                goto E10;
           endif;
           n:=RegsReadUnmodified(b,a); if n <> a then goto E11 endif;
           n:=InsertQf3(a,qFLD,fSD,fmf,a.type,opr);
      elsif fnc=qPUSHC
      then
           case 0:6 (fmf)
           when FMF_LREAL: j:=0;
                repeat i:=j while i < ((8/AllignFac)-1)
                do j:=i+1; b(j):=b(i).pred;
                   if b(j)=none then goto E12 endif;
                   if b(j).fnc <> qPUSHC then goto E13 endif;
                endrepeat;
%-E             cnst.wrd(0):=b(0) qua Qfrm2.aux.val;
%-E             cnst.wrd(1):=b(1) qua Qfrm2.aux.val;
%-E             cnst.wrd(2):=b(2) qua Qfrm2.aux.val;
%-E             cnst.wrd(3):=b(3) qua Qfrm2.aux.val;
%+E             cnst.int(0):=b(0) qua Qfrm2.aux.val;
%+E             cnst.int(1):=b(1) qua Qfrm2.aux.val;
           when FMF_REAL:
%-E             b(1):=b(0).pred; if b(1)=none then goto Ex1 endif;
%-E             if b(1).fnc <> qPUSHC then goto Ex2 endif;
%-E             cnst.wrd(0):=b(0) qua Qfrm2.aux.val;
%-E             cnst.wrd(1):=b(1) qua Qfrm2.aux.val;
%+E             cnst.int:=b(0) qua Qfrm2.aux.val;
           otherwise
%+D                  IERR("MASS.mFPOP  -- PUSHC.1");
                     goto E14;
           endcase;
%+E        if NUMID=WTLx167 then cn:=0
%+E        else
                cn:=Const87(fmf,cnst);
%+E        endif
           if cn <> 0 then n:=InsertQf1(a,qFLDCK,cn,a.type);
%-E        elsif DSEGID=DGROUP then n:=InsertQf3b(a,qFLDC,qSS,fmf,a.type,cnst);
%-E        else tmp.kind:=segadr; tmp.sbireg:=0;
%-E             tmp.rela.val:=0; tmp.segmid:=DSEGID;
%-E             n:=InsertQf2b(a,qLOADSC,qES,qAX,cOBJ,0,tmp);
%-E             n:=InsertQf3b(a,qFLDC,qES,fmf,a.type,cnst);
%+E        else n:=InsertQf3b(a,qFLDC,fSD,fmf,a.type,cnst);
           endif;
--    elsif fnc=qPUSHR
--    then if r1=r2 then n:=none
--         else if RegSize(r1) <> RegSize(r2)
--              then
-- %+D               WARNING("Masseur.mPOPR.2");
--                   goto Exx;
--              endif;
--              n:=InsertQf2(n,qMOV,0,r1,c???,r2)
--         endif
      else goto E15 endif
      DeleteQinstr(b);
      if b(1) <> none then DeleteQinstr(b(1)) endif;
%-E   if b(2) <> none then DeleteQinstr(b(2)) endif;
%-E   if b(3) <> none then DeleteQinstr(b(3)) endif;
      DeleteQinstr(a); if n<>none then ReMasseur(n) endif;
%-E Ex1:Ex2:
E1:E2:E3:E4:E5:E6:E7:E8:E9:E10:E11:E12:E13:E14:E15:end; -- mFPOP
%page
--    FDYAD:
------------------------------------------------------------------------
-- b: FLD fSD fmf opr   |                 o b creates ST(0) or ST(1)
--    .                 .                 o R(opr) unmodified <b,a>
--    .            -->  .                 o M(opr) unmodified <b,a>
--    .                 .                 o b creates ST(0): subc'=subcR
-- a: FDYAD subc  FDYADM subc' fmf fSD opr o b creates ST(1): subc'=subc
------------------------------------------------------------------------
%+D Visible
Routine mFDYAD; import ref(Qpkt) a;
begin ref(Qpkt) b,n,t; short integer k;
      infix(MemAddr) opr; range(0:7) subc; boolean clean;
%+D   range(0:MaxWord) nPrev; nPrev:=0;
%+D   RST(R_mFDYAD);
      b:=a; k:=-1; subc:=a.subc; clean:=true;
      repeat b:=b.pred while b <> none
      do case 0:qMXX (b.fnc)
         when qFDEST,qBDEST,qLABEL,qENTER,qJMP,qJMPM,
%-E           qJMPFM,
              qRET,qIRET,qLEAVE,qEVAL:  goto E1
         when qFLDC: ConvertFLDCtoFLD(b); goto L;
         when qFLD: L: k:=k+1;
              if ((k=0) or (k=1)) and clean -- b creates ST(k)
              then if b.reg <> FMF_TEMP
                   then opr:= b qua Qfrm3.opr;
                        t:=InsertQf4c(a,qLOAD,0,0,cVAL,0,opr,0);
                        if SameMemWritten(b,t) then DeleteQinstr(t);
                        else goto DD endif;
                   endif;
              endif;
              clean:=true;
         when qFPOP,qFLDCK: k:=k+1; clean:=true
         when qFDUP:  k:=k+1; clean:=false
         when qFST,qFDYADM,qFMONAD: clean:=false
         when qFSTP,qFPUSH: k:=k-1
         when qFDYAD: k:=k-1; clean:=false
         endcase;
         if k > 0 then goto E2 endif;
%+D      nPrev:=nPrev+1;
      endrepeat; goto E3
DD:  
      DeleteQinstr(t);
      if k=0 then mFDYADrev(a);
-- ??? %+E   else b.subc:=b.subc+2   WEITEK !!! HOLDER IKKE !!!
      endif;
%+D   if listq1>1 then mPRINT2("FDYAD(1)",b,a) endif;
      n:=InsertQf4(a,qFDYADM,a.subc,b.reg,a.type,b.subc,opr);
      DeleteQinstr(a); DeleteQinstr(b); ReMasseur(n);
E1:E2:E3:
%+D   if (TLIST>4) and (nPrev > 50)
%+D   then Ed(errmsg,"mFDYAD:nPrev=");
%+D        EdWrd(errmsg,nPrev); WARNING("  ");
%+D   endif;
end; -- mFDYAD

%+D Visible
Routine mFDYADrev; import ref(Qpkt) a;
begin
%+D   RST(R_mFDYADrev);
      case 0:7 (a.subc)
      when qFCOM:  reversed:= not reversed
      when qFSUB:  a.subc:=qFSUBR
      when qFSUBR: a.subc:=qFSUB
      when qFDIV:  a.subc:=qFDIVR
      when qFDIVR: a.subc:=qFDIV
      endcase
end; -- mFDYADrev
%page
--    Condition:
-----------------------------------------------------------------------
-- d: LOAD  AL opr             LOAD AL opr      o sc in (EQ,NE)
-- c: LOADC AH 0               |                o 0<=k<=255
-- b: DYADC CMPf AX k  -->  n: DYADC CMPf AL k  o ccc in (JMP,CONDEC)
--a1: (LOADC AL 0)             (LOADC AL 0)     o ccc=CONDEC: a1 present
-- a: ccc sc                   ccc sc           o AH dies in a
-----------------------------------------------------------------------
%+D Visible
Routine mCondition; import ref(Qpkt) a;
begin ref(Qpkt) b,c,d,n; range(0:15) sc,cmp; range(0:MaxWord) k;
%+D   RST(R_mCondition);
      if not RegDies(a,uAH) then goto E16 endif;
      sc:=a.subc;
      case 0:15 (sc) when q_WEQ,q_WNE,q_IEQ,q_INE:;
      otherwise goto E1 endcase;
      b:=a.pred; if b=none then goto E2 endif;
      if a.fnc=qCONDEC
      then if b.fnc<>qLOADC then goto E17 endif;
           if b.kind<>K_Qfrm2 then goto E18 endif;
           if b.reg<>qAL then goto E19 endif;
           if b qua Qfrm2.aux.val<>0 then goto E20 endif;
           b:=b.pred; if b=none then goto E21 endif
      endif;
      if b.fnc<>qDYADC then goto E3 endif;
      if b.kind<>K_Qfrm2 then goto E4 endif;
      cmp:=b.subc; if cmp<>qCMP then goto E5 endif;
      if b.reg<>qAX then goto E6 endif;
      k:=b qua Qfrm2.aux.val;
      if k>255 then goto E70 elsif k<0 then goto E71 endif;
      c:=b.pred; if c=none then goto E8 endif;
      if c.fnc<>qLOADC then goto E9 endif;
      if c.kind<>K_Qfrm2 then goto E10 endif;
      if c.reg<>qAH then goto E11 endif;
      if c qua Qfrm2.aux.val<>0 then goto E12 endif;
      d:=c.pred; if d=none then goto E13 endif;
      if d.fnc<>qLOAD then goto E14 endif;
%+E   if d.subc<>0 then goto Ex1 endif; -- TEMP ????
      if d.reg<>qAL then goto E15 endif;
      n:=InsertQf2(b,qDYADC,cmp,qAL,b.type,k);
      DeleteQinstr(b); DeleteQinstr(c); ReMasseur(n);
%+E Ex1:
E1:E2:E3:E4:E5:E6:E70:E71:E8:E9:E10:E11:E12:
E13:E14:E15:E16:E17:E18:E19:E20:E21:
      if a.fnc=qJMP then mJMP(a) endif
end; -- mCondition
%page
--    JMP:
------------------------------------------------------------------------
--a2: LOADC r const           |             . F,r dies in a
--a1: DYADR ORM r r     -->   |             . const=0: cond in eq
-- a: JMP cond dest           JMP 0 dest    . const<>0: cond in neq
------------------------------------------------------------------------
--a2: LOADC r const           |             . F,r dies in a
--a1: DYADR ORM r r     -->   |             . const=0: cond in neq
-- a: JMP cond dest           |             . const<>0: cond in eq
------------------------------------------------------------------------
----------------------------------------------------------pj------------
--    |              /-->  c1:BDEST a
--    <codeb>        !        <codeb>           o <codeb>=<codea>
-- b: BDEST a      --/        |                 o no LABEL in <code>
--    .                       .
--    <codea>                 |
-- a: JMP 0 b              a: JMP 0 b
------------------------------------------------------------------------
%+D Visible
Routine mJMP; import ref(Qpkt) a;
begin ref(Qfrm2) a1,a2,aa,b,bb,b1; range(0:nregs) r; boolean del;
%+D   RST(R_mJMP);
   -- moved pj: if not RegDies(a,uF) then goto E1 endif;
   a1:=a.pred; if a1=none then goto E2 endif;
   if a1.fnc<>qDYADR then goto E3 endif;
   if a1.subc<>qORM then goto E4 endif;
   r:=a1.reg; if a1.aux.val<>r then goto E5 endif;
   a2:=a1.pred; if a2=none then goto E6 endif;
   if a2.fnc<>qLOADC then goto E7 endif;
   if a2.kind<>K_Qfrm2 then goto E8 endif;
   if a2.reg<>r then goto E9 endif;
   if not RegDies(a,uF) then goto E1 endif;
   if    a.subc=q_WEQ then del:=(a2.aux.val<>0)
   elsif a.subc=q_IEQ then del:=(a2.aux.val<>0)
   elsif a.subc=q_WNE then del:=(a2.aux.val=0)
   elsif a.subc=q_INE then del:=(a2.aux.val=0)
   else goto E10 endif;
   if del then DeleteQPosibJ(a)
   else a.subc:=0; ModifyQinstr(a);
      if a=qlast then DeadCode:=true
%+C   else IERR("MASS.mJMP.notlast")
      endif
   endif
   DeleteQinstr(a1); DeleteQinstr(a2); goto E11;
E1:   E3:E4:E5:E6:E7:E8:E9:E10:
   ----- pj 6/4 92 -------------------------
   b:=a qua Qfrm5.dst;
   if b<>none then if b.fnc=qBDEST then if b.next<>none
   then bb:=b.pred; aa:=a.pred; a1:=none;
        repeat
           if DEBMOD < 3
           then repeat while bb<>none
                do if bb.fnc=qLINE then bb:=bb.pred else goto X1 endif
                endrepeat;
           X1:  repeat while aa.fnc=qLINE do aa:=aa.pred endrepeat;
           endif;
        while bb<>none
        do if QinstrEqual(aa,bb)
           then a1:=aa; aa:=aa.pred; b1:=bb; bb:=bb.pred
           else goto X2 endif
        endrepeat;
   X2:  if a1<>none
        then a2:=b.next; moveQinstr(b,b1);
             repeat b1:=a1.next; deleteQposibJ(a1); a1:=b1;
             while a1<>a do endrepeat;
             remasseur(a2);
        endif
   endif endif endif
E2:E11: end; -- mJMP
%page
--    FDEST:
------------------------------------------------------------------------
-- b: JMP cond a              |
-- c: JMP 0 x           -->   JMP notcond x
-- a: FDEST b                 |
------------------------------------------------------------------------
-- c: <ev set flags>          |
-- b: JMP cond a              |
--    <DEST/LABEL>*     -->   <DEST/LABEL>*
-- a: FDEST b                 |
------------------------------------------------------------------------
--    <codeb>                 |                 o <codeb>=<codec>
-- b: JMP 0 a              b: JMP 0 c1          o no LABEL in <code>
--    .                       .
--    |              /-->  c1:FDEST b
--    <codec>        !        <codec>
-- c: JMP 0 a1       !     c: JMP 0 a1
--    .              !        .
-- a1:FDEST c        !     a1:FDEST c
--    <DEST/LABEL>*  !        <DEST/LABEL>*
-- a: FDEST b      --/        |
------------------------------------------------------------------------
%+D Visible
Routine mFDEST; import ref(Qfrm6) a;
begin ref(Qpkt) b,c,d,cc,bb,b1,c1,bb1,cc1;
      range(0:qMXX) df; short integer maxnc,nc;
%+D   RST(R_mFDEST);
      b:=a.jmp; if b=none then goto E1 endif;
      if b.next=none then goto E6 endif; -- Jmp is exhausted
      if b.subc<>0
      then c:=a.pred;
           if DEBMOD < 3
           then repeat while c.fnc=qLINE do c:=c.pred endrepeat endif;
           if c.fnc=qJMP
           then if c.subc=0
                then d:=c.pred;
                     if DEBMOD < 3
                     then repeat while d.fnc=qLINE do d:=d.pred endrepeat endif;
                     if d=b
                     then c.subc:=NotQcond(b.subc); ModifyQinstr(c);
                          DeleteQPosibJ(b); goto E4
                     endif;
                endif;
           endif;
      endif;
      d:=a;
      repeat d:=d.pred while d<>b
      do df:=d.fnc;
         if    df=qLINE  then if DEBMOD>2 then goto DB1 endif
         elsif df=qFDEST then --
         elsif df=qLABEL then --
         elsif df<>qBDEST then goto DB2 endif
      endrepeat;
      -- while (d<>b) and
      --       ((df=qFDEST) or (df=qBDEST) or (df=qLABEL)
      --       or ((DEBMOD<3) and (df=qLINE)) )
      -- do endrepeat;
      -- if d=b then
      if b.subc<>0
      then c:=b.pred;
           if c<>none
           then if wAND(c.write,uF) <> 0
                then if regsWrittenDies(b,qF)
                     then DeleteQinstr(c) endif
                endif;
           endif;
      endif;
      DeleteQPosibJ(b); goto E2
      -- endif;
DB1:DB2: if b.subc<>0 then goto E5 endif;
      maxnc:=0; cc:=d;
      repeat
             if cc<>none
             then bb:=b.pred; nc:=0;
                  repeat
                     if DEBMOD > 2
                     then if cc=none then goto ER2xx endif;
                          if bb=none then goto ER3xx endif;
                     else repeat if cc=none then goto ER2 endif;
                          while cc.fnc=qLINE do cc:=cc.pred endrepeat;
                          repeat if bb=none then goto ER3 endif;
                          while bb.fnc=qLINE do bb:=bb.pred endrepeat;
                     endif
                  while bb.fnc<>qLABEL
                  do if (QinstrEqual(bb,cc))
                     then nc:=nc+1; cc1:=cc; bb1:=bb;
                          bb:=bb.pred; cc:=cc.pred
                     else goto ER1 endif
                  endrepeat; ER1: ER2: ER3: ER2xx: ER3xx:
                  if nc>maxnc then maxnc:=nc; c1:=cc1; b1:=bb1 endif
             endif;
             d:=d.next
      while d<>a
      do cc:=none;
         if d.fnc=qFDEST
         then c:=d qua Qfrm6.jmp;
              if c<>none then if c.subc=0 then cc:=c.pred endif endif
         endif
      endrepeat;
      if maxnc>0
      then cc:=a;
           repeat cc:=cc.pred; if cc=b then goto E3 endif;
           while cc<>c1 do endrepeat;
           moveQinstr(a,c1);
           repeat bb:=b1.next; DeleteQPosibJ(b1); b1:=bb
           while bb<>b do endrepeat
      endif
E1:E2:E3:E4:E5:E6:end; -- mFDEST

%page
Routine moveQinstr; import ref(Qpkt) f,n;
begin ref(Qpkt) pr,nx;
%+D   RST(R_moveFdest);
%+D   if listq1 > 1 then ListQinstr("Moving:   ",f,false) endif;
      pr:=f.pred; nx:=f.next;
      if pr=none then qfirst:=nx; nx.pred:=none
      elsif nx=none then qlast:=pr; pr.next:=none
      else pr.next:=nx; nx.pred:=pr
      endif;
      pr:=n.pred; if pr=none then qfirst:=f else pr.next:=f endif;
      f.pred:=pr; n.pred:=f; f.next:=n
%+D   if listq1 > 2 then ListQinstr("Moved Q:  ",f,true) endif;
end; -- moveQinstr

%+D Routine ListQinstr;
%+D import infix(string) ms; ref(Qpkt) qi; Boolean ListI;
%+D begin infix(wWORD) rela; rela.val:=0;
%+D       setpos(sysout,6); edref(sysout,qi);
%+D       sysout.pos:=0; outstring(ms);
%+D       if qi = none then printout(sysout);
%+D       else
%+D            if QinstrIsDeleted(qi)
%+D            then sysout.pos:=18; outstring("#") else sysout.pos:=19 endif
%+AD           AsmListing(rela,qi,ListI);
%+D            if ListI
%+D            then setpos(sysout,10);
%+D                 EdRegMask(sysout,"Read",qi.read); outstring("  ");
%+D                 EdRegMask(sysout,"Write",qi.write); outstring("  ");
%+D                 if not InMassage
%+D                 then EdRegMask(sysout,"Mind",MindMask) endif;
%+D                 printout(sysout);
%+D            endif;
%+D       endif;
%+D end;

end
