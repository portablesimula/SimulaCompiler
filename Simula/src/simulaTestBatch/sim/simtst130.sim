% ===============================================   Main   program =============
%  PROGRAM NAME:   SIMULA TEST NO 130
%
%  PURPOSE: Test Class DEC_Lib, a set of utility procedures from DEC Handbook.
%
%  WRITTEN BY:  MYH 
% ==============================================================================
external class SimulaTest;

SimulaTest(130,"--- Test Class DEC_Lib, a set of utility procedures from DEC Handbook.") begin

DEC_Lib begin
    boolean b,doAbort;
    integer i,j,p;
    real r;
    long real lr;
    character c;
    text m,o,n;
    text fileName,defaultextension;
    text t,t1,t2,t3,t4,t5;
    ref(File) f;
    ref(Printfile) pf;
    
    procedure trace(mess); text mess; if verbose then begin
        outtext(mess); outimage;
    end;    
    
    procedure testAbort; begin ------------------------------------------------------------------------------ abort
        abort("Program will terminate");
    end;
    
    procedure testChange; begin ------------------------------------------------------------------------------ change
        boolean procedure change1(master,oldtext,newtext); name master; text master,oldtext,newtext; begin
            text local; integer p;
            trace("TEST change1(" & master & "," & oldtext  & "," & newtext & ")    master.pos=" & edit(master.pos) );
            local:-master;
            p:=search(local,oldtext);
            trace("TEST change1: p=" & edit(p) & ", local.length=" & edit(local.length) );
            if p <= local.length then begin
                change1:=true;
                trace("TEST change1: oldtext.length=" & edit(oldtext.length) & ", newtext.length=" & edit(newtext.length) );
                if oldtext.length >= newtext.length then begin
                    local.sub(p,newtext.length):=newtext;
                    if oldtext.length>newtext.length then begin
                        from(local,p+newtext.length):=from(local,p+oldtext.length);
                        local:-local.sub(1,local.length-oldtext.length+newtext.length)
                    end
                end else local:-local.sub(1,p-1) & newtext & from(local,p+oldtext.length);
                local.setpos(p+newtext.length);
                master:-local
            end else master.setpos(0)
        end;

        procedure test(master,oldt,newt,expectedSuccess,expectedValue,expectedPosAfter);
        text master,oldt,newt; boolean expectedSuccess; text expectedValue; integer expectedPosAfter; begin
            boolean success,succes1; text mastr1; integer p;
            trace("Test  change(" & master & "," & oldt & "," & newt & ")  "
             & "   expectedSuccess=" & edit(expectedSuccess) & ", expectedValue=" & expectedValue & ", expectedPosAfter=" & edit(expectedPosAfter));
            p:=master.pos; mastr1:-copy(master); mastr1.setpos(p);
            success:=change(master,oldt,newt);
            succes1:=change1(mastr1,oldt,newt);
            if success ne expectedSuccess then err("Test  testChange FAILED: expectedSuccess=" & edit(expectedSuccess));
            if succes1 ne expectedSuccess then err("Test testChange1 FAILED: expectedSuccess=" & edit(expectedSuccess));
            if master ne expectedValue then err("Test  testChange FAILED: master=" & master);
            if mastr1 ne expectedValue then err("Test testChange1 FAILED: mastr1=" & mastr1);
            if master.pos ne expectedPosAfter then err("Test  testChange FAILED: master.pos=" & edit(master.pos));
            if mastr1.pos ne expectedPosAfter then err("Test  testChange FAILED: mastr1.pos=" & edit(mastr1.pos));
        end;
        
        trace("BEGIN TEST change --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("abracadabra"); test(t1,"dab","DAB",true,"abracaDABra",10);
            t1:-copy("abracadabra"); test(t1,"dab","DA",true,"abracaDAra",9);
            t1:-copy("abracadabra"); test(t1,"dab","DABER",true,"abracaDABERra",12);
            t1:-copy("abracadabra"); test(t1,"DAS","DO",false,"abracadabra",12);
        
            t1:-copy("...AA...AA...CCCCAA"); t1.setpos(11); test(t1,"AA","CC",true,"...AA...AA...CCCCCC",20);
            t1:-copy("...AA...AA...CCCCAA"); t1.setpos(11); test(t1,"AA","DDD",true,"...AA...AA...CCCCDDD",21);
            t1:-copy("...AA...AA...CCCCAA"); t1.setpos(11); test(t1,"AA","F",true,"...AA...AA...CCCCF",19);
        
            t1:-copy("...AA...AA...CCCCAA"); t1.setpos(7); test(t1,"AA","CC",true,"...AA...CC...CCCCAA",11);
            t1:-copy("...AA...AA...CCCCAA"); t1.setpos(7); test(t1,"AA","DDD",true,"...AA...DDD...CCCCAA",12);
            t1:-copy("...AA...AA...CCCCAA"); t1.setpos(7); test(t1,"AA","F",true,"...AA...F...CCCCAA",10);
        trace("ENDOF TEST change --------------------------------------------------- nFailed=" & edit(nFailed));
    end;
 
     
    procedure testChangeAll; begin ------------------------------------------------------------------------------ change (all)
        -- Changing all occurrences of oldtext to newtext may be done with the following procedure;
     
        procedure changeAll(master,oldtext,newtext); name master; text master,oldtext,newtext; begin
            text local; local:- master;
            while local.more do change(local,oldtext,newtext);
            master:- local
        end;
        
        procedure test(master,oldt,newt,expectedValue,expectedPosAfter);
        text master,oldt,newt; text expectedValue; integer expectedPosAfter; begin
            text prevMaster; integer p;
            prevMaster:-copy(master); p:=master.pos;
            trace("Test  changeAll(" & master & "," & oldt & "," & newt & ")  "
                & "   expectedValue=" & expectedValue & ", expectedPosAfter=" & edit(expectedPosAfter));
            changeAll(master,oldt,newt);
            if master ne expectedValue then err("Test  testChangeAll FAILED: master=" & master);
            if master.pos ne expectedPosAfter then err("Test  testChangeAll FAILED: master.pos=" & edit(master.pos));
            master.setpos(p); changeAll(master,newt,oldt);
            if master ne prevMaster then err("Test  testChangeAll FAILED: master=" & master & ", prevMaster=" & prevMaster);
        end;

        trace("BEGIN TEST change --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("abracadabra"); test(t1,"bra","BRA","aBRAcadaBRA",12);
            t1:-copy("abracadabra"); test(t1,"a","BRA","abrBRAcBRAdBRAbrBRA",20);
        trace("BEGIN TEST change --------------------------------------------------- nFailed=" & edit(nFailed));

    end;
    
       
    procedure testCheckextension; begin ------------------------------------------------------------------------------ checkextension
        procedure test(t,defaultextension,expectedValue); text t,defaultextension,expectedValue; begin
            text res; res:-checkextension(t,defaultextension);
            trace("Test  checkextension(" & t & "," & defaultextension & ") ==> '" & res & "'   expectedValue=" & expectedValue);
            if res ne expectedValue then err("Test  checkextension FAILED: result=" & res);
        end;

        trace("BEGIN TEST checkextension --------------------------------------------------- nFailed=" & edit(nFailed));
            test("FileName",".txt","FileName.txt");
            test("FileName.data",".txt","FileName.data");
        trace("ENDOF TEST checkextension --------------------------------------------------- nFailed=" & edit(nFailed));
        
    end;

    procedure testCheckfrac; begin ------------------------------------------------------------------------------ checkfrac

        procedure test(t,expectedValue,expectedPosAfter); text t; integer expectedValue,expectedPosAfter; begin
            integer res; res:-checkfrac(t);
            trace("Test  checkfrac(" & t & ") ==> '" & edit(res) & "'   expectedValue=" & edit(expectedValue) & ", expectedPosAfter=" & edit(expectedPosAfter));
            if res ne expectedValue then err("Test  checkfrac FAILED: result=" & edit(res));
            if t.pos ne expectedPosAfter then err("Test  checkfrac FAILED: t.pos=" & edit(t.pos));
        end;
        
        trace("BEGIN TEST checkfrac --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("fff12 378 ITEM2"); test(t1,-1,1);
            t1:-copy("fff123 78 ITEM2"); t1.setpos(4); test(t1,+1,10);
            t1:-copy("fff12 37 8 ITEM2"); t1:-t1.sub(4,11); test(t1,+1,8);
            t1:-copy("12378 9999 999999 999 99999 999999 999999 99999 99999 999999 999999999"); test(t1,-1,1);
        trace("ENDOF TEST checkfrac --------------------------------------------------- nFailed=" & edit(nFailed));

    end;

    procedure testCheckint; begin ------------------------------------------------------------------------------ checkint
        procedure test(t,expectedValue,expectedPosAfter); text t; integer expectedValue,expectedPosAfter; begin
            integer res;
            res:-checkint(t);
            trace("Test  checkint(" & t & ") ==> '" & edit(res) & "'   expectedValue=" & edit(expectedValue) & ", expectedPosAfter=" & edit(expectedPosAfter));
            if res ne expectedValue then err("Test  checkint FAILED: result=" & edit(res));
            if t.pos ne expectedPosAfter then err("Test  checkint FAILED: t.pos=" & edit(t.pos));
        end;
        
        trace("BEGIN TEST checkint --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("fff12378 ITEM2"); test(t1,-1,1);
            t1:-copy("fff12378 ITEM2"); t1.setpos(4); test(t1,+1,9);
            t1:-copy("fff12378 ITEM2"); t1:-t1.sub(4,9); test(t1,+1,6);
            t1:-copy("123789999999999999999999999999999999999999999999999999999999"); test(t1,-1,1);
        trace("ENDOF TEST checkint --------------------------------------------------- nFailed=" & edit(nFailed));

    end;    
    
    procedure testCheckreal; begin ------------------------------------------------------------------------------ checkreal
        procedure test(t,expectedValue,expectedPosAfter); text t; integer expectedValue,expectedPosAfter; begin
            integer res;
            res:-checkreal(t);
            trace("Test  checkreal(" & t & ") ==> '" & edit(res) & "'   expectedValue=" & edit(expectedValue) & ", expectedPosAfter=" & edit(expectedPosAfter));
            if res ne expectedValue then err("Test  checkreal FAILED: result=" & edit(res));
            if t.pos ne expectedPosAfter then err("Test  checkreal FAILED: t.pos=" & edit(t.pos));
        end;
    
        trace("BEGIN TEST checkreal --------------------------------------------------- nFailed=" & edit(nFailed));
            --t1:-copy("fff123.78 ITEM2"); test(t1,-1,1);
            --t1:-copy("fff12.378 ITEM2"); t1.setpos(4); test(t1,+1,10);
            --t1:-copy("fff1.2378 ITEM2"); t1:-t1.sub(4,9); test(t1,+1,7);
            t1:-copy("+1237.8999&+9999999999"); test(t1,+1,23);
        trace("ENDOF TEST checkreal --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testCompress; begin ------------------------------------------------------------------------------ compress
        text procedure compress1(tin, ch); text tin; character ch; begin
            integer pInp, tinLen, count, pout; character tmpCh;
            if tin == notext then compress1 :- notext
            else begin
                tinLen := tin.length;
                tin.setpos(1); pout:=1;
                for pInp := 1 step 1 until tinLen do begin
                    tin.setpos(pInp); tmpCh := tin.getchar;
                    if tmpCh ne ch then begin
                        depchar(tin,pout,tmpCh); pout:=pout+1;
                    end
                end;
                compress1 :- if pout = 0 then notext else tin.sub(1,pout-1);
            end elsBeg;
        end compress;

        procedure test(tin,ch,expectedValue,expectedMain); text tin,expectedValue,expectedMain; character ch; begin
            text tin1,tin2,res,rs1; tin1:-copy(tin); tin2:-copy(tin);
            res:-compress(tin1,ch);
            rs1:-compress1(tin2,ch);
            trace("Test  compress(" & tin & "," & edit(ch) & ") ==> '" & res & "'   expectedValue=" & expectedValue & ", expectedMain=" & expectedMain);
            trace("Test compress1(" & tin & "," & edit(ch) & ") ==> '" & rs1 & "'   expectedValue=" & expectedValue & ", expectedMain=" & expectedMain);
            if res ne expectedValue then err("Test  compress FAILED: result=" & res);
            if rs1 ne expectedValue then err("Test  compress1 FAILED: result=" & rs1);
            if res.main ne expectedMain then err("Test  compress FAILED: result.main=" & res.main);
            if rs1.main ne expectedMain then err("Test  compress1 FAILED: result.main=" & rs1.main);
        end;
    
        trace("BEGIN TEST compress --------------------------------------------------- nFailed=" & edit(nFailed));
        -- Example:  t1:-copy("AxBxCxDx");  t2:-compress(t1,'x');
        --     gives t1="ABCDCxDx", t2==t1.sub(1,4), t2="ABCD".
        t1:-copy("AxBxCxDx"); test(t1,'x',"ABCD","ABCDCxDx");
        t1:-copy("AxBxCxDx"); test(t1,'y',"AxBxCxDx","AxBxCxDx");
        trace("ENDOF TEST compress --------------------------------------------------- nFailed=" & edit(nFailed));

    end;

    procedure testConcatenations; begin ------------------------------------------------------------------------------ conc
        procedure testConc(t1,t2,expectedValue); text t1,t2; text expectedValue; begin
            text res; res:-conc(t1,t2);
            trace("Test  conc(" & t1 & "," & t2 & ") ==> '" & res & "'   expectedValue=" & expectedValue);
            if res ne expectedValue then err("Test  testConc FAILED: result=" & res);
        end;
        
        procedure testConc2(t1,t2,expectedValue); text t1,t2; text expectedValue; begin
            text res; res:-conc2(t1,t2);
            trace("Test  conc2(" & t1 & "," & t2 & ") ==> '" & res & "'   expectedValue=" & expectedValue);
            if res ne expectedValue then err("Test  testConc2 FAILED: result=" & res);
        end;
        
        procedure testConc3(t1,t2,t3,expectedValue); text t1,t2,t3; text expectedValue; begin
            text res; res:-conc3(t1,t2,t3);
            trace("Test  conc3(" & t1 & "," & t2 & "," & t3 & ") ==> '" & res & "'   expectedValue=" & expectedValue);
            if res ne expectedValue then err("Test  testConc3 FAILED: result=" & res);
        end;
        
        procedure testConc4(t1,t2,t3,t4,expectedValue); text t1,t2,t3,t4; text expectedValue; begin
            text res; res:-conc4(t1,t2,t3,t4);
            trace("Test  conc4(" & t1 & "," & t2 & "," & t3 & "," & t4 & ") ==> '" & res & "'   expectedValue=" & expectedValue);
            if res ne expectedValue then err("Test  testConc4 FAILED: result=" & res);
        end;
        
        procedure testConc5(t1,t2,t3,t4,t5,expectedValue); text t1,t2,t3,t4,t5; text expectedValue; begin
            text res; res:-conc5(t1,t2,t3,t4,t5);
            trace("Test  conc5(" & t1 & "," & t2 & "," & t3 & "," & t4 & "," & t5 & ") ==> '" & res & "'   expectedValue=" & expectedValue);
            if res ne expectedValue then err("Test  testConc5 FAILED: result=" & res);
        end;
        
        trace("BEGIN TEST conc --------------------------------------------------- nFailed=" & edit(nFailed));
        testConc("abra","cadabra","abracadabra");
        testConc2("abra","cadabra","abracadabra");
        testConc3("abra","ca","dabra","abracadabra");
        testConc4("ab","ra","ca","dabra","abracadabra");
        testConc5("ab","ra","ca","da","bra","abracadabra");
        trace("ENDOF TEST conc --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testCptime; begin ------------------------------------------------------------------------------ cptime
        real procedure cptime1;
        begin cptime1:= cputime; end;
       
        trace("BEGIN TEST cptime --------------------------------------------------- nFailed=" & edit(nFailed));
        lr:=cptime1; trace("Test cptime1 ==> " & edfix(lr,4));
        lr:=cptime;  trace("Test  cptime ==> " & edfix(lr,4));
        trace("BEGIN TEST cptime --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testDayno; begin ------------------------------------------------------------------------------ dayno
        integer procedure dayno1; dayno1:=datetime.sub(9,2).getint;		

        trace("BEGIN TEST testDayno --------------------------------------------------- nFailed=" & edit(nFailed));
            i:-dayno1; trace("Test dayno1 ==> '" & edit(i) & "'   pos=" & edit(t1.pos));
            j:-dayno;  trace("Test  dayno ==> '" & edit(j) & "'   pos=" & edit(t1.pos));
            if i ne j then err("Test  dayno FAILED");
        trace("ENDOF TEST testDayno --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testToday; begin ------------------------------------------------------------------------------ today
        text procedure today1; today1:-datetime.sub(1,10);
        
        trace("BEGIN TEST today --------------------------------------------------- nFailed=" & edit(nFailed));
            trace("Test  today ==> " & today);
            trace("Test today1 ==> " & today1);
            if today ne today1 then err("Test  today FAILED");
        trace("ENDOF TEST today --------------------------------------------------- nFailed=" & edit(nFailed));

	end;

    procedure testDaytime; begin ------------------------------------------------------------------------------ daytime
        text procedure daytime1; daytime1:-datetime.sub(12,8);

        trace("BEGIN TEST testDaytime --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-daytime1; trace("Test daytime1 ==> '" & t1 & "'   pos=" & edit(t1.pos));
            t2:-daytime;  trace("Test  daytime ==> '" & t1 & "'   pos=" & edit(t1.pos));
            if t1 ne t2 then err("Test  daytime FAILED");
        trace("ENDOF TEST testDaytime --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testDepchar; begin ------------------------------------------------------------------------------ depchar
        procedure depchar1(t,p,c); text t; integer p; character c;
        if p>0 and p<=t.length then t.sub(p,1).putchar(c);

        procedure test(t,p,c,expectedValue); text t,expectedValue; integer p; character c; begin
            depchar(t,p,c);
            trace("Test  depchar(" & t & "," & edit(p) & "," & edit(c) & "), ==> '" & t & "'   expectedValue=" & expectedValue);
            if t ne expectedValue then err("Test  depchar FAILED: result=" & t);
        
            depchar1(t,p,c);
            trace("Test  depchar1(" & t & "," & edit(p) & "," & edit(c) & "), ==> '" & t & "'   expectedValue=" & expectedValue);
            if t ne expectedValue then err("Test  depchar1 FAILED: result=" & t);
		end;
		    
        trace("BEGIN TEST testDepchar --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("Abracadab"); test(t1,4,'X',"AbrXcadab");
            t1:-copy("Abracadab"); test(t1,-4,'X',"Abracadab");
            t1:-copy("Abracadab"); test(t1,9,'X',"AbracadaX");
            t1:-copy("Abracadab"); test(t1,10,'X',"Abracadab");
            t1:-copy("Abracadab"); test(t1,11,'X',"Abracadab");
        trace("ENDOF TEST testDepchar --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testEnterdebug; begin ------------------------------------------------------------------------------ enterdebug
        enterdebug(true);
    end;

    procedure testExit; begin ------------------------------------------------------------------------------ exit
        procedure exit1(n); integer n;
        begin
            if n=0 then !... stop execution;
            if n=1 then terminate_program;
            if n=2 then enterdebug(true)
            else begin
                outtext("Parameter to exit out of range (0,2)"); outimage;
                terminate_program;
            end;
        end;
         
        exit(4);
    end;

    procedure testFetchar; begin ------------------------------------------------------------------------------ fetchar
        character procedure fetchar1(t,p); text t; integer p;
        if p>0 and p<=t.length then fetchar1:= t.sub(p,1).getchar;
        
        procedure test(t,p,expectedValue); text t; integer p; character expectedValue; begin
            character res,rs1;
            res:=fetchar(t,p);
            rs1:=fetchar1(t,p);
            trace("Test  fetchar(" & t & "," & edit(p) & ") ==> '" & edit(res) & "'   expectedValue=" & edit(expectedValue));
            trace("Test fetchar1(" & t & "," & edit(p) & ") ==> '" & edit(rs1) & "'   expectedValue=" & edit(expectedValue));
            if res ne expectedValue then err("Test  fetchar FAILED: result=" & edit(res));
            if rs1 ne expectedValue then err("Test  fetchar1 FAILED: result=" & edit(rs1));
        end;
        
        trace("BEGIN TEST fetchar --------------------------------------------------- nFailed=" & edit(nFailed));
        test("master",3,'s');
        t1:-copy("fff12.378 ITEM2"); t1.setpos(4); test(t1,8,'7');
        t1:-copy("fff1.2378 ITEM2"); t1:-t1.sub(4,11);  test(t1,9,'T');
        trace("BEGIN TEST fetchar --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testFindtrigger; begin ------------------------------------------------------------------------------ findtrigger
        character procedure findtrigger1(master,triggers); name master; text master,triggers; begin
            character c;
            text t; t:- master;
            while t.more do begin
                c:= t.getchar;
                triggers.setpos(1);
                if scanto(triggers,c) =/= triggers then begin
                    comment C found in triggers;
                    findtrigger1:= c;
                    goto out;
               end
            end loop;
            out:  master.setpos(t.pos);
        end;

        procedure test(master,triggers,expectedValue,expectedPosAfter); text master,triggers; character expectedValue; integer expectedPosAfter; begin
            character res,rs1; text mastr2; integer pos;
            pos:=master.pos; mastr2:-copy(master); mastr2.setpos(pos);
            res:-findtrigger(master,triggers);
            rs1:-findtrigger1(mastr2,triggers);
            trace("Test  findtrigger(" & master & "," & triggers & ") ==> '" & edit(res) & "'   expectedValue=" & edit(expectedValue) & ", expectedPosAfter=" & edit(expectedPosAfter));
            trace("Test findtrigger1(" & mastr2 & "," & triggers & ") ==> '" & edit(rs1) & "'   expectedValue=" & edit(expectedValue) & ", expectedPosAfter=" & edit(expectedPosAfter));
            if res ne expectedValue then err("Test  findtrigger FAILED: result=" & edit(res));
            if rs1 ne expectedValue then err("Test  findtrigger1 FAILED: result=" & edit(rs1));
            if master.pos ne expectedPosAfter then err("Test  findtrigger FAILED: master.pos=" & edit(master.pos));
            if mastr2.pos ne expectedPosAfter then err("Test  findtrigger1 FAILED: mastr2.pos=" & edit(mastr2.pos));
        end;
    
        trace("BEGIN TEST findtrigger --------------------------------------------------- nFailed=" & edit(nFailed));
        test("master","es",'s',4);
        t1:-copy("fff12.378 ITEM2"); t1.setpos(4); test(t1,"TM",'T',13);
        t1:-copy("fff1.2378 ITEM2"); t1:-t1.sub(4,11);  test(t1,"TM",'T',10);
        trace("ENDOF TEST findtrigger --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testFrom; begin ------------------------------------------------------------------------------ from
        text procedure from1(t,p); text t; integer p;
        if p<=t.length then from1 :- if p<=0 then t else t.sub(p,t.length-p+1);
                  
        procedure test(t,p,expectedValue); text t,expectedValue; integer p; begin
            text res,rs1;
            res:-from(t,p); rs1:-from(t,p);
            trace("Test  from(" & t & "," & edit(p) & ") ==> '" & res & "'   expectedValue=" & expectedValue);
            trace("Test from1(" & t & "," & edit(p) & ") ==> '" & rs1 & "'   expectedValue=" & expectedValue);
            if res ne rs1 then err("Test  from FAILED");
            if res ne expectedValue then err("Test  from FAILED: result=" & res);
        end;
                  
        trace("BEGIN TEST from --------------------------------------------------- nFailed=" & edit(nFailed));
        test("master File",8,"File");
        test("master File",-8,"master File");
        test("master File",18,notext);
        trace("ENDOF TEST from --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testFront; begin ------------------------------------------------------------------------------ front
        text procedure front1(t); text t;
        if t=/=notext then front1:-t.sub(1,t.pos-1);
        
        procedure test(t,expectedValue); text t,expectedValue; begin
            text res,rs1;
            res:-front(t);
            rs1:-front1(t);
            trace("Test  front(" & t & "), t.pos=" & edit(t.pos) & " ==> '" & res & "'   expectedValue=" & expectedValue);
            trace("Test front1(" & t & "), t.pos=" & edit(t.pos) & " ==> '" & rs1 & "'   expectedValue=" & expectedValue);
            if res ne expectedValue then err("Test  front FAILED: result=" & res);
            if rs1 ne expectedValue then err("Test  front1 FAILED: result=" & rs1);
            trace("front & from ==> '" & res & from(t,t.pos) & "'");
            if (res & from(t,t.pos)) ne t then err("Test  front1 FAILED: res & from(t,t.pos)='" & res & from(t,t.pos) & "'");
        end;
        
        trace("BEGIN TEST front --------------------------------------------------- nFailed=" & edit(nFailed));
        t1:-"Abracadabra"; t1.setpos(6); test(t1,"Abrac");
        t1:-copy("fff12.378 ITEM2"); t1.setpos(4); test(t1,"fff");
        t1:-copy("fff1.2378 ITEM2"); t1:-t1.sub(4,11); t1.setpos(8);  test(t1,"1.2378 ");
        trace("BEGIN TEST front --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testFrontcompare; begin ------------------------------------------------------------------------------ frontcompare
        boolean procedure frontcompare1(string,config); text string,config;
        if string.length - string.pos+1 >= config.length then
        frontcompare1:= string.sub(string.pos,config.length) = config;
        
        procedure test(t1,t2,expectedValue); text t1,t2; boolean expectedValue; begin
            boolean res,rs1;
            res:-frontcompare(t1,t2);
            rs1:-frontcompare1(t1,t2);
            trace("Test  frontcompare(" & t1 & "," & t2 & "), t1.pos=" & edit(t1.pos) & " ==> '" & edit(res) & "'   expectedValue=" & edit(expectedValue));
            trace("Test frontcompare1(" & t1 & "," & t2 & "), t1.pos=" & edit(t1.pos) & " ==> '" & edit(rs1) & "'   expectedValue=" & edit(expectedValue));
            if res ne expectedValue then err("Test  frontcompare FAILED: result=" & edit(res));
            if rs1 ne expectedValue then err("Test  frontcompare1 FAILED: result=" & edit(rs1));
        end;

        trace("BEGIN TEST frontcompare --------------------------------------------------- nFailed=" & edit(nFailed));
        t1:-"Abracadabra"; t1.setpos(1); test(t1,"Abrac",true);
        t1:-"Abracadabra"; t1.setpos(6); test(t1,"Abrac",false);
        t1:-"Abracadabra"; t1.setpos(8); test(t1,"abra",true);
        t1:-copy("Abracadabra"); t1:-t1.sub(4,8); t1.setpos(4);  test(t1,"Abracabra",false);
        t1:-copy("Abracadabra"); t1:-t1.sub(4,8); t1.setpos(4);  test(t1,"dabra",true);
        trace("ENDOF TEST frontcompare --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testFrontstrip; begin ------------------------------------------------------------------------------ frontstrip
        text procedure frontstrip1(t); text t;
        if t=/=notext then begin
            t.setpos(1);
            while t.more do
            if t.getchar ne ' ' then begin
                frontstrip1 :- t.sub(t.pos-1,t.length-t.pos+2);
                t.setpos(t.length);
                goto exit;
            end;
        exit:end;

        procedure test(t,expectedValue); text t,expectedValue; begin
            text res,rs1;
            res:-frontstrip(t);
            rs1:-frontstrip1(t);
            trace("Test  frontstrip(" & t & "), t.pos=" & edit(t.pos) & " ==> '" & res & "'   expectedValue=" & expectedValue);
            trace("Test frontstrip1(" & t & "), t.pos=" & edit(t.pos) & " ==> '" & rs1 & "'   expectedValue=" & expectedValue);
            if res ne expectedValue then err("Test  frontstrip FAILED: result=" & res);
            if rs1 ne expectedValue then err("Test  frontstrip1 FAILED: result=" & rs1);
        end;
        
        trace("BEGIN TEST frontstrip --------------------------------------------------- nFailed=" & edit(nFailed));
        t1:-"     Abracadabra"; t1.setpos(1); test(t1,"Abracadabra");
        t1:-"Abraca      Abracadabra"; t1:-t1.sub(7,17); test(t1,"Abracadabra");
        trace("ENDOF TEST frontstrip --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testGetitem; begin ------------------------------------------------------------------------------ getitem
        text procedure getitem1(tt); name tt; text tt;
        if tt =/= notext then begin
           character window; integer startpos; text t;
     
           character procedure getCharacter;
           if t.more then
           getCharacter:= window:= t.getchar else goto out;
           
           boolean procedure idchar(c); character c;
           idchar:= letter(c) or digit(c);
     
           t:- tt; t.setpos(tt.pos);
           startpos:= t.length+1;
           getCharacter;
           while window = ' ' or window = char(9) do getCharacter;
           startpos:= t.pos-1;
           if not letter(window) then begin
               if digit(window) then while digit(getCharacter) do;
               if window = '.'  then while digit(getCharacter) do;
           end else while idchar(getCharacter) do;
           if t.pos > startpos + 1 then t.setpos(t.pos-1);
      out: getitem1 :- t.sub(startpos,t.pos-startpos);
           tt.setpos(t.pos)
        end;

        procedure test(tt,expectedValue,expectedPosAfter); name tt; text tt,expectedValue; integer expectedPosAfter; begin
            text res,rs1,t2; integer pos;
            pos:=tt.pos; t2:-copy(tt); t2.setpos(pos);
            res:-getitem(tt);
            rs1:-getitem1(t2);
            trace("Test  getitem(" & tt & "), tt.pos=" & edit(tt.pos) & " ==> '" & res & "'   expectedValue=" & expectedValue & ", expectedPosAfter=" & edit(expectedPosAfter));
            trace("Test getitem1(" & t2 & "), t2.pos=" & edit(t2.pos) & " ==> '" & rs1 & "'   expectedValue=" & expectedValue & ", expectedPosAfter=" & edit(expectedPosAfter));
            if res ne expectedValue then err("Test  getitem FAILED: result=" & res);
            if rs1 ne expectedValue then err("Test  getitem1 FAILED: result=" & rs1);
            if tt.pos ne expectedPosAfter then err("Test  getitem FAILED: tt.pos=" & edit(tt.pos));
            if t2.pos ne expectedPosAfter then err("Test  getitem1 FAILED: t2.pos=" & edit(t2.pos));
        end;

        trace("BEGIN TEST getitem --------------------------------------------------- nFailed=" & edit(nFailed));
            --  Example: "if car.wheel_size > 13.5" will be split into the items
            --           "if", "car", ".", "wheel", "_", "size", ">", "13.5"
            --           via successive calls to GETITEM.
            t1 :- copy("XXXIF car.wheel_size > 13.5"); t1:-t1.sub(4,t1.length-3);
            test(t1,"IF",3);  test(t1,"car",7);    test(t1,".",8);   test(t1,"wheel",13);
            test(t1,"_",14);  test(t1,"size",18);  test(t1,">",20);  test(t1,"13.5",25);
        trace("ENDOF TEST getitem --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testHash; begin ------------------------------------------------------------------------------ hash
        integer procedure hash1(t,n); text t; integer n; begin
            text tstrip; integer a;
            tstrip:- frontstrip(t.strip);
            if tstrip == notext then hash1:= mod(t.length,n) else begin
                a:= rank(tstrip.getchar);
                if tstrip.length > 3 then begin
                    a:= a +   8*rank(tstrip.getchar);
                    a:= a +  64*rank(tstrip.getchar)
                end;
                tstrip.setpos(tstrip.length);
                a:= a + 512*rank(tstrip.getchar) + t.length;
                hash1:= mod(a,n);
            end
        end of hash;

        procedure test(t,n,expectedValue); text t; integer n,expectedValue; begin
            integer res,rs1;
            res:-hash(t,n);
            rs1:-hash1(t,n);
            trace("Test  hash(" & t & "," & edit(n) & "), t.pos=" & edit(t.pos) & " ==> '" & edit(res) & "'   expectedValue=" & edit(expectedValue));
            trace("Test hash1(" & t & "," & edit(n) & "), t.pos=" & edit(t.pos) & " ==> '" & edit(rs1) & "'   expectedValue=" & edit(expectedValue));
            if res ne expectedValue then err("Test  hash FAILED: result=" & edit(res));
            if rs1 ne expectedValue then err("Test  hash1 FAILED: result=" & edit(rs1));
        end;
        
        trace("BEGIN TEST hash --------------------------------------------------- nFailed=" & edit(nFailed));
            test("Abracadabra",17,3);
            test("Abracadabra",37,26);
             t1:-"Abraca      Abracadabra"; t1:-t1.sub(7,17); test(t1,133,104);
        trace("ENDOF TEST hash --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testInitem; begin ------------------------------------------------------------------------------ initem
        text procedure initem1(fileref); ref(File) fileref; begin
            text res; short integer i;
            inspect fileref
              when Infile do
                   if not lastitem then res:-getitem(image)
              when Directfile do
                   if not lastitem then res:-getitem(image)
              when Inbytefile do begin
                   res:-blanks(1); i:=rank('!9!');
                   while i=rank(' ') or i=rank('!9!') !TAB; do i:=inbyte;
                   res.sub(1,1).putchar(char(i));
              end
              when Directbytefile do begin
                   res:-blanks(1); i:=rank('!9!');
                   while i=rank(' ') or i=rank('!9!') !TAB; do i:=inbyte;
                   res.sub(1,1).putchar(char(i));
              end;
              initem1:-res;
        end;
        
        integer nTests=10;
        
        procedure createImagefile(fil); ref(Outfile) fil; begin
            fil.setaccess("anycreate"); fil.open(blanks(20));
            for i:=1 step 1 until nTests do fil.outtext("   item" & edit(i) & "   ");
            fil.outimage; fil.close;
        end;  
        
        procedure testImagefile(fileName); text fileName;  begin
            ref(Infile) fil;
            fil:-new Infile(fileName); doTestImagefile(fil,initem1(fil));
            fil:-new Infile(fileName); doTestImagefile(fil,initem(fil));
        end;
        
        procedure doTestImagefile(fil,nextitem); name nextitem; text nextitem; ref(Infile) fil;  begin
            fil.open(blanks(20)); i:=0;
            while not fil.lastitem do begin
                text item; item:-nextitem; i:=i+1;
                trace("GOT: '" & item & "'");
                if item ne ("item" & edit(i)) then err("TestInitem - Imagefile FAILED for Item " & edit(i) & " = '" & item & "'");
            end;
            fil.close;
        end;      
         
        procedure createDirectfile(fil); ref(Directfile) fil; begin
            fil.setaccess("anycreate"); fil.open(blanks(20));
            for i:=1 step 1 until nTests do fil.outtext("   item" & edit(i) & "   ");
            fil.outimage; fil.close;
        end;  

        procedure testDirectfile(fileName); text fileName;  begin
            ref(Directfile) fil;
            fil:-new Directfile(fileName); doTestDirectfile(fil,initem1(fil));
            fil:-new Directfile(fileName); doTestDirectfile(fil,initem(fil));
        end;
        
        procedure doTestDirectfile(fil,nextitem); name nextitem; text nextitem; ref(Directfile) fil; begin
            fil.open(blanks(20)); i:=0;
            fil.locate(1); fil.inimage;
            while not fil.lastitem do begin
                text item;
                item:-nextitem; i:=i+1;
                trace("GOT: '" & item & "'");
                if item ne ("item" & edit(i)) then err("TestInitem - Directfile FAILED for Item " & edit(i) & " = '" & item & "'");
            end;
            fil.close;
        end;      
         
        procedure createBytefile(fil); ref(Outbytefile) fil; begin
            fil.setaccess("anycreate"); fil.open;
            for i:=1 step 1 until nTests do fil.outtext("   " & edit(char(rank('A')+i)) & "   ");
            fil.close;
        end;  

        procedure testBytefile(fileName); text fileName;  begin
            ref(Inbytefile) fil;
            fil:-new Inbytefile(fileName); doTestBytefile(fil,initem1(fil));
            fil:-new Inbytefile(fileName); doTestBytefile(fil,initem(fil));
        end;
        
        procedure doTestBytefile(fil,nextitem); name nextitem; text nextitem; ref(Inbytefile) fil; begin
            fil.open;
            for i:=1 step 1 until nTests do begin
                text item; item:-nextitem;
                trace("GOT: '" & item & "'   Endfile=" & edit(endfile));
                if item ne edit(char(rank('A')+i)) then err("TestInitem - Bytefile FAILED for Item " & edit(i) & " = '" & item & "'");
            end;
            fil.close;
        end;      
         
        procedure createDirectBytefile(fil); ref(Directbytefile) fil; begin
            fil.setaccess("anycreate"); fil.open;
            for i:=1 step 1 until nTests do fil.outtext("   " & edit(char(rank('A')+i)) & "   ");
            fil.close;
        end;  

        procedure testDirectBytefile(fileName); text fileName;  begin
            ref(Directbytefile) fil;
            fil:-new Directbytefile(fileName); doTestDirectBytefile(fil,initem1(fil));
            fil:-new Directbytefile(fileName); doTestDirectBytefile(fil,initem(fil));
        end;
        
        procedure doTestDirectBytefile(fil,nextitem); name nextitem; text nextitem; ref(Directbytefile) fil; begin
            fil.open;
            for i:=1 step 1 until nTests do begin
                text item; item:-nextitem;
                trace("GOT: '" & item & "'   Endfile=" & edit(endfile));
                if item ne edit(char(rank('A')+i)) then err("TestInitem - Directbytefile FAILED for Item " & edit(i) & " = '" & item & "'");
            end;
            fil.close;
        end;      

        trace("BEGIN TEST initem --------------------------------------------------- nFailed=" & edit(nFailed));
            createImagefile(new Outfile("simtst130-TEMP1"));             testImagefile("simtst130-TEMP1");
            createDirectfile(new Directfile("simtst130-TEMP2"));         testDirectfile("simtst130-TEMP2");
            createBytefile(new Outbytefile("simtst130-TEMP3"));          testBytefile("simtst130-TEMP3");
            createDirectBytefile(new Directbytefile("simtst130-TEMP4")); testDirectBytefile("simtst130-TEMP4");
        trace("ENDOF TEST initem --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testInsinglechar; begin ------------------------------------------------------------------------------ insinglechar
        character procedure prompt(mss,echo); text mss; boolean echo; begin
            character c;
            outimage; outtext(mss); breakoutimage;
            c:=insinglechar;
            if echo then begin outchar(c); breakoutimage; end;
            prompt:=c;
        end;
        
        while true do
        if prompt("Continue ? ",true)='q' then abort(" Abort");
        
        
    end;

    procedure testLinecount; begin ------------------------------------------------------------------------------ linecount
	    integer procedure linecount1(pfil); ref(Printfile) pfil; begin
            if pfil==none then linecount1:=-1
            else if not pfil.isopen then linecount1:=-2
            else begin
                --  return current linesperpage setting
                integer count; count:=pfil.linesperpage(0); linesperpage(count);
                linecount1:=count;
            end;
        end;

        procedure test(pf,expectedValue); ref(Printfile) pf; integer expectedValue; begin
            integer c1,c2;
            c1:=linecount(pf); c2:=linecount1(pf);
            trace("Test  linecount ==> '" & edit(c1) & "'   expectedValue=" & edit(expectedValue));
            trace("Test linecount1 ==> '" & edit(c2) & "'   expectedValue=" & edit(expectedValue));
            if c1 ne expectedValue then err("Test  linecount FAILED: result=" & edit(c1));
            if c2 ne expectedValue then err("Test  linecount1 FAILED: result=" & edit(c2));
            if c1 ne c2 then err("Test  linecount FAILED");
        end;

        trace("BEGIN TEST linecount --------------------------------------------------- nFailed=" & edit(nFailed));
            test(pf, -1);
            pf:-new Printfile("simtst130-TEMP");
            test(pf, -2);
            pf.open(blanks(80));
            test(pf,pf.linesperpage(0));
        trace("ENDOF TEST linecount --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testLowc; begin ------------------------------------------------------------------------------ lowc
         character procedure lowc1(c); character c;
         lowc1:= if not letter(c) then c else
                if c < 'a' then
                char(rank(c)-rank('A')+rank('a')) else c;

        procedure test(c); character c; begin
            character c1,c2;
            c1:-lowc(c); c2:-lowc1(c);
            trace("Test  lowc(" & edit(c) & ") " & " ==> '" & edit(c1) & "'");
            trace("Test lowc1(" & edit(c) & ") " & " ==> '" & edit(c2) & "'");
            if c1 ne c2 then err("Test  lowc FAILED");
        end;

        trace("BEGIN TEST lowc --------------------------------------------------- nFailed=" & edit(nFailed));
            for i:=0 step 1 until 127 do test(char(i));
        trace("ENDOF TEST lowc --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testMaketext; begin ------------------------------------------------------------------------------ maketext
        text procedure maketext1(ch,n); character ch; integer n;
        if n > 0 then begin
            text t; t:-blanks(n);
            while t.more do t.putchar(ch);
            t.setpos(1); maketext1 :- t;
        end;

        procedure test(c,n); character c; integer n; begin
            text c1,c2;
            c1:-maketext(c,n); c2:-maketext1(c,n);
            trace("Test  maketext(" & edit(c) & ",n=" & edit(n) & ") " & " ==> '" & c1 & "'");
            trace("Test maketext1(" & edit(c) & ",n=" & edit(n) & ") " & " ==> '" & c2 & "'");
            if c1 ne c2 then err("Test  maketext FAILED");
        end;

        trace("BEGIN TEST maketext --------------------------------------------------- nFailed=" & edit(nFailed));
            test('-',80);
        trace("ENDOF TEST maketext --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testPuttext; begin ------------------------------------------------------------------------------ puttext
        boolean procedure puttext1(oldstring,newstring); name oldstring; text oldstring,newstring; begin
            text s; s:-oldstring;
            if s.pos+newstring.length-1 <= s.length and then not s.constant then begin
                puttext1 := true;
                s.sub(s.pos,newstring.length):=newstring;
                s.setpos(s.pos+newstring.length)
                oldstring.setpos(s.pos)
            end;
        end;
    
        procedure test(oldt,newt,expectedValue,expectedPosAfter); text oldt,newt; boolean expectedValue; integer expectedPosAfter; begin
            boolean res,rs1; text old2,oldtx,old2x; integer pos;
            pos:=oldt.pos; old2:-copy(oldt); old2.setpos(pos);
            oldtx:-copy(oldt); old2x:-copy(old2);
            res:-puttext(oldt,newt);
            rs1:-puttext1(old2,newt);
            trace("Test  puttext(" & oldtx & "," & newt & ") ==> '" & oldt & "':" & edit(res) & "   expectedValue=" & edit(expectedValue) & ", expectedPosAfter=" & edit(expectedPosAfter));
            trace("Test puttext1(" & old2x & "," & newt & ") ==> '" & old2 & "':" & edit(rs1) & "   expectedValue=" & edit(expectedValue) & ", expectedPosAfter=" & edit(expectedPosAfter));
            if res ne expectedValue then err("Test  puttext FAILED: result=" & edit(res));
            if rs1 ne expectedValue then err("Test  puttext1 FAILED: result=" & edit(rs1));
            if oldt.pos ne expectedPosAfter then err("Test  puttext FAILED: oldt.pos=" & edit(oldt.pos));
            if old2.pos ne expectedPosAfter then err("Test  puttext1 FAILED: old2.pos=" & edit(old2.pos));
        end;
        
        trace("BEGIN TEST puttext --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("fff12 378 ITEM2"); test(t1,"newt",true,5);
            t1:-copy("fff123 78 ITEM2"); t1.setpos(4); test(t1,"newt",true,8);
            t1:-copy("fff12 37 8 ITEM2"); t1:-t1.sub(4,11); test(t1,"newt",true,5);
 
            t1:-copy("fff12 378 ITEM2"); test(t1,"newtxxxxxxxxxxxxxxxx",false,1);
            t1:-copy("fff123 78 ITEM2"); t1.setpos(4); test(t1,"newtzzzzzzzzz",false,4);
            t1:-copy("fff12 37 8 ITEM2"); t1:-t1.sub(4,11); test(t1,"newtyyyyyyyy",false,1);
        trace("ENDOF TEST puttext --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testRest; begin ------------------------------------------------------------------------------ rest
        text procedure rest1(t); text t; begin
            trace("rest1(" & t & ") t.pos=" & edit(pos));
            rest1:- t.sub(t.pos,t.length+1-t.pos);
        end;

        procedure test(t); text t; begin
            text t1,t2,x;
            integer pos; pos:=t.pos;
            x:-copy(t); x.setpos(pos);
            t1:-rest(t); t2:-rest1(x);
            trace("Test  rest(" & t & ") t.pos=" & edit(pos) & " ==> '" & t1 & "'");
            trace("Test rest1(" & t & ") t.pos=" & edit(pos) & " ==> '" & t2 & "'");
            if t1 ne t2 then err("Test  rest FAILED");
        end;
        
        trace("BEGIN TEST rest --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("Abracadabra"); t1.setpos(4); test(t1);
            t1:-t1.sub(2,t1.length-2); t1.setpos(5); test(t1);
        trace("ENDOF TEST rest --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testScanchar; begin ------------------------------------------------------------------------------ scanchar
        character procedure scanchar1(t); name t; text t;
        scanchar1 := if t.more then t.getchar else char(0);

        procedure test(t,expectedValue,expectedPosAfter); text t; character expectedValue; integer expectedPosAfter; begin
            character c1,c2; text x; integer pos;
            pos:=t.pos; x:-copy(t); x.setpos(pos);
            
            c1:-scanchar(t); c2:-scanchar1(x);
            trace("Test  scanchar(" & t & ") ==> '" & t & "':" & edit(c1) & "   expectedValue=" & edit(expectedValue) & ", expectedPosAfter=" & edit(expectedPosAfter));
            trace("Test scanchar1(" & x & ") ==> '" & x & "':" & edit(c2) & "   expectedValue=" & edit(expectedValue) & ", expectedPosAfter=" & edit(expectedPosAfter));
            if c1 ne expectedValue then err("Test  scanchar FAILED: result=" & edit(c1));
            if c2 ne expectedValue then err("Test  scanchar1 FAILED: result=" & edit(c2));
            if t.pos ne expectedPosAfter then err("Test  scanchar FAILED: t.pos=" & edit(t.pos));
            if x.pos ne expectedPosAfter then err("Test  scanchar1 FAILED: x.pos=" & edit(x.pos));
        end;

        trace("BEGIN TEST scanchar --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("Abracadabra"); t1.setpos(4); test(t1,'a',5);
            t1:-copy("Abracadabra"); t1.setpos(t1.length); test(t1,'a',12);
            t1:-copy("Abracadabra"); t1.setpos(t1.length+1); test(t1,'!0!',12);
        trace("ENDOF TEST scanchar --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testScanfrac; begin ------------------------------------------------------------------------------ scanfrac
        integer procedure scanfrac1(t); name t; text t; begin
            text s; s:-rest(t);
            if checkfrac(s)=1 then begin
                scanfrac1:=s.getfrac;
                t.setpos(t.pos+s.pos-1)
            end else scanfrac1:=minint
        end;

        procedure test(t,expectedPosAfter); text t; integer expectedPosAfter; begin
            integer i1,i2;
            text x; integer pos; pos:=t.pos;
            x:-copy(t); x.setpos(pos);
            i1:-scanfrac(t); i2:-scanfrac1(x);
            trace("Test  scanfrac(" & t & ") ==> '" & edit(i1) & "'");
            trace("Test scanfrac1(" & t & ") ==> '" & edit(i2) & "'");
            if i1 ne i2 then err("Test  scanfrac FAILED");
            if t.pos ne expectedPosAfter then err("Test  scanfrac FAILED: t.pos=" & edit(t.pos));
            if x.pos ne expectedPosAfter then err("Test  scanfrac1 FAILED: x.pos=" & edit(x.pos));
        end;

        trace("BEGIN TEST scanfrac --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("12 37 8"); t1.setpos(1); test(t1,8);
            t1:-copy("+12 37 8"); t1.setpos(1); test(t1,9);
            t1:-copy("-12 37 8"); t1.setpos(1); test(t1,9);
            t1:-copy("&12 37 8"); t1.setpos(1); test(t1,1);
            t1:-copy("&12 37 8"); t1.setpos(2); test(t1,9);
            t1:-copy("-21 474 836 50"); t1.setpos(1); test(t1,1);
            t1:-copy("+214 748 365 0"); t1.setpos(1); test(t1,1);
        trace("ENDOF TEST scanfrac --------------------------------------------------- nFailed=" & edit(nFailed));
    
    end;

    procedure testScanint; begin ------------------------------------------------------------------------------ scanint
        integer procedure scanint1(t); name t; text t; begin
            text s;  integer i;
            s:-rest(t);
            i:=checkint(s);
            if i=1 then begin
                scanint1:=s.getint;
                t.setpos(t.pos+s.pos-1)
            end else scanint1:=minint
        end;

        procedure test(t,expectedPosAfter); text t; integer expectedPosAfter; begin
            integer i1,i2;
            text x; integer pos; pos:=t.pos;
            x:-copy(t); x.setpos(pos);
            i1:-scanint(t); i2:-scanint1(x);
            trace("Test  scanint(" & t & ") ==> '" & edit(i1) & "'");
            trace("Test scanint1(" & t & ") ==> '" & edit(i2) & "'");
            if i1 ne i2 then err("Test  scanint FAILED");
            if t.pos ne expectedPosAfter then err("Test  scanint FAILED: t.pos=" & edit(t.pos));
            if x.pos ne expectedPosAfter then err("Test  scanint1 FAILED: x.pos=" & edit(x.pos));
        end;

        trace("BEGIN TEST scanint --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("12378"); t1.setpos(1); test(t1,6);
            t1:-copy("+12378"); t1.setpos(1); test(t1,7);
            t1:-copy("-12378"); t1.setpos(1); test(t1,7);
            t1:-copy("&12378"); t1.setpos(1); test(t1,1);
            t1:-copy("&12378"); t1.setpos(2); test(t1,7);
        trace("ENDOF TEST scanint --------------------------------------------------- nFailed=" & edit(nFailed));
        
    end;

    procedure testScanreal; begin ------------------------------------------------------------------------------ scanreal
        long real procedure scanreal1(t); name t; text t; begin
            text s; integer i;
            s:-rest(t);
            i:=checkreal(s);
            if i=1 then begin
                scanreal1:=s.getreal;
                trace("scanreal1(" & s & ")  PosAfter=" & edit(s.pos));
                t.setpos(t.pos+s.pos-1)
            end else scanreal1:=minreal;
        end;

        procedure test(t,expectedPosAfter); text t; integer expectedPosAfter; begin
            long real lr1,lr2;
            text x; integer pos; pos:=t.pos;
            x:-copy(t); x.setpos(pos);
            lr1:-scanreal(t); lr2:-scanreal1(x);
            trace("Test  scanreal(" & t & ") ==> '" & edit(lr1) & "'  ExpectedPosAfter=" & edit(expectedPosAfter));
            trace("Test scanreal1(" & t & ") ==> '" & edit(lr2) & "'  ExpectedPosAfter=" & edit(expectedPosAfter));
            if lr1 ne lr2 then err("Test  scanreal FAILED");
            if t.pos ne expectedPosAfter then err("Test  scanreal FAILED: t.pos=" & edit(t.pos));
            if x.pos ne expectedPosAfter then err("Test  scanreal1 FAILED: x.pos=" & edit(x.pos));
        end;
        
        trace("BEGIN TEST scanreal --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("123.78"); t1.setpos(1); test(t1,7);
            t1:-copy("+123.78"); t1.setpos(1); test(t1,8);
            t1:-copy("-123.78"); t1.setpos(1); test(t1,8);
            t1:-copy("&123.78"); t1.setpos(1); test(t1,1);
            t1:-copy("123.78 ITEM2"); t1.setpos(2); test(t1,7);
            t1:-copy("ITEM1 ITEM2"); t1.setpos(2); test(t1,2);
        trace("ENDOF TEST scanreal --------------------------------------------------- nFailed=" & edit(nFailed));

    end;

    procedure testScanto; begin ------------------------------------------------------------------------------ scanto
        text procedure scanto1(tt,c); name tt; text tt; character c; begin
            text t; integer p;
            t:- rest(tt); p:= tt.pos;
            trace("REST=" & t & ", p=" & edit(p));
            while t.more do if t.getchar = c then begin
                scanto1:- t.sub(1,t.pos-2);
                trace("GOT IT: " & t.sub(1,t.pos-2));
                tt.setpos(p+t.pos-2);
                goto out;
            end;
            scanto1:- from(t,p);
            trace("not FOUND: t.pos=" & edit(t.pos) & ", t.length=" & edit(t.length));
            tt.setpos(tt.length+1);
            out: --tt.setpos(t.pos);
        end of scanto;

        procedure test(t,c,expectedPosAfter); text t; character c; integer expectedPosAfter; begin
            text t1,t2,x; integer p; p:=t.pos; x:-copy(t); x.setpos(p);
            t1:-scanto(t,c); t2:-scanto1(x,c);
            trace("Test  scanto(" & t & "," & edit(c) & ") ==> '" & t1 & "'  pos=" & edit(t.pos) & ", ExpectedPosAfter=" & edit(expectedPosAfter));
            trace("Test scanto1(" & t & "," & edit(c) & ") ==> '" & t2 & "'  pos=" & edit(t.pos) & ", ExpectedPosAfter=" & edit(expectedPosAfter));
            if t1 ne t2 then err("Test  scanto FAILED");
            if t.pos ne expectedPosAfter then err("Test  scanto FAILED: t.pos=" & edit(t.pos));
            if x.pos ne expectedPosAfter then err("Test  scanto1 FAILED: x.pos=" & edit(x.pos));
        end;

        trace("BEGIN TEST scanto --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-copy("THIS IS UPTO AB TEST END"); t1:-t1.sub(6,19); t1.setpos(4); test(t1,'A',9);
            test("..........TEST END",';',19);
            test("begin ..... END;",';',16);
        trace("ENDOF TEST scanto --------------------------------------------------- nFailed=" & edit(nFailed));

    end;

    procedure testSearch; begin ------------------------------------------------------------------------------ search
        procedure test(t1,t2,n); text t1,t2; integer n; begin
            integer n2; n2:=search(t1,t2);
            trace("Test  search(" & t1 & "," & t2 & "," & edit(n) & ") ==> " & edit(n2));
            if n ne n2 then err("Test  search FAILED");
        end;
            
        trace("BEGIN TEST search --------------------------------------------------- nFailed=" & edit(nFailed));
            test("Abracadabra","cadab",5);
            test("Abracadabra","newYork",12);
            test(notext,"cadab",0);
            test("Abracadabra",notext,0);
        trace("ENDOF TEST search --------------------------------------------------- nFailed=" & edit(nFailed));
  
     end;

    procedure testSkip; begin ------------------------------------------------------------------------------ skip
        text procedure skip1(tt,c); name tt; text tt; character c; begin
            text t; t:- tt;
            while t.more do if t.getchar <> c then begin
                t.setpos(t.pos-1);
                skip1:- t.sub(t.pos,t.length-t.pos+1);
                goto out
            end;
            out: tt.setpos(t.pos)
        end of skip1;

        procedure test(t,c,expectedPosAfter); text t; character c; integer expectedPosAfter; begin
            text t1,t2,x; x:-copy(t); t1:-skip(t,c); t2:-skip1(x,c);
            trace("Test  skip(" & t & "," & edit(c) & ") ==> '" & t1 & "'   expectedPosAfter=" & edit(expectedPosAfter));
            trace("Test skip1(" & t & "," & edit(c) & ") ==> '" & t2 & "'   expectedPosAfter=" & edit(expectedPosAfter));
            if t1 ne t2 then err("Test  skip FAILED");
            if t.pos ne expectedPosAfter then err("Test  skip FAILED: t.pos=" & edit(t.pos));
            if x.pos ne expectedPosAfter then err("Test  skip1 FAILED: x.pos=" & edit(x.pos));
        end;
        
        trace("BEGIN TEST skip --------------------------------------------------- nFailed=" & edit(nFailed));
            test("..........TEST END",'.',11);
            test("..........TEST END",';',1);
        trace("ENDOF TEST skip --------------------------------------------------- nFailed=" & edit(nFailed));

     end;
    
    procedure testStartpos; begin ------------------------------------------------------------------------------ startpos
        integer procedure startpos1(t); text t;
        begin startpos1:=t.start; end;
   
        procedure test(t); text t; begin
            trace("Test  startpos ==> " & edit(startpos(t)));
            trace("Test startpos1 ==> " & edit(startpos1(t)));
            if startpos(t) ne startpos1(t) then err("Test  startpos FAILED");
        end;
        
        trace("BEGIN TEST startpos --------------------------------------------------- nFailed=" & edit(nFailed));
            t1:-blanks(100);
            test(t1);
            test(t1.sub(30,10));
        trace("ENDOF TEST startpos --------------------------------------------------- nFailed=" & edit(nFailed));

	end;

    procedure testTsub; begin ------------------------------------------------------------------------------ tsub
        text procedure tsub1(t,p,l); text t; integer p,l;
            if p >= 1 and l >= 0 and p+l <= t.length + 1 then
                tsub1:- t.sub(p,l);
    
        procedure test(t,p,l); text t; integer p,l; begin
            trace("Test  tsub(" & t & "," & edit(p) & "," & edit(l) & ") ==> " & tsub(t,p,l));
            trace("Test  tsub1(" & t & "," & edit(p) & "," & edit(l) & ") ==> " & tsub1(t,p,l));
            if tsub(t,p,l) ne tsub1(t,p,l) then err("Test  tsub(" & t & "," & edit(p) & "," & edit(l) & ") FAILED");
        end;
        
        trace("BEGIN TEST tsub --------------------------------------------------- nFailed=" & edit(nFailed));
            t:-copy("Dette er en tekst");
            test(t,7,6);
            test(t,-7,6);
            test(t,7,26);
            test(t,7,-6);
        trace("ENDOF TEST tsub --------------------------------------------------- nFailed=" & edit(nFailed));

	end;
	    
    procedure testUpc; begin ------------------------------------------------------------------------------ upc
        character procedure upc1(c); character c;
           upc1:= if not letter(c) then c else
                 if c > 'Z' then
                    char(rank(c)-rank('a')+rank('A')) else c;

        procedure test(c); character c; begin
            trace("Test  upc(" & edit(c) & ") ==> " & edit(upc(c)));
            trace("Test upc1(" & edit(c) & ") ==> " & edit(upc1(c)));
            if upc(c) ne upc1(c) then err("Test upc(" & edit(c) & ") FAILED");
        end;
        
        trace("BEGIN TEST upc --------------------------------------------------- nFailed=" & edit(nFailed));
            for i:=0 step 1 until 127 do test(char(i));
        trace("ENDOF TEST upc --------------------------------------------------- nFailed=" & edit(nFailed));

    end;
    
    procedure testUpcompare; begin ------------------------------------------------------------------------------ upcompare
        boolean procedure upcompare1(master,test); text master,test;
        if master.pos + test.length <= master.length + 1 then begin
            character cmaster,ctest;
            integer shift;
            shift:= rank('a') - rank('A');
            while master.more and test.more and cmaster = ctest do begin
                cmaster:= master.getchar;
                ctest:= test.getchar;
                if (if cmaster > 'Z' then letter(cmaster) else false)
                    then cmaster:= char(rank(cmaster) - shift);
            end loop;
        out:upcompare1:= cmaster = ctest;
        end;
    
        procedure test(master,test,expectedResult); text master,test; boolean expectedResult; begin
            boolean result,result1;
            result:=upcompare(master,test);
            result1:=upcompare1(master,test);
            trace("Test  upcompare(" & master & "," & test & ") ==> " & edit(result));
            trace("Test upcompare1(" & master & "," & test & ") ==> " & edit(result1));
            if result ne result1 then err("Test upcompare(" & master & "," & test & ") FAILED - not equal");
            if result ne expectedResult then err("Test upcompare(" & master & "," & test & ") FAILED - Wrong result");
        end;

        trace("BEGIN TEST upcompare --------------------------------------------------- nFailed=" & edit(nFailed));
            test("begin","BEG",true);
            test("begin","beg",false);
            test("begin","BEG",true);
            test("begin","beg",false);
            test("xxxxx","BEG",false);
            t1:-copy("begin procedure XXX"); t1.setpos(7);
            test(t1,"PROC",true);
        trace("ENDOF TEST upcompare --------------------------------------------------- nFailed=" & edit(nFailed));

    end;
        
    procedure testUpto; begin ------------------------------------------------------------------------------ upto
        text procedure upto1(t,i); text t; integer i;
        if i>0 then upto1 :- if i>t.length then t else t.sub(1,i-1);
    
        procedure test(t,i); text t; integer i; begin
            trace("Test  upto(" & t & "," & edit(i) & ") ==> " & upto(t,i));
            trace("Test upto1(" & t & "," & edit(i) & ") ==> " & upto1(t,i));
            if upto(t,i) ne upto1(t,i) then err("Test upto(" & t & "," & edit(i) & ") FAILED");
        end;
        
        trace("BEGIN TEST upto --------------------------------------------------- nFailed=" & edit(nFailed));
            test("",6);
            test("abracadab",-6);
            test("abracadab",26);
            test("abracadab",6);
        trace("BEGIN TEST upto --------------------------------------------------- nFailed=" & edit(nFailed));

    end;
    
    procedure fullTest; begin;
        --testAbort;     -- MUST BE RUN IN A SEPARATE TESTPROGRAM
        testChange;
        testChangeAll;
        testCheckextension;    
        testCheckfrac;    
        testCheckint;    
        testCheckreal;    
        testCompress;    
        testConcatenations;    
        testCptime;
        testDayno;    -- ???
        testDaytime;    
        testDepchar;    
        --testEnterdebug;     -- MUST BE RUN IN A SEPARATE TESTPROGRAM
        --testExit;           -- MUST BE RUN IN A SEPARATE TESTPROGRAM
        testFetchar;    
        testFindtrigger;    
        testFrom;    
        testFront;    
        testFrontcompare;    
        testFrontstrip;    
        testGetitem;    
        testHash;    
        testInitem;
        --testInsinglechar;   -- MUST BE RUN IN A SEPARATE TESTPROGRAM
        testLinecount;
        testLowc;    
        testMaketext;    
        testPuttext;    
        testRest;    
        testScanchar;    
        testScanfrac;    
        testScanint;    
        testScanreal;    
        testScanto;    
        testSearch;    
        testSkip;    
        testStartpos;    
        testToday;    
        testTsub;    
        testUpc;    
        testUpcompare;
        testUpto;
    end;
    
    procedure singleTest; begin;
        --testAbort;     -- MUST BE RUN IN A SEPARATE TESTPROGRAM
        
        -- TEXT MANIPULATION
        --testChange;    -- Replacing Subtexts.
        --testChangeAll;   
        --testCheckextension;  -- Add default File name extension  
        
        -- DE-EDITING
        --testCheckfrac;   -- Check if next item is a factional number 
        --testCheckint;    -- Check if next item is a integer number
        --testCheckreal;   -- Check if next item is a real number
          
        --testCompress;     --  Removes all occurrences of the character c in the text t.   
        --testConcatenations;  -- Concatenate texts  
        --testCptime;            -- Returns total CPU time spent until now.  
        --testDayno;    -- ???
        --testDaytime;    
        --testDepchar;    
        --testEnterdebug;     -- MUST BE RUN IN A SEPARATE TESTPROGRAM
        --testExit;           -- MUST BE RUN IN A SEPARATE TESTPROGRAM
        --testFetchar;    
        --testFindtrigger;    
        --testFrom;    
        testFront;    
        --testFrontcompare;    
        --testFrontstrip;    
        --testGetitem;    
        --testHash;    
        --testInitem;
        --testInsinglechar;
        --testLinecount;
        --testLowc;    
        --testMaketext;    -- generate a ch-filled text
        --testPuttext;    
        --testRest;    
        --testScanchar;    
        --testScanfrac;    
        --testScanint;    
        --testScanreal;    
        --testScanto;    
        --testSearch;    
        --testSkip;    
        --testStartpos;    
        --testToday;    
        --testTsub;    
        --testUpc;    
        --testUpcompare;
        --testUpto;
    end;
    
    fullTest;
--    singleTest;
       
    
end;