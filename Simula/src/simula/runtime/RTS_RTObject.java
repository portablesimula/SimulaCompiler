/*
 * (CC) This work is licensed under a Creative Commons
 * Attribution 4.0 International License.
 *
 * You find a copy of the License on the following
 * page: https://creativecommons.org/licenses/by/4.0/
 */
package simula.runtime;

import java.util.Iterator;

/**
 * This class is the main superclass used to form all other Simula classes
 * <p>
 * Link to GitHub: <a href="https://github.com/portablesimula/SimulaCompiler/blob/master/Simula/src/simula/runtime/RTS_RTObject.java"><b>Source File</b></a>.
 * @author Ã˜ystein Myhre Andersen
 */
@SuppressWarnings("unchecked")
public abstract class RTS_RTObject {

	/**
	 * The default input line length. I.e. BASICIO'INPUT_LINELENGTH
	 */
	static final int _INPUT_LINELENGTH = 80;
	/**
	 * The default output line length. I.e. BASICIO'OUTPUT_LINELENGTH
	 */
	static final int _OUTPUT_LINELENGTH = 132;
	/**
	 * The variable SYSIN. 
	 */
	static RTS_Infile _SYSIN;
	
	/**
	 * The intenal pointer to sysout.
	 */
	public static RTS_Printfile _SYSOUT;

	/**
	 * Implementation of Simula's Procedure sysin.
	 * @return a pointer to _SYSIN
	 */
	public static RTS_Infile sysin() {
		return (_SYSIN);
	}

	/**
	 * Implementation of Simula's Procedure sysout.
	 * @return a pointer to _SYSOUT
	 */
	public static RTS_Printfile sysout() {
		return (_SYSOUT);
	}

	/**
	 * Execution stat time in millis
	 */
	private static long startTimeMs;

	/**
	 * Simula object Operational States
	 */
	public enum OperationalState {
		/**
		 * The object is attached
		 */
		attached,
		/**
		 * The object is detached
		 */
		detached,
		/**
		 * The object is resumed
		 */
		resumed,
		/**
		 * The object is terminated
		 */
		terminated,
		/**
		 * The Process object is shuting down
		 */
		terminatingProcess
	}

	/**
	 * This object's Operational State.
	 * @see OperationalState
	 */
	public OperationalState _STATE;
	
	/**
	 * This is a pointer to the Coroutine in which this block instance is running.
	 * <br>
	 * If this block instance is detached it is used to save the complete
	 * reactivation point (call stack and the continuation point).
	 */
	public RTS_Coroutine _CORUT;

	/**
	 * Outmost Block Instance
	 */
	public static final RTS_BASICIO _CTX = new RTS_BASICIO(null);
	
	/**
	 * Current Block Instance
	 */
	public static RTS_RTObject _CUR = _CTX;
	
	/**
	 * Jump Table Index used by _STM()
	 */
	public int _JTX;

	/**
	 * This is a static property generated by the compiler.
	 * <br>
	 * It will return true for Block or Prefixed Block with local classes.
	 * <br>
	 * This method is redefined in every subclass which represent a Simula Block.
	 * 
	 * @return true: this object is a QPS System block
	 */
	public boolean isQPSystemBlock() {
		return (false);
	} // Needs Redefinition

	/**
	 * This is a static property generated by the compiler.
	 * <br>
	 * It will return true for Blocks in which 'detach' is used.
	 * <br>
	 * This method is redefined in every subclass which represent a Simula Block.
	 * 
	 * @return true: this object is a QPS System block
	 */
	public boolean isDetachUsed() {
		return (false);
	} // Needs Redefinition

	/**
	 * This is a pointer to the object of the nearest textually enclosing block
	 * instance, also called 'static link'.
	 */
	public RTS_RTObject _SL; // Static Link

	/**
	 * If this block instance is attached this is a pointer to the object of the
	 * block instance to which the instance is attached (also called dynamic link),
	 * i.e. it points to the block instance which called this one.
	 */
	RTS_RTObject _DL; // Dynamic Link

	// ************************************************************
	// *** Constructor
	// ************************************************************

	/**
	 * Constructor
	 * 
	 * @param SL Static Link, may be null when creating CONTEXT, TEXTOBJ and TXTREF
	 */
	public RTS_RTObject(final RTS_RTObject SL) {
		if (SL != null) {
			this._SL = SL;
			this._CORUT = RTS_Coroutine.getCurrentCoroutine();
		}
	}

	/**
	 * The Abstract Class RTS_NAME&lt;T> are supporting Simula's Name-Parameters in
	 * Java Coding.
	 * <p>
	 * The basic principle is to establish an
	 * object within the calling scope. This object will have two attribute methods;
	 * 'get' og 'put' to evaluate and read the value of the actual parameter, or, if legal, to
	 * write into it. The following Java-class is used to perform such parameter
	 * transmissions:
	 * 
	 * <pre>
	 * 
	 *	 abstract class RTS_NAME&lt;T> {
	 *	 	abstract T get();
	 * 
	 *	 	void put(T x) {
	 *	 		error("Illegal ...");
	 *	 	}
	 *	 }
	 *
	 * </pre>
	 * 
	 * Note that we both use abstract Java classes and 'generics' i.e. the actual
	 * type is a parameter. Also note that the 'put' method has a default definition
	 * producing an error. This enables redefinition of the 'put' method to be
	 * dropped for expression as actual parameters.
	 * <p>
	 * Suppose the Simula Procedure:
	 * 
	 * <pre>
	 *		procedure P(k); name k; integer k; k:=k+1;
	 * </pre>
	 * 
	 * It will be translated to something like this Java method:
	 * 
	 * <pre>
	 *	 void P(RTS_NAME&lt;Integer> k) {
	 *	 	k.put(k.get() + 1); // E.g: k=k+1
	 *	 }
	 * </pre>
	 * 
	 * In the calling place, in practice in the actual parameter list, we create an
	 * object of a specific subclass of RTS_NAME&lt;T> by specifying the Integer type
	 * and defining the get and put methods. Eg. If the current parameter is a
	 * variable 'q', then the actual parameter will be coded as follows:
	 * 
	 * <pre>
	 *	 new RTS_NAME&lt;Integer>() {
	 *	 	Integer get() {
	 *	 		return (q);
	 *	 	}
	 * 
	 *	 	void put(Integer x) {
	 *	 		q = (int) x;
	 *	 	}
	 *	 }
	 * </pre>
	 * 
	 * However, if the actual parameter is an expression like (j + m * n) then it
	 * will be coded as follows:
	 * 
	 * <pre>
	 *	 new RTS_NAME&lt;Integer>() {
	 *	 	Integer get() {
	 *	 		return (j + m * n);
	 *	 	}
	 *	 }
	 * </pre>
	 * 
	 * Here we see that the 'put' method is not redefined so that any attempt to
	 * assign a new value to this name parameter will result in an error message.
	 *
	 * @param <T> the type of the parameter
	 */
	public abstract class RTS_NAME<T> {
		/**
		 * The environment in which evaluations of get'parameters will take place.
		 */
		public RTS_RTObject _CUR; // Thunk Environment

		/**
		 * Construct a RTS_NAME object
		 */
		public RTS_NAME() {
			_CUR = RTS_RTObject._CUR;
		}

		/**
		 * Evaluate and get the value of a name parameter
		 * @return the value 
		 */
		public abstract T get();

		/**
		 * Write back into a name parameter
		 * @param x the value to be written
		 * @return the value written
		 */
		public T put(final T x) {
			throw new RTS_SimulaRuntimeError("Illegal assignment. Name parameter is not a variable");
		}
	}

	// ************************************************************
	// *** ARRAY OBJECTS
	// ************************************************************

	/**
	 * This class is used to hold bound pairs in RTS_ARRAY objects.
	 *
	 */
	public final class RTS_BOUNDS {
		/**
		 * An array upper bound
		 */
		final public int LB;
		/**
		 * An array ELEMENTS size
		 */
		final public int SIZE;

		/**
		 * Create an array bound pair object
		 * @param LB Lower bound
		 * @param UB Upper bound
		 */
		public RTS_BOUNDS(final int LB, final int UB) {
			if (LB > UB)
				throw new RTS_SimulaRuntimeError("Lower bound(" + LB + ") > upper bound(" + UB + ")");
			this.LB = LB;
			SIZE = UB - LB + 1;
		}

		@Override
		public String toString() {
			return ("" + LB + ':' + (LB + SIZE - 1));
		}
	}


	// ************************************************************
	// *** INTEGER ARRAY
	// ************************************************************
	/**
	 * This class represent a Simula integer array. 
	 *
	 */
	public final class RTS_INTEGER_ARRAY extends RTS_ARRAY {
		/**
		 * The elements in this RTS_INTEGER_ARRAY
		 */
		final private int[] ELTS;

		/**
		 * Create a integer array with the given bounds.
		 * @param BOUNDS the array bounds
		 */
		public RTS_INTEGER_ARRAY(final RTS_BOUNDS... BOUNDS) {
			super(BOUNDS);
			ELTS = new int[SIZE];
		}

		/**
		 * This method will put a value into ELTS[ix]
		 * @param ix the index of ELTS
		 * @param val the value to put
		 * @return the value stored
		 */
		public int putELEMENT(int ix, int val) {
			ELTS[ix] = val;
			return (val);
		}

		/**
		 * This method will return a value from ELTS[x]
		 * @param x the index of ELTS
		 * @return the value loaded
		 */
		public int getELEMENT(int... x) {
			return (ELTS[index(x)]);
		}

		/**
		 * Abstract method redefined for all subclaRTS_BOUNDS;type>_ARRAY
		 * @return a copy of this RTS_INTEGER_ARRAY
		 */
		@Override
		public RTS_INTEGER_ARRAY COPY() {
			RTS_INTEGER_ARRAY copy = new RTS_INTEGER_ARRAY(BOUNDS);
			System.arraycopy(ELTS, 0, copy.ELTS, 0, SIZE);
			return (copy);
		}
	}

	// ************************************************************
	// *** CHARACTER ARRAY
	// ************************************************************
	/**
	 * This class represent a Simula character array. 
	 *
	 */
	public final class RTS_CHARACTER_ARRAY extends RTS_ARRAY {
		/**
		 * The elements in this RTS_CHARACTER_ARRAY
		 */
		final private char[] ELTS;

		/**
		 * Create a character array with the given bounds.
		 * @param BOUNDS the array bounds
		 */
		public RTS_CHARACTER_ARRAY(final RTS_BOUNDS... BOUNDS) {
			super(BOUNDS);
			ELTS = new char[SIZE];
		}

		/**
		 * This method will put a value into ELTS[ix]
		 * @param ix the index of ELTS
		 * @param val the value to put
		 * @return the value stored
		 */
		public char putELEMENT(int ix, char val) {
			ELTS[ix] = val;
			return (val);
		}

		/**
		 * This method will return a value from ELTS[x]
		 * @param x the index of ELTS
		 * @return the value loaded
		 */
		public char getELEMENT(int... x) {
			return (ELTS[index(x)]);
		}

		/**
		 * Abstract method redefined for all subclass &lt;type>_ARRAY
		 * @return a copy of this RTS_CHARACTER_ARRAY
		 */
		@Override
		public RTS_CHARACTER_ARRAY COPY() {
			RTS_CHARACTER_ARRAY copy = new RTS_CHARACTER_ARRAY(BOUNDS);
			System.arraycopy(ELTS, 0, copy.ELTS, 0, SIZE);
			return (copy);
		}
	}

	// ************************************************************
	// *** BOOLEAN ARRAY
	// ************************************************************
	/**
	 * This class represent a Simula boolean array. 
	 *
	 */
	public final class RTS_BOOLEAN_ARRAY extends RTS_ARRAY {
		/**
		 * The elements in this RTS_BOOLEAN_ARRAY
		 */
		final private boolean[] ELTS;

		/**
		 * Create a boolean array with the given bounds.
		 * @param BOUNDS the array bounds
		 */
		public RTS_BOOLEAN_ARRAY(final RTS_BOUNDS... BOUNDS) {
			super(BOUNDS);
			ELTS = new boolean[SIZE];
		}

		/**
		 * This method will put a value into ELTS[ix]
		 * @param ix the index of ELTS
		 * @param val the value to put
		 * @return the value stored
		 */
		public boolean putELEMENT(int ix, boolean val) {
			ELTS[ix] = val;
			return (val);
		}

		/**
		 * This method will return a value from ELTS[x]
		 * @param x the index of ELTS
		 * @return the value loaded
		 */
		public boolean getELEMENT(int... x) {
			return (ELTS[index(x)]);
		}

		/**
		 * Abstract method redefined for all subclass &lt;type>_ARRAY
		 * @return a copy of this RTS_BOOLEAN_ARRAY
		 */
		@Override
		public RTS_BOOLEAN_ARRAY COPY() {
			RTS_BOOLEAN_ARRAY copy = new RTS_BOOLEAN_ARRAY(BOUNDS);
			System.arraycopy(ELTS, 0, copy.ELTS, 0, SIZE);
			return (copy);
		}
	}

	// ************************************************************
	// *** REAL TYPE ARRAY
	// ************************************************************
	/**
	 * This class is the common superclass for real type arrays. 
	 * It is introduced to implement overloading of real type parameter arrays.
	 *
	 */
	public abstract class RTS_REALTYPE_ARRAY extends RTS_ARRAY {

		/**
		 * Create a real-type array with the given bounds.
		 * @param BOUNDS the array bounds
		 */
		public RTS_REALTYPE_ARRAY(final RTS_BOUNDS... BOUNDS) {
			super(BOUNDS);
		}

		/**
		 * Utility for fetching value of a real type array
		 * <p>
		 * Used by: Reandom drawing discrete and linear procedures.
		 * @param i index
		 * @return value of ELTS[i]
		 */
		public abstract double getRealTypeELEMENT(int i);
	}

	// ************************************************************
	// *** REAL ARRAY
	// ************************************************************
	/**
	 * This class represent a Simula real array. 
	 *
	 */
	public final class RTS_REAL_ARRAY extends RTS_REALTYPE_ARRAY {
		/**
		 * The elements in this RTS_REAL_ARRAY
		 */
		final float[] ELTS;

		/**
		 * Create a real array with the given bounds.
		 * @param BOUNDS the array bounds
		 */
		public RTS_REAL_ARRAY(final RTS_BOUNDS... BOUNDS) {
			super(BOUNDS);
			ELTS = new float[SIZE];
		}

		/**
		 * This method will put a value into ELTS[ix]
		 * @param ix the index of ELTS
		 * @param val the value to put
		 * @return the value stored
		 */
		public float putELEMENT(int ix, float val) {
			ELTS[ix] = val;
			return (val);
		}

		/**
		 * This method will return a value from ELTS[x...]
		 * @param x the index of ELTS
		 * @return the value loaded
		 */
		public float getELEMENT(int... x) {
			return (ELTS[index(x)]);
		}

		/**
		 * Abstract method redefined for all subclass &lt;type>_ARRAY
		 * @return a copy of this RTS_REAL_ARRAY
		 */
		@Override
		public RTS_REAL_ARRAY COPY() {
			RTS_REAL_ARRAY copy = new RTS_REAL_ARRAY(BOUNDS);
			System.arraycopy(ELTS, 0, copy.ELTS, 0, SIZE);
			return (copy);
		}

		@Override
		public double getRealTypeELEMENT(int i) {
			return (ELTS[i]);
		}
	}

	// ************************************************************
	// *** LONG REAL ARRAY
	// ************************************************************
	/**
	 * This class represent a Simula long real array. 
	 *
	 */
	public final class RTS_LONG_REAL_ARRAY extends RTS_REALTYPE_ARRAY {
		/**
		 * The elements in this RTS_LONG_REAL_ARRAY
		 */
		final double[] ELTS;

		/**
		 * Create a long real array with the given bounds.
		 * @param BOUNDS the array bounds
		 */
		public RTS_LONG_REAL_ARRAY(final RTS_BOUNDS... BOUNDS) {
			super(BOUNDS);
			ELTS = new double[SIZE];
		}

		/**
		 * This method will put a value into ELTS[ix]
		 * @param ix the index of ELTS
		 * @param val the value to put
		 * @return the value stored
		 */
		public double putELEMENT(int ix, double val) {
			ELTS[ix] = val;
			return (val);
		}

		/**
		 * This method will return a value from ELTS[x...]
		 * @param x the index of ELTS
		 * @return the value loaded
		 */
		public double getELEMENT(int... x) {
			return (ELTS[index(x)]);
		}

		/**
		 * Abstract method redefined for all subclass &lt;type>_ARRAY
		 * @return a copy of this RTS_LONG_REAL_ARRAY
		 */
		@Override
		public RTS_LONG_REAL_ARRAY COPY() {
			RTS_LONG_REAL_ARRAY copy = new RTS_LONG_REAL_ARRAY(BOUNDS);
			System.arraycopy(ELTS, 0, copy.ELTS, 0, SIZE);
			return (copy);
		}

		@Override
		public double getRealTypeELEMENT(int i) {
			return (ELTS[i]);
		}
	}

	// ************************************************************
	// *** TEXT ARRAY
	// ************************************************************
	/**
	 * This class represent a Simula text array. 
	 *
	 */
	public final class RTS_TEXT_ARRAY extends RTS_ARRAY {
		/**
		 * The elements in this RTS_TEXT_ARRAY
		 */
		final private RTS_TXT[] ELTS;


		/**
		 * Create a text array with the given bounds.
		 * @param BOUNDS the array bounds
		 */
		public RTS_TEXT_ARRAY(final RTS_BOUNDS... BOUNDS) {
			super(BOUNDS);
			ELTS = new RTS_TXT[SIZE];
		}

		/**
		 * This method will put a text reference into ELTS[ix]
		 * @param ix the index of ELTS
		 * @param val the value to put
		 * @return the value stored
		 */
		public RTS_TXT putELEMENT(int ix, RTS_TXT val) {
			ELTS[ix] = val;
			return (val);
		}

		/**
		 * This method will return a text reference from ELTS[x...]
		 * @param x the indexes of ELTS
		 * @return the value loaded
		 */
		public RTS_TXT getELEMENT(int... x) {
			return (ELTS[index(x)]);
		}

		/**
		 * Abstract method redefined for all subclass &lt;type>_ARRAY
		 * @return a copy of this TEXT_ARRAY
		 */
		@Override
		public RTS_TEXT_ARRAY COPY() {
			RTS_TEXT_ARRAY copy = new RTS_TEXT_ARRAY(BOUNDS);
			System.arraycopy(ELTS, 0, copy.ELTS, 0, SIZE);
			return (copy);
		}
	}

	// ************************************************************
	// *** REF() ARRAY
	// ************************************************************
	/**
	 * This class represent a Simula ref(T) array. 
	 *
	 * @param <T> the actual array type
	 */
	public final class RTS_REF_ARRAY<T> extends RTS_ARRAY {
		/**
		 * The elements in this RTS_REF_ARRAY
		 */
		final private RTS_RTObject[] ELTS;

		/**
		 * Create a ref() array with the given bounds.
		 * @param BOUNDS the array bounds
		 */
		public RTS_REF_ARRAY(final RTS_BOUNDS... BOUNDS) {
			super(BOUNDS);
			ELTS = new RTS_RTObject[SIZE];
		}

		/**
		 * This method will put a object reference into ELTS[ix]
		 * @param ix the index of ELTS
		 * @param val the value to put
		 * @return the value stored
		 */
		public T putELEMENT(int ix, T val) {
			ELTS[ix] = (RTS_RTObject) val;
			return (val);
		}

		/**
		 * This method will return a value from ELTS[x...]
		 * @param x the indexes of ELTS
		 * @return the value loaded
		 */
		public T getELEMENT(int... x) {
			return ((T) ELTS[index(x)]);
		}

		@Override
		public RTS_REF_ARRAY<T> COPY() {
			RTS_REF_ARRAY<T> copy = new RTS_REF_ARRAY<T>(BOUNDS);
			System.arraycopy(ELTS, 0, copy.ELTS, 0, SIZE);
			return (copy);
		}
	}

	// ********************************************************************
	// *** Parameter Transmission in case of Formal/Virtual Procedure Call
	// ********************************************************************
	
	/**
	 * Utility method to support Parameter Transmission in case of Formal/Virtual Procedure Call.
	 * <p>
	 * If the parameter is 'by name' the parameter is evaluated.
	 * <p>
	 * See {@link simula.compiler.syntaxClass.declaration.ProcedureDeclaration#doCodePrepareFormal() simula.compiler.declaration.ProcedureDeclaration#doCodePrepareFormal}
	 * @param par an Object
	 * @return a RTS_ARRAY value
	 */
	public RTS_ARRAY arrayValue(final Object par) {
		if (par instanceof RTS_NAME<?> arr)
			return ((RTS_ARRAY) arr.get());
		return ((RTS_ARRAY) par);
	}

	/**
	 * Utility method to support Parameter Transmission in case of Formal/Virtual Procedure Call.
	 * <p>
	 * If the parameter is 'by name' the parameter is evaluated.
	 * <p>
	 * See {@link simula.compiler.syntaxClass.declaration.ProcedureDeclaration#doCodePrepareFormal() simula.compiler.declaration.ProcedureDeclaration#doCodePrepareFormal}
	 * @param par an Object
	 * @return a RTS_PRCQNT value
	 */
	public RTS_PRCQNT procValue(final Object par) {
		if (par instanceof RTS_NAME<?> proc)
			return ((RTS_PRCQNT) proc.get());
		return ((RTS_PRCQNT) par);
	}

	/**
	 * Utility method to support Parameter Transmission in case of Formal/Virtual Procedure Call.
	 * <p>
	 * If the parameter is 'by name' the parameter is evaluated.
	 * <p>
	 * If the parameter is a RTS_PRCQNT that procedure is called 
	 * <p>
	 * See {@link simula.compiler.syntaxClass.declaration.ProcedureDeclaration#doCodePrepareFormal() simula.compiler.declaration.ProcedureDeclaration#doCodePrepareFormal}
	 * @param par an Object
	 * @return a Object value
	 */
	public Object objectValue(Object par) {
		if (par instanceof RTS_NAME<?> npar)
			par = npar.get();
		if (par instanceof RTS_PRCQNT proc)
			par = proc.CPF()._RESULT();
		return (par);
	}

	/**
	 * Utility method to support Parameter Transmission in case of Formal/Virtual Procedure Call.
	 * <p>
	 * If the parameter is 'by name' the parameter is evaluated.
	 * <p>
	 * If the parameter is a _PRCQNT that procedure is called 
	 * <p>
	 * If the parameter is a Float or Double they are casted to Integer 
	 * <p>
	 * See {@link simula.compiler.syntaxClass.declaration.ProcedureDeclaration#doCodePrepareFormal() simula.compiler.declaration.ProcedureDeclaration#doCodePrepareFormal}
	 * @param par an Object
	 * @return an Integer value
	 */
	public int intValue(Object par) {
		if (par instanceof RTS_NAME<?> npar)
			par = npar.get();
		if (par instanceof RTS_PRCQNT proc)
			par = proc.CPF()._RESULT();
		if (par instanceof Float f)
			return (f.intValue());
		if (par instanceof Double d)
			return (d.intValue());
		if (par instanceof Integer i)
			return (i);
		throw new ClassCastException("Incompatible Types: int," + par.getClass().getSimpleName());
	}

	/**
	 * Utility method to support Parameter Transmission in case of Formal/Virtual Procedure Call.
	 * <p>
	 * If the parameter is 'by name' the parameter is evaluated.
	 * <p>
	 * If the parameter is a _PRCQNT that procedure is called 
	 * <p>
	 * If the parameter is a Integer or Double they are casted to Float 
	 * <p>
	 * See {@link simula.compiler.syntaxClass.declaration.ProcedureDeclaration#doCodePrepareFormal() simula.compiler.declaration.ProcedureDeclaration#doCodePrepareFormal}
	 * @param par an Object
	 * @return a Float value
	 */
	public float floatValue(Object par) {
		if (par instanceof RTS_NAME<?> npar)
			par = npar.get();
		if (par instanceof RTS_PRCQNT proc)
			par = proc.CPF()._RESULT();
		if (par instanceof Float f)
			return (f);
		if (par instanceof Double d)
			return (d.floatValue());
		if (par instanceof Integer i)
			return (i.floatValue());
		throw new ClassCastException("Incompatible Types: float," + par.getClass().getSimpleName());
	}

	/**
	 * Utility method to support Parameter Transmission in case of Formal/Virtual Procedure Call.
	 * <p>
	 * If the parameter is 'by name' the parameter is evaluated.
	 * <p>
	 * If the parameter is a _PRCQNT that procedure is called 
	 * <p>
	 * If the parameter is an Integer or Float they are casted to Double 
	 * <p>
	 * See {@link simula.compiler.syntaxClass.declaration.ProcedureDeclaration#doCodePrepareFormal() simula.compiler.declaration.ProcedureDeclaration#doCodePrepareFormal}
	 * @param par an Object
	 * @return a Double value
	 */
	public double doubleValue(Object par) {
		if (par instanceof RTS_NAME<?> npar)
			par = npar.get();
		if (par instanceof RTS_PRCQNT proc)
			par = proc.CPF()._RESULT();
		if (par instanceof Float f)
			return (f.doubleValue());
		if (par instanceof Double d)
			return (d);
		if (par instanceof Integer i)
			return (i.doubleValue());
		throw new ClassCastException("Incompatible Types: double," + par.getClass().getSimpleName());
	}

	// *******************************************************
	// *** FRAMEWORK for for-list iteration
	// *******************************************************
	/**
	 * The Implementation of the for-statement is a bit tricky.
	 * The basic idea is to create a ForList iterator that iterates over a set of ForElt iterators.
	 * The following subclasses of ForElt are defined:
	 * <ul>
	 * <li> {@link SingleElt SingleElt&lt;T>} for basic types T control variable
	 * <li> {@link SingleTValElt SingleTValElt} for Text type control variable
	 * <li> {@link StepUntil StepUntil} for numeric types
	 * <li> {@link WhileElt WhileElt&lt;T>} for basic types T control variable
	 * <li> {@link WhileTValElt WhileTValElt} representing For t:= &lt;TextExpr> while &lt;Cond>
	 *                  	With text value assignment
	 * </ul>
	 * Each of which has a boolean method 'hasNext' indicating whether this for-element is exhausted.
	 * All parameters to these classes are transferred 'by name'.
	 * This is done to ensure that all expressions are evaluated in the right order.
	 * The assignment to the 'control variable' is done within the various for-elements when the 'next' method is invoked.
	 *
	 */
	public final class ForList implements Iterable<Boolean> {
		/**
		 * The ForList Iterator.
		 */
		ForListIterator forListIterator;

		/**
		 * Create a ForList Iterator.
		 * @param forElt an array of ForElt Iterators.
		 */
		public ForList(final ForElt... forElt) {
			forListIterator = new ForListIterator(forElt);
		}

		@Override
		public Iterator<Boolean> iterator() {
			return (forListIterator);
		}
	}

	/**
	 * Simula for-statement for-list iterator
	 * 
	 */
	public final class ForListIterator implements Iterator<Boolean> {
		/**
		 * The ForElt array.
		 */
		final ForElt[] forElt;
		/**
		 * Current index into the ForElt array.
		 */
		int index;

		/**
		 * Create a ForListIterator consisting of an array of ForElt Iterators.
		 * @param forElt an array of ForElt Iterators.
		 */
		public ForListIterator(final ForElt... forElt) {
			this.forElt = forElt;
		}

		@Override
		public boolean hasNext() {
			return (index < forElt.length && forElt[index].hasNext());
		}

		@Override
		public Boolean next() {
			Boolean val = forElt[index].next();
			if (!forElt[index].hasNext())
				index++;
			return (val);
		}
	}

	/**
	 * 
	 * Abstract class representing a for-statement element, all of 
	 * which are Iterator's.
	 * 
	 */
	public abstract class ForElt implements Iterator<Boolean> {
		/**
		 * More to come ?
		 */
		boolean more;

		/**
		 * Create a for-stament element.
		 */
		public ForElt() {
			more = true;
		}

		@Override
		public boolean hasNext() {
			return (more);
		}
	}

	/**
	 * For-statement single value element, not text.
	 * 
	 * <pre>
	 * 		For i:= &lt;Expr>
	 * </pre>
	 *
	 * @param <T> the type of this element
	 */
	public final class SingleElt<T> extends ForElt {
		/**
		 * The for-statement control variable.
		 */
		final RTS_NAME<T> cvar;
		/**
		 * Next value.
		 */
		RTS_NAME<T> nextValue;

		/**
		 * Create single value element, not text.
		 * 
		 * @param cvar the for-statement control variable
		 * @param val the text value expression
		 * 
		 */
		public SingleElt(final RTS_NAME<T> cvar, final RTS_NAME<T> val) {
			this.cvar = cvar;
			this.nextValue = val;
			more = true;
		}

		@Override
		public boolean hasNext() {
			return (nextValue != null);
		}

		@Override
		public Boolean next() {
			if (nextValue == null)
				return (false);
			T val = nextValue.get();
			cvar.put(val);
			nextValue = null;
			return (true);
		}
	}

	/**
	 * For-statement single text value element.
	 * 
	 * <pre>
	 * 		For t:= &lt;TextExpr> // Text Value Assignment
	 * </pre>
	 *
	 */
	public final class SingleTValElt extends ForElt {
		/**
		 * The for-statement control variable.
		 */
		final RTS_NAME<RTS_TXT> cvar;
		/**
		 * Next value.
		 */
		RTS_NAME<RTS_TXT> nextValue;

		/**
		 * Create single text value element.
		 * 
		 * @param cvar the for-statement control variable
		 * @param tval the text value expression
		 * 
		 */
		public SingleTValElt(final RTS_NAME<RTS_TXT> cvar, final RTS_NAME<RTS_TXT> tval) {
			this.cvar = cvar;
			this.nextValue = tval;
			more = true;
		}

		@Override
		public boolean hasNext() {
			return (nextValue != null);
		}

		@Override
		public Boolean next() {
			if (nextValue == null)
				return (false);
			RTS_TXT val = nextValue.get();
			_ASGTXT(cvar.get(), val);
			nextValue = null;
			return (true);
		}
	}

	/**
	 * For-statement step until element.
	 * 
	 * <pre>
	 *  A1 step A2 until A3 C := A1;
	 *                      DELTA := A2;
	 *                      while DELTA*(C-A3) &lt;= 0
	 *                      do begin
	 *                            S;
	 *                            DELTA := A2;
	 *                            C := C + DELTA;
	 *                      end while;
	 *                      ... next for list element
	 * </pre>
	 *
	 */
	public final class StepUntil extends ForElt {
		/**
		 * The for-statement control variable.
		 */
		final RTS_NAME<Number> cvar;
		/**
		 * The initial value.
		 */
		final RTS_NAME<Number> init;
		/**
		 * The step value.
		 */
		final RTS_NAME<Number> step;
		/**
		 * The until value.
		 */
		final RTS_NAME<Number> until;
		/**
		 * Next value.
		 */
		Number nextValue;

		/**
		 * Create step until element.
		 * 
		 * @param cvar the for-statement control variable
		 * @param init the initial value expression
		 * @param step the step value expression
		 * @param until the until value expression
		 * 
		 */
		public StepUntil(final RTS_NAME<Number> cvar, final RTS_NAME<Number> init, final RTS_NAME<Number> step,
				final RTS_NAME<Number> until) {
			this.cvar = cvar;
			this.init = init;
			this.step = step;
			this.until = until;
		}

		@Override
		public Boolean next() {
			try {
				Number stp;
				int sign;
				if (nextValue == null) {
					nextValue = init.get();
					stp = 0;// new Integer(0);
					sign = (int) Math.signum(step.get().longValue());
				} // First value
				else {
					stp = step.get();
					sign = (int) Math.signum(stp.longValue());
				}
				Number val = nextValue;
				Number utl = until.get();
				if (val instanceof Double || stp instanceof Double) {
					nextValue = val.doubleValue() + stp.doubleValue();
					more = (sign * (nextValue.doubleValue() - utl.doubleValue()) <= 0);
				} else if (val instanceof Float || stp instanceof Float) {
					nextValue = val.floatValue() + stp.floatValue();
					more = (sign * (nextValue.floatValue() - utl.floatValue()) <= 0);
				} else if (val instanceof Long || stp instanceof Long) {
					nextValue = val.longValue() + stp.longValue();
					more = (sign * (nextValue.longValue() - utl.longValue()) <= 0);
				} else {
					nextValue = val.intValue() + stp.intValue();
					more = (sign * (nextValue.intValue() - utl.intValue()) <= 0);
				}
				cvar.put(nextValue);
				return (more);
			} catch (Throwable e) {
				e.printStackTrace();
				return (null);
			}
		}
	}

	/**
	 * For-statement While element, not text
	 * 
	 * <pre>
	 * 		For i:= &lt;Expr> while &lt;Cond>
	 * </pre>
	 *
	 * @param <T> the type of this element
	 */
	public final class WhileElt<T> extends ForElt {
		/**
		 * The for-statement control variable.
		 */
		final RTS_NAME<T> cvar;
		/**
		 * A Value expression.
		 */
		final RTS_NAME<T> expr;
		/**
		 * The condition that determines whether to continue.
		 */
		RTS_NAME<Boolean> cond;

		/**
		 * Create While element. 
		 * @param cvar the for-statement control variable
		 * @param expr a Value expression
		 * @param cond a Boolean exppression
		 */
		public WhileElt(final RTS_NAME<T> cvar, final RTS_NAME<T> expr, final RTS_NAME<Boolean> cond) {
			this.cvar = cvar;
			this.expr = expr;
			this.cond = cond;
		}

		@Override
		public Boolean next() {
			T val = expr.get();
			cvar.put(val);
			more = cond.get(); // IF not more return null - test i loopen: if(_CB==null) continue;
			return (more);
		}
	}

	/**
	 * For-statement While-element with Text Value Assignment.
	 * 
	 * <pre>
	 * 		For t:= &lt;TextExpr> while &lt;Cond> // Text Value Assignment
	 * </pre>
	 *
	 */
	public final class WhileTValElt extends ForElt {
		// For t:= <TextExpr> while <Cond> // Text Value Assignment
		/**
		 * The for-statement control variable.
		 */
		final RTS_NAME<RTS_TXT> cvar;
		/**
		 * A Text Value expression.
		 */
		final RTS_NAME<RTS_TXT> expr;
		/**
		 * The condition that determines whether to continue.
		 */
		RTS_NAME<Boolean> cond;

		/**
		 * Create Text Value While-element. 
		 * @param cvar the for-statement control variable
		 * @param expr a Text Value expression
		 * @param cond a Boolean expression
		 */
		public WhileTValElt(final RTS_NAME<RTS_TXT> cvar, final RTS_NAME<RTS_TXT> expr, final RTS_NAME<Boolean> cond) {
			this.cvar = cvar;
			this.expr = expr;
			this.cond = cond;
		}

		@Override
		public Boolean next() {
			RTS_TXT val = expr.get();
			_ASGTXT(cvar.get(), val);
			more = cond.get(); // IF not more return null - test i loopen: if(_CB==null) continue;
			return (more);
		}
	}

	// *****************************************
	// *** Text utilities ***
	// *****************************************
	/**
	 * Utility constant NOTEXT
	 */
	public final static RTS_TXT NOTEXT = new RTS_TXT();

	/**
	 * <pre>
	 * text procedure copy(T); text T;
	 *            if T =/= notext
	 *            then begin text U;
	 *               U.OBJ    :- new TEXTOBJ(T.LENGTH,false);
	 *               U.START  := 1;
	 *               U.LENGTH := T.LENGTH;
	 *               U.POS    := 1;
	 *               U        := T;
	 *               copy     :- U
	 *            end copy;
	 * </pre>
	 * 
	 * "copy(T)", with T =/= notext, references a new alterable main frame which
	 * contains a text value identical to that of T.
	 * 
	 * @param T the text object to be copied
	 * @return a copy of T
	 */
	public static RTS_TXT copy(final RTS_TXT T) {
		if (T == null)
			return (null);
		RTS_TXT U = blanks(T.LENGTH);
		_ASGTXT(U, T);
		return (U);
	}

	/**
	 * The operator &amp; permits text concatenation.
	 * 
	 * @param T1 the first text to be concatenated
	 * @param T2 the second text to be concatenated
	 * @return  the concatenated text
	 */
	public RTS_TXT CONC(RTS_TXT T1, RTS_TXT T2) {
		if (T1 == null)
			T1 = NOTEXT;
		if (T2 == null)
			T2 = NOTEXT;
		RTS_TXT U = blanks(RTS_TXT.length(T1) + RTS_TXT.length(T2));
		_ASGTXT(RTS_TXT.sub(U, 1, RTS_TXT.length(T1)), T1);
		_ASGTXT(RTS_TXT.sub(U, 1 + RTS_TXT.length(T1), RTS_TXT.length(T2)), T2);
		return (U);
	}

	/**
	 * <pre>
	 * text procedure blanks(n); integer n;
	 *            if        n &lt; 0 then error("..." ! Parm. to blanks &lt; 0;)
	 *            else if   n > 0
	 *            then begin text T;
	 *               T.OBJ    :- new TEXTOBJ(n,false);
	 *               T.START  := 1;
	 *               T.LENGTH := n;
	 *               T.POS    := 1;
	 *               T        := notext;    ! blank-fill, see 4.1.2;
	 *               blanks   :- T
	 *            end blanks;
	 * </pre>
	 * 
	 * "blanks(n)", with n > 0, references a new alterable main frame of length n,
	 * containing only blank characters. "blanks(0)" references notext.
	 * 
	 * @param n the number of space characters
	 * @return a text object conraining n space characters
	 */
	public static RTS_TXT blanks(final int n) {
		if (n < 0)
			throw new RTS_SimulaRuntimeError("Parmameter to blanks < 0");
		if (n == 0)
			return (NOTEXT);
		RTS_TXT textRef = new RTS_TXT();
		RTS_TEXTOBJ textObj = new RTS_TEXTOBJ(n, false);
		textObj.fill(' ');
		textRef.START = 0; // Note: Counting from zero in this implementation
		textRef.LENGTH = n;
		textRef.POS = 0; // Note: Counting from zero in this implementation
		textRef.OBJ = textObj;
		return (textRef);
	}

	/**
	 * Text value assignment.
	 * @param T the from text
	 * @param U the target text
	 * @return the resulting text
	 */
	public static RTS_TXT _ASGTXT(RTS_TXT T, RTS_TXT U) {
		if (T == null)
			T = NOTEXT;
		if (U == null)
			U = NOTEXT;
		int fromLength = U.LENGTH;
		if (fromLength > T.LENGTH)
			throw (new RTS_SimulaRuntimeError(
					"RHS too long in text value assignment: RHS.length=" + T.LENGTH + ", LHS.length=" + fromLength));
		for (int i = 0; i < fromLength; i++)
			T.OBJ.MAIN[T.START + i] = U.OBJ.MAIN[U.START + i];
		for (int i = fromLength; i < T.LENGTH; i++)
			T.OBJ.MAIN[T.START + i] = ' ';
		return (T);
	}

	/**
	 * Text value assignment from String.
	 * @param T the from text
	 * @param s the target text
	 * @return the resulting text
	 */
	public RTS_TXT _ASGSTR(RTS_TXT T, final String s) {
		if (T == null)
			T = NOTEXT;
		int fromLength = 0;
		if (s != null)
			fromLength = s.length();
		if (fromLength > T.LENGTH)
			throw (new RTS_SimulaRuntimeError(
					"RHS too long in text value assignment: RHS.length=" + T.LENGTH + ", LHS.length=" + fromLength));
		for (int i = 0; i < fromLength; i++)
			T.OBJ.MAIN[T.START + i] = s.charAt(i);
		for (int i = fromLength; i < T.LENGTH; i++)
			T.OBJ.MAIN[T.START + i] = ' ';
		return (T);
	}

	// **************************************************************
	// *** TXTREL - Text value relations
	// **************************************************************
	/**
	 * Text value relation - LT
	 * @param left left hand side
	 * @param right right hand side
	 * @return true if relation holds
	 */
	public static boolean _TXTREL_LT(final RTS_TXT left, final RTS_TXT right) {
		return (TXTREL(left, right, 1));
	}

	/**
	 * Text value relation - EQ
	 * @param left left hand side
	 * @param right right hand side
	 * @return true if relation holds
	 */
	public boolean _TXTREL_EQ(final RTS_TXT left, final RTS_TXT right) {
		return (TXTREL(left, right, 2));
	}

	/**
	 * Text value relation - LE
	 * @param left left hand side
	 * @param right right hand side
	 * @return true if relation holds
	 */
	public boolean _TXTREL_LE(final RTS_TXT left, final RTS_TXT right) {
		return (TXTREL(left, right, 3));
	}

	/**
	 * Text value relation - GT
	 * @param left left hand side
	 * @param right right hand side
	 * @return true if relation holds
	 */
	public boolean _TXTREL_GT(final RTS_TXT left, final RTS_TXT right) {
		return (TXTREL(left, right, 4));
	}

	/**
	 * Text value relation - NE
	 * @param left left hand side
	 * @param right right hand side
	 * @return true if relation holds
	 */
	public boolean _TXTREL_NE(final RTS_TXT left, final RTS_TXT right) {
		return (TXTREL(left, right, 5));
	}

	/**
	 * Text value relation - GE
	 * @param left left hand side
	 * @param right right hand side
	 * @return true if relation holds
	 */
	public boolean _TXTREL_GE(final RTS_TXT left, final RTS_TXT right) {
		return (TXTREL(left, right, 6));
	}

	/**
	 * Text value relation
	 * @param left left hand side
	 * @param right right hand side
	 * @param code relational code
	 * @return true if relation holds
	 */
	private static boolean TXTREL(RTS_TXT left, RTS_TXT right, int code) {
		int i; // Loop index.
		int dif; // Difference between lengths.
		int lng; // Length of common parts.
		if (left == null)
			left = NOTEXT;
		if (right == null)
			right = NOTEXT;
		lng = right.LENGTH;
		dif = lng - left.LENGTH;
		if (dif != 0) {
			if (code == 2)
				return (false);
			if (code == 5)
				return (true);
			if (dif > 0)
				lng = left.LENGTH;
		}
		i = 0;
		while (i < lng) {
			int rightChar = right.OBJ.MAIN[right.START + i];
			int leftChar = left.OBJ.MAIN[left.START + i];
			if (rightChar != leftChar) {
				dif = rightChar - leftChar;
				break;
			}
			i = i + 1;
		}
		switch (code) {
		case 1:
			return (0 < dif);
		case 2:
			return (0 == dif);
		case 3:
			return (0 <= dif);
		case 4:
			return (0 > dif);
		case 5:
			return (0 != dif);
		case 6:
			return (0 >= dif);
		default:
			throw new RTS_SimulaRuntimeError("Internal Error");
		}
	}

	// **************************************************************
	// *** TXTREL - Text reference relations. == =/=
	// **************************************************************
	/**
	 * Text reference equal relation
	 * @param left left hand side
	 * @param right right hand side
	 * @return true if relation holds
	 */
	public boolean TRF_EQ(RTS_TXT left, RTS_TXT right) {
		if (left == null)
			left = NOTEXT;
		if (right == null)
			right = NOTEXT;
		if (left.LENGTH != right.LENGTH)
			return (false);
		if (left.START != right.START)
			return (false);
		if (left.OBJ != right.OBJ)
			return (false);
		return (true);
	}

	/**
	 * Text reference not equal relation
	 * @param left left hand side
	 * @param right right hand side
	 * @return true if relation holds
	 */
	public boolean TRF_NE(final RTS_TXT left, final RTS_TXT right) {
		return (!TRF_EQ(left, right));
	}

	// **************************************************************
	// *** USED IN CONDITIONAL STATEMENT TO PREVENT DEAD-CODE REMOVAL
	// **************************************************************
	/**
	 * Used in Conditional Statement to prevent 'dead code removal'.
	 * @param cond a boolean condition
	 * @return the same conditional
	 */
	public boolean _VALUE(boolean cond) {
		return (cond);
	}

	// ************************************************************
	// *** lOCAL JUMP/LABEL - Meant for Byte-Code Engineering
	// ************************************************************
	/**
	 * Method meant for Byte-Code Engineering.
	 * <br>
	 * During Byte-Code Engineering this method-call is used to signal the occurrence of a Simula Label.
	 */
	public static void _PRE_LABEL() {
		// Local LABEL - Needs ByteCode Engineering.
	}

	// ************************************************************
	// *** lOCAL JUMP/LABEL - Meant for Byte-Code Engineering -- TODO: OLD VERSION
	// ************************************************************
	/**
	 * Method meant for Byte-Code Engineering.
	 * <br>
	 * During Byte-Code Engineering this method-call is used to signal the occurrence of a Simula Label.
	 * The bytecode address is collected and some instruction are removed.
	 * The parameter 'labelIndex' is the label's ordinal number.
	 * <p>deprecated
     * This method will be removed when java.lang.classfile becomes available.
     * @param labelIndex the label's ordinal number.
	 * @param ident the label's identifier
	 */
	public static void _LABEL(final int labelIndex, final String ident) {
		// Local LABEL - Needs ByteCode Engineering.
	}

	// ************************************************************
	// *** lOCAL JUMP/LABEL - Meant for Byte-Code Engineering
	// ************************************************************
	/**
	 * Method meant for Byte-Code Engineering.
	 * <br>
	 * During Byte-Code Engineering this method-call is used to signal the occurrence of a Simula Label.
	 * A pseudo label instruction is added some instruction are removed.
	 * The parameter 'labelIndex' is the label's ordinal number.
	 * @param labelIndex the label's ordinal number.
	 */
	public static void _SIM_LABEL(final int labelIndex) {
		// Local LABEL - Needs ByteCode Engineering.
	}

	/**
	 * Method meant for Byte-Code Engineering.
	 * <br>
	 * This method-call is a placeholder for where to put in a Jump-Table.
	 * <br>
	 * See <a href="doc/SimulaRTS.pdf">Mapping Simula to Java (runtime design)</a> 
	 * Sect. 6.1.2 Byte Code Engineering.
	 */
	public static void _PRE_TABLE() {}

	/**
	 * Method meant for Byte-Code Engineering.
	 * <br>
	 * This method-call is a placeholder for where to put in a Jump-Table.
	 * <br>
	 * See <a href="doc/SimulaRTS.pdf">Mapping Simula to Java (runtime design)</a> 
	 * Sect. 6.1.2 Byte Code Engineering.
	 * 
	 * @param labelIndex the label index
	 * @param tableSize the jumptable size
	 */
	public static void _JUMPTABLE(final int labelIndex,final int tableSize) {
		// Local GOTO - Needs ByteCode Engineering.
		if (RTS_COMMON.Option.GOTO_TRACING)
			RTS_COMMON.TRACE("_RTObject._JUMPTABLE: labelIndex=" + labelIndex);
		String msg = "FATAL ERROR: Local GOTO LABEL#" + labelIndex + " Needs ByteCode Engineering.";
		RTS_COMMON.println(msg);
		if (labelIndex == 0)
			return;
		RTS_COMMON.println(msg);
		throw new RTS_SimulaRuntimeError(msg);
	}
	
	// ************************************************************
	// *** lOCAL JUMP/LABEL - Meant for Byte-Code Engineering --  TODO: OLD VERSION
	// ************************************************************
	/**
	 * Method meant for Byte-Code Engineering.
	 * <p>deprecated
     * This method will be removed when java.lang.classfile becomes available.
	 * @param labelIndex the label index
	 */
	public static void _JUMPTABLE(final int labelIndex) {
		_JUMPTABLE(labelIndex,0);
	}
	
	// ************************************************************
	// *** FRAMEWORK for NonLocal Label-Parameters in Java Coding
	// ************************************************************
	/**
	 * This class represent a Simula Label quantity
	 *
	 */
	@SuppressWarnings("serial")
	public final class RTS_LABEL extends RuntimeException { // RuntimeError {
//		static final long serialVersionUID = 42L;
		/**
		 * Static link, i.e. the block in which the label is defined.
		 */
		public final RTS_RTObject _SL;
		/**
		 * Index, I.e. ordinal number of the Label within its Scope(staticLink).
		 */
		public final int index;
		/**
		 * Label identifier. To improve error and trace messages.
		 */
		public final String identifier; // To improve error and trace messages.

		// Constructor
		/**
		 * Create a label quantity
		 * @param _SL static link
		 * @param index label index
		 * @param identifier label identifier
		 */
		public RTS_LABEL(final RTS_RTObject _SL, final int index, final String identifier) {
			this._SL = _SL;
			this.index = index;
			this.identifier = identifier;
		}

		@Override
		public String toString() {
			return ("RTS_LABEL(" + _SL + ", LABEL#" + index + ", identifier=" + identifier + ')');
		}
	}

	// ************************************************************
	// *** _GOTO -- To avoid Java-error: "Unreachable code" after GOTO
	// ************************************************************
	/**
	 * Utility method to avoid Java-error: "Unreachable code" after GOTO
	 * @param q the RTS_LABEL
	 */
	public void _GOTO(final RTS_LABEL q) {
		if (RTS_COMMON.Option.GOTO_TRACING)
			RTS_COMMON.TRACE("_RTObject.GOTO: " + q);
		throw (q);
	}

	// ************************************************************
	// *** TRACING: TRACE_GOTO
	// ************************************************************
	/**
	 * Utility method to trace GOTO Statements
	 * @param msg a descriptive message
	 * @param label the label quant
	 */
	public static void TRACE_GOTO(final String msg, final RTS_LABEL label) {
		RTS_COMMON.TRACE(msg + " GOTO " + label);
	}

	// ************************************************************
	// *** UncaughtExceptionHandler
	// ************************************************************
	/**
	 * 
	 * UncaughtExceptionHandler
	 *
	 */
	public class UncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
		/**
		 * Current RTObject in which the exception occured.
		 */
		public final RTS_RTObject obj;

		/**
		 * Create an UncaughtExceptionHandler.
		 * @param obj the Current RTObject in which the exception occured.
		 */
		public UncaughtExceptionHandler(final RTS_RTObject obj) {
			this.obj = obj;
		}

		@Override
		public void uncaughtException(Thread thread, Throwable e) {
			String threadID = (RTS_COMMON.Option.VERBOSE) ? ("Thread:" + thread.getName() + '[' + obj + "]: ") : "";
			if (RTS_COMMON.Option.GOTO_TRACING) {
				RTS_COMMON.println(threadID + " throws exception: " + e);
				e.printStackTrace();
			}
			if (e instanceof RTS_LABEL) {
				if (RTS_COMMON.Option.GOTO_TRACING) {
					System.err.println("POSSIBLE GOTO OUT OF COMPONENT " + obj.edObjectAttributes());
					RTS_COMMON.println("POSSIBLE GOTO OUT OF COMPONENT " + obj.edObjectAttributes());
				}
				RTS_RTObject DL = obj._DL;
				if (DL != null && DL != _CTX) {
					if (RTS_COMMON.Option.GOTO_TRACING) {
						System.err.println("DL=" + DL.edObjectAttributes());
						RTS_COMMON.println("DL=" + DL.edObjectAttributes());
					}
					RTS_Coroutine._PENDING_EXCEPTION = (RuntimeException) e;
					DL._CORUT.run();
				} else {
					String msg = "Illegal GOTO " + ((RTS_LABEL) e).identifier;
					if (RTS_ENVIRONMENT.EXCEPTION_HANDLER != null)
						treatRuntimeError(msg);
					RTS_COMMON.println(threadID + "SIMULA RUNTIME ERROR: " + msg);
					if (RTS_COMMON.Option.VERBOSE)
						e.printStackTrace();
					endProgram(-1);
				}
			} else if (e instanceof RuntimeException) {
				String msg = getErrorMessage(e);
				msg = msg.replace("RTS_SimulaRuntimeError: ", "");
				if (RTS_ENVIRONMENT.EXCEPTION_HANDLER != null)
					treatRuntimeError(msg);
				RTS_COMMON.printError(threadID + "SIMULA RUNTIME ERROR: " + msg);
				if (RTS_COMMON.Option.VERBOSE)
					e.printStackTrace();
				RTS_COMMON.printSimulaStackTrace(e, 0);
				endProgram(-1);
			} else if (e instanceof Error) {
				String msg = e.getClass().getSimpleName();
				RTS_COMMON.printError(threadID + "SIMULA RUNTIME ERROR: " + msg);
				RTS_COMMON.printSimulaStackTrace(e, 0);
				if (RTS_COMMON.Option.VERBOSE)
					e.printStackTrace();
				endProgram(-1);
			} else {
				RTS_COMMON.printError(threadID + "UNCAUGHT EXCEPTION: " + e.getMessage());
				e.printStackTrace();
				endProgram(-1);
			}
			if (RTS_COMMON.Option.GOTO_TRACING)
				RTS_COMMON.printThreadList();
		}

		/**
		 * Utility: Treat Runtime error
		 * @param msg the message
		 */
		private void treatRuntimeError(String msg) {
			RTS_PRCQNT erh = RTS_ENVIRONMENT.EXCEPTION_HANDLER;
			try {
				RTS_ENVIRONMENT.EXCEPTION_HANDLER = null;
				erh.CPF().setPar(new RTS_TXT(msg))._ENT();
			} catch (Throwable t) {
				RTS_COMMON.printError("EXCEPTION IN SIMULA EXCEPTION_HANDLER: " + t);
				RTS_COMMON.printError("EXCEPTION_HANDLER: " + erh);
				t.printStackTrace();
			}
		}
	}

	/**
	 * Utility to convert a Throwable message to Simula message.
	 * @param e a Throwable
	 * @return converted message
	 */
	public static String getErrorMessage(Throwable e) {
		String msg = e.getMessage();
		if (e instanceof NullPointerException)
			msg = "NONE-CHECK Failed";
		else if (e instanceof ArrayIndexOutOfBoundsException)
			msg = "ArrayIndexOutOfBounds";
		return (e.getClass().getSimpleName() + ": " + msg);
	}

	// ************************************************************
	// *** Procedure terminate_program;
	// *** begin ... ; goto STOP end terminate_program;
	// ************************************************************
	/**
	 * Implementation of Simula's Procedure terminate_program.
	 */
	public static void terminate_program() {
		endProgram(0);
	}

	// ************************************************************
	// *** BPRG -- Begin Program
	// ************************************************************
	/**
	 * The begin program routine (BPRG) is the runtime system initialization
	 * routine. It will initiate the global data in the runtime system.
	 * 
	 * @param ident the program identifier
	 */
	public void BPRG(final String ident) {
		startTimeMs = System.currentTimeMillis();
		Thread.currentThread().setUncaughtExceptionHandler(new UncaughtExceptionHandler(this));
		RTS_COMMON.progamIdent = ident;
		if (RTS_COMMON.Option.BLOCK_TRACING)
			RTS_COMMON.TRACE("Begin Execution of Simula Program: " + ident);
		if (_SYSIN == null) {
			if (RTS_COMMON.Option.USE_CONSOLE) {
				RTS_COMMON.console = new RTS_ConsolePanel();
				RTS_COMMON.console.popup("Runtime Console");
			}
			_SYSIN = new RTS_Infile(this, new RTS_TXT("#sysin"));
			_SYSOUT = new RTS_Printfile(this, new RTS_TXT("#sysout"));
			_SYSIN.open(blanks(_INPUT_LINELENGTH));
			_SYSOUT.open(blanks(_OUTPUT_LINELENGTH));
		}
		_CUR = this;
	}

	// ************************************************************
	// *** BBLK - Begin Block
	// ************************************************************
	/**
	 * This routine is used to initiate a block instance. Its functions are:
	 * <ul>
	 * <li>Attach the block to its dynamic environment.</li>
	 * <li>Update the current instance pointer(_CUR).</li>
	 * </ul>
	 */
	public void BBLK() {
		_DL = _CUR;
		_CUR = this;
		_CORUT = _DL._CORUT;
		_STATE = OperationalState.attached;
		if (RTS_COMMON.Option.BLOCK_TRACING)
			RTS_COMMON.TRACE("BEGIN " + edObjectAttributes());
		if (_SL == null) {
			throw new RTS_SimulaRuntimeError("NONE-CHECK FAILED: Remote Call on Procedure x.proc, x==none");
		}
	}

	// *********************************************************************
	// *** EBLK - End Block
	// *********************************************************************
	/**
	 * End Block.
	 * <p>
	 * This routine is used to terminate a block instance when control passes
	 * through the final end (of the outermost prefix for class and prefixed block).
	 * <p>
	 * According to the different categories of block instances, we have the
	 * following cases:
	 * <ul>
	 * <li>Terminate prefixed block instance.
	 * <p>
	 * Update the '_CUR' pointer and return to Compiler generated code.</li>
	 * <li>Terminate class instance.
	 * <p>
	 * The object is marked 'terminated' and the '_CUR' pointer is updated.</li>
	 * </ul>
	 * If the class instance is detached: The instance is marked as terminated. The
	 * sub-block or prefixed block representing the quasiparallel system of which
	 * the instance was a component is located. The main program of the system is
	 * then 'resumed'.
	 * <p>
	 * Finally; Yield continuation and return to Compiler generated code.
	 * <p>
	 * However; If the program passes through its final end sysout.outimage is
	 * called. The the entire program is terminated.
	 */
	public void EBLK() {
		switch (_STATE) {
		case attached -> {
			if (RTS_COMMON.Option.BLOCK_TRACING)
				RTS_COMMON.TRACE("END ATTACHED BLOCK " + edObjectAttributes());
			_STATE = OperationalState.terminated;
			_CUR = _DL; // Make the dynamic enclosure the new current instance.
		}
		case resumed -> {
			// Treat the case of a resumed and operating object.
			// It is the head of an object component. The class
			// object enters the terminated state, and the object component
			// disappears from its system. The main component of that system
			// takes its place as the operating component of the system.
			// Invariant: _CUR._STATE = resumed and _CUR.DL = main.SL
			_STATE = OperationalState.terminated;
			// Find main component (and system) head. It must be the static
			// enclosure since the object has been RESUMEd.
			RTS_RTObject main = _SL;
			// The main component becomes the operating component.
			RTS_RTObject dl = _DL;
			_DL = null;
			_CUR = main._DL;
			main._DL = dl;
			if (RTS_COMMON.Option.BLOCK_TRACING)
				RTS_COMMON.TRACE("END COMPONENT " + edObjectAttributes());
		}
		case terminatingProcess -> {
			if (RTS_COMMON.Option.BLOCK_TRACING)
				RTS_COMMON.TRACE("TERMINATING PROCESS " + edObjectAttributes());
			_STATE = OperationalState.terminated;
			_CORUT = null; // Leave it to the GarbageCollector
			return; // Let this Continuation R.I.P.
		}
		default -> throw new RTS_SimulaRuntimeError("_RTObject.EBLK: Internal Error " + edObjectAttributes());
		}
		if (_CUR == null || _CUR == _CTX) {
			if (RTS_COMMON.Option.BLOCK_TRACING)
				RTS_COMMON.TRACE("PROGRAM PASSES THROUGH FINAL END " + edObjectAttributes());
			endProgram(0);
		} else {
			if (this._CORUT != null && this.isDetachUsed()) {
				RTS_Coroutine.detach();
			}
		}
	}

	// *********************************************************************
	// *** QUASI PARALLEL SEQUENCING
	// *********************************************************************

	// *********************************************************************
	// *** DETACH - See Simula Standard 7.3.1 Detach
	// *********************************************************************
	/**
	 * Standard procedure 'detach'.
	 * <p>
	 * Consider a call of the detach attribute of a block instance X.
	 * <p>
	 * If X is an instance of a prefixed block the detach statement has no effect.
	 * Assume that X is a class object. The following cases arise:
	 * <ol>
	 * <li>X is an attached object.<br>
	 * If X is not operating the detach statement constitutes an error. Assume X is
	 * operating. The effect of the detach statement is:
	 * <ul>
	 * <li>X becomes detached and thereby (the head of) a new non-operative object
	 * component, its reactivation point positioned immediately after the detach
	 * statement. As a consequence, that part of the operating chain which is
	 * dynamically enclosed by X becomes the (non-operating) reactivation chain of
	 * X.
	 * 
	 * <li>The PSC returns to the block instance to which X was attached and
	 * execution continues immediately after the associated object generator or call
	 * statement (see 7.3.2).
	 * </ul>
	 * If X is local to a system head, the new component becomes a member of the
	 * associated system. It is a consequence of the language definition that, prior
	 * to the execution of the detach statement, X was dynamically enclosed by the
	 * head of the operative component of this system. The operative component
	 * remains operative.
	 * 
	 * <li>X is a detached object.<br>
	 * The detach statement then constitutes an error.
	 * 
	 * <li>X is a resumed object.<br>
	 * X is then (the head of) an operative system component. Let S be the
	 * associated system. It is a consequence of the language definition that X must
	 * be operating. The effect of the detach statement is:
	 * <ul>
	 * <li>X enters the detached state and becomes non-operative, its reactivation
	 * point positioned immediately after the detach statement. As a consequence,
	 * that part of the operating chain which is dynamically enclosed by X becomes
	 * the (non-operating) reactivation chain of X.
	 * 
	 * <li>The PSC is moved to the current reactivation point of the main component
	 * of S, whereby this main component becomes operative and operating. As a
	 * consequence, all block instances on the reactivation chain of the main
	 * component also become operating.
	 * </ul>
	 * <li>X is a terminated object.<br>
	 * The detach statement then constitutes an error.
	 * </ol>
	 */
	public void detach() {
		// if (_RT.Option.QPS_TRACING) _RT.TRACE("BEGIN DETACH " + this.edObjectIdent() + " ==> " + _CUR.edObjectIdent());
		if (isQPSystemBlock())
			return; // Detach QPS System Block is no-operation.
		// Make sure that this object is on the operating chain.
		// Note that a detached or terminated object cannot be on the operating chain.
		RTS_RTObject dl = _CUR;
		while (dl != this) {
			dl = dl._DL;
			if (dl == null)
				throw new RTS_SimulaRuntimeError("x.Detach: x is not on the operating chain.");
		}
		switch (this._STATE) {
		case resumed -> {
			// Find main component for component to be detached. The main
			// component head must be the static enclosure of the object.
			RTS_RTObject main = this._SL;
			// Rotate the contents of '_CUR', 'this._DL' and 'main._DL'.
			// <main._DL,this._DL,_CUR> := <this._DL,_CUR,main._DL>
			dl = main._DL;
			main._DL = this._DL;
			this._DL = _CUR;
			_CUR = dl;
		}
		case attached -> {
			// Swap the contents of object's 'this._DL' and '_CUR'.
			// <this._DL,_CUR> := <_CUR,this._DL>
			dl = this._DL;
			this._DL = _CUR;
			_CUR = dl;
		}
		default -> throw new RTS_SimulaRuntimeError("Illegal Detach");
		}
		this._STATE = OperationalState.detached;

		if (RTS_COMMON.Option.QPS_TRACING)
			RTS_COMMON.TRACE("DETACH " + this.edObjectIdent() + " ==> " + _CUR.edObjectIdent());
		RTS_Coroutine.detach();
	}

	/**
	 * See {@link RTS_RTObject#detach()}
	 * @param SL The object to be Detached
	 */
	public static void detach(RTS_RTObject SL) {
		SL.detach();
	}
	
	/**
	 * See {@link RTS_RTObject#detach()}
	 * @param sourceLine the sourceline of the call
	 */
	public void detach(int sourceLine) {
		if (RTS_COMMON.Option.QPS_TRACING)
			RTS_COMMON.TRACE("LINE " + sourceLine + ": BEGIN DETACH " + this.edObjectIdent() + " ==> " + _CUR.edObjectIdent());
		detach();
		if (RTS_COMMON.Option.QPS_TRACING)
			RTS_COMMON.TRACE("LINE " + sourceLine + ": DETACH(" + this.edObjectIdent() + ") CONTINUE IN "
					+ _CUR.edObjectIdent());
	}


	// *********************************************************************
	// *** CALL - See Simula Standard 7.3.1 Call
	// *********************************************************************
	/**
	 * Standard procedure 'call'.
	 * <p>
	 * "call" is formally a procedure with one object reference parameter qualified
	 * by a fictitious class 'CLASS' including all classes. Let Y denote the object
	 * referenced by a call statement.
	 * 
	 * <p>
	 * If Y is terminated, attached or resumed, or Y == none, the call statement
	 * constitutes an error.
	 * 
	 * <p>
	 * Assume Y is a detached object. The effect of the call statement is:
	 * <ul>
	 * <li>Y becomes attached to the block instance containing the call statement,
	 * whereby Y loses its status as a component head. As a consequence the system
	 * to which Y belongs (if any) loses the associated component.
	 * 
	 * <li>The PSC is moved to the (former) reactivation point of Y. As a
	 * consequence, all block instances on the reactivation chain of Y become
	 * operating.
	 * </ul>
	 * 
	 * @param ins The object to be Called (Coroutine)
	 */
	public void call(final RTS_RTObject ins) {
		RTS_RTObject dl; // Temporary reference to dynamic enclosure.
		if (ins == null)
			throw new RTS_SimulaRuntimeError("Call(x): x is none.");
		if (ins._STATE != OperationalState.detached)
			throw new RTS_SimulaRuntimeError("Call(x): x is not in detached state.");
		// The object to be attached cannot be on the operating chain,
		// because then its state would have been resumed and not detached.

		// Swap the contents of '_CUR' and object's 'dl'.
		// <ins._DL,_CUR>:=<_CUR,ins._DL>;
		dl = ins._DL;
		ins._DL = _CUR;
		_CUR = dl;
		// From now on the object is in attached state.
		// It is no longer a component head.
		ins._STATE = OperationalState.attached;
		// if (_RT.Option.QPS_TRACING) _RT.TRACE("CALL " + this.edObjectIdent() + " ==>
		// " + _CUR.edObjectIdent());
		swapCoroutines();
	}
	
	/**
	 * See {@link RTS_RTObject#call(RTS_RTObject)}
	 * @param ins The object to be Called (Coroutine)
	 * @param sourceLine the sourceline of the call
	 */
	public void call(final RTS_RTObject ins, int sourceLine) {
		if (RTS_COMMON.Option.QPS_TRACING)
			RTS_COMMON.TRACE("LINE " + sourceLine + ": BEGIN CALL " + this.edObjectIdent() + " ==> " + _CUR.edObjectIdent());
		call(ins);
		if (RTS_COMMON.Option.QPS_TRACING)
			RTS_COMMON.TRACE(
					"LINE " + sourceLine + ": CALL(" + this.edObjectIdent() + ") CONTINUE IN " + _CUR.edObjectIdent());
	}


	// *********************************************************************
	// *** RESUME - See Simula Standard 7.3.1 Resume
	// *********************************************************************
	/**
	 * <p>
	 * "resume" is formally a procedure with one object reference parameter
	 * qualified by a fictitious class 'CLASS' including all classes. Let Y denote
	 * the object referenced by a resume statement.
	 * 
	 * <p>
	 * If Y is not local to a system head, i.e. if Y is local to a class object or
	 * an instance of a procedure body, the resume statement constitutes an error.
	 * 
	 * <p>
	 * If Y is terminated or attached, or Y==none, the resume statement constitutes
	 * an error.
	 * 
	 * <p>
	 * If Y is a resumed object, the resume statement has no effect (it is a
	 * consequence of the language definition that Y must then be operating.)
	 * 
	 * <p>
	 * Assume Y is a detached object being (the head of) a non-operative system
	 * component. Let S be the associated system and let X denote (the head of) the
	 * current operative component of S. It is a consequence of the language
	 * definition that X must be operating, and that X is either the main component
	 * of S or local to the head of S. The effect of the resume statement is:
	 * <ul>
	 * <li>X becomes non-operative, its reactivation point positioned immediately
	 * after the resume statement. As a consequence, that part of the operating
	 * chain which is dynamically enclosed by X becomes the (non-operating)
	 * reactivation chain of X. If X is an object component its head enters the
	 * detached state.
	 * 
	 * <li>The PSC is moved to the reactivation point of Y, whereby Y enters the
	 * resumed state and becomes operative and operating. As a consequence, all
	 * block instances on the reactivation chain of Y also become operating.
	 * </ul>
	 * 
	 * @param ins The object to be Resumed
	 */
	public void resume(final RTS_RTObject ins) {
		resume(ins, true); // Normal Case
	}

	/**
	 * See {@link RTS_RTObject#resume(RTS_RTObject)}
	 * @param ins The object to be Resumed
	 * @param sourceLine the sourceline of the call
	 */
	public void resume(final RTS_RTObject ins, int sourceLine) {
		if (RTS_COMMON.Option.QPS_TRACING)
			RTS_COMMON.TRACE("LINE " + sourceLine + ": BEGIN RESUME " + this.edObjectIdent() + " ==> " + _CUR.edObjectIdent());
		resume(ins);
	}

	/**
	 * See {@link RTS_RTObject#resume(RTS_RTObject)}
	 * @param ins The object to be Resumed
	 * @param doSwap decides whether Coroutines should be swapped
	 */
	public void resume(final RTS_RTObject ins, boolean doSwap) {
		RTS_RTObject comp; // Component head.
		RTS_RTObject mainSL; // Static enclosure of main component head.
		RTS_RTObject main; // The head of the main component and also
						// the head of the quasi-parallel system.
		if (ins == null)
			throw new RTS_SimulaRuntimeError("Resume(x): x is none.");

		if (ins._STATE != OperationalState.resumed) { // A no-operation?
			// The object to be resumed must be local to a system head.
			main = ins._SL;
			if (!main.isQPSystemBlock())
				throw new RTS_SimulaRuntimeError("Resume(x): x is not local to sub-block or prefixed block.");
			if (ins._STATE != OperationalState.detached)
				throw new RTS_SimulaRuntimeError("Resume(x): x is not in detached state but " + ins._STATE);
			// Find the operating component of the quasi-parallel system.
			comp = _CUR;
			mainSL = main._SL;
			while (comp._DL != mainSL)
				comp = comp._DL;
			if (comp._STATE == OperationalState.resumed)
				comp._STATE = OperationalState.detached;
			// Rotate the contents of 'ins.dl', 'comp.dl' and '_CUR'.
			// Invariant: comp._DL = mainSL
			// <ins._DL,comp._DL,_CUR>=<comp._DL,_CUR,ins._DL>
			comp._DL = _CUR;
			_CUR = ins._DL;
			ins._DL = mainSL;
			ins._STATE = OperationalState.resumed;
			if (RTS_COMMON.Option.QPS_TRACING)
				RTS_COMMON.TRACE("RESUME " + this.edObjectIdent() + " ==> " + _CUR.edObjectIdent());
			if (doSwap)
				swapCoroutines();
		}
	}

	/**
	 * Method representing the Statements in this Block
	 * <br>
	 * This method is virtual and must be redefined in blocks.
	 * @return a pointer to this _RTObject
	 */
	public RTS_RTObject _STM() {
		return (this);
	}

	// *********************************************************************
	// *** endProgram
	// *********************************************************************
	/**
	 * End of Simula program execution.
	 * @param exitValue the exit value
	 */
	private static void endProgram(final int exitValue) {
		// _SYSIN.close();
		// _SYSOUT.close();
		_SYSOUT.outimage();
		long timeUsed = System.currentTimeMillis() - startTimeMs;
		if (RTS_COMMON.Option.VERBOSE) {
			RTS_COMMON.println("\nEnd program: " + RTS_COMMON.progamIdent);
			if (RTS_COMMON.numberOfEditOverflows > 0)
				RTS_COMMON.println(" -  WARNING " + RTS_COMMON.numberOfEditOverflows + " EditOverflows");
			Runtime runtime = Runtime.getRuntime();
			RTS_COMMON.println(" -  Memory(used=" + runtime.totalMemory() + ",free=" + runtime.freeMemory() + ')');
			RTS_COMMON.println(" -  nProcessors=" + runtime.availableProcessors());
			RTS_COMMON.println(" -  Elapsed Time Approximately " + timeUsed / 1000 + " sec.");
		} else if (RTS_COMMON.numberOfEditOverflows > 0)
			RTS_COMMON.println("End program: WARNING " + RTS_COMMON.numberOfEditOverflows + " EditOverflows");
		if (RTS_COMMON.console == null)
			System.exit(exitValue);
	}

	// *********************************************************************
	// *** swapCoroutines
	// *********************************************************************
	/**
	 * Utility: Swap Coroutines.
	 */
	static void swapCoroutines() {
		RTS_Coroutine cont = RTS_Coroutine.getCurrentCoroutine();
		// if(_RT.Option.QPS_TRACING) _RT.TRACE("SWAP: CURRENT= "+cont);
		if (cont == null) {
			cont = _CUR._CORUT;
			RTS_RTObject next = _CUR;
			while (next._CORUT != null) {
				// if(_RT.Option.QPS_TRACING) _RT.TRACE("SWAP: RUN NEXT "+next);
				next._CORUT.run();
				// Return here when Coroutine is Detached or Done
				next = _CUR;
				// if(_RT.Option.QPS_TRACING) _RT.TRACE("SWAP: RUN RETURNED "+next);
			}
		} else {
			// if(_RT.Option.QPS_TRACING) _RT.TRACE("SWAP: YIELD "+cont);
			RTS_Coroutine.detach();
		}
	}

	// *********************************************************************
	// *** TRACING AND DEBUGGING UTILITIES
	// *********************************************************************

	/**
	 * Utility to support trace and debugging.
	 * <p>
	 * An edited string identifier of the static link object is formed.
	 * @param staticLink a reference to the static link object
	 * @return an edited string 
	 */
	public static RTS_TXT objectTraceIdentifier(final RTS_RTObject staticLink) {
		return (new RTS_TXT(staticLink.edObjectIdent()));
	}

	/**
	 * Utility to support trace and debugging.
	 * <p>
	 * An edited string identifier of this object is formed.
	 * @return an edited string 
	 */
	public RTS_TXT objectTraceIdentifier() {
		return (new RTS_TXT(edObjectIdent()));
	}

	/**
	 * Utility to support trace and debugging.
	 * <p>
	 * An edited string identifier of this object's class is formed.
	 * @return an edited string 
	 */
	public String edObjectIdent() {
		StringBuilder s = new StringBuilder();
		s.append(this.getClass().getSimpleName());
		return (s.toString());
	}

	/**
	 * Utility to support trace and debugging.
	 * <p>
	 * An edited string identifier of this object's main attributes is formed.
	 * @return an edited string 
	 */
	public String edObjectAttributes() {
		StringBuilder s = new StringBuilder();
		s.append(edObjectIdent());
		s.append(" SL=").append((_SL == null) ? "null" : _SL.edObjectIdent());
		s.append(" DL=").append((_DL == null) ? "null" : _DL.edObjectIdent());
		s.append(" STATE=").append(_STATE);
		s.append(" CORUT=").append(_CORUT);
		s.append(" CUR=").append(_CUR);
		return (s.toString());
	}

//	public void printStaticContextChain() {
//		_RTObject x = this;
//		_RT.println("STATIC CONTEXT CHAIN:");
//		while (x != null) {
//			_RT.println(" - " + x.edObjectAttributes());
//			x = x._SL;
//		}
//	}

	/**
	 * Returns a string representation of the object.
	 */
	@Override
	public String toString() {
		return (edObjectIdent());
	}

}