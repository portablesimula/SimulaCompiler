External class CHECKER2;

CHECKER2 class SCODER0;
%      -----------------------------------------------------------------
%      ---  COPYRIGHT 1988 by                                        ---
%      ---  Simula a.s.                                              ---
%      ---  Oslo, Norway                                             ---
%      ---                                                           ---
%      ---                 P O R T A B L E     S I M U L A           ---
%      ---              F R O N T - E N D    C O M P I L E R         ---
%      ---      S - C o d e    G e n e r a t o r     P a r t  0.     ---
%      ---                                                           ---
%      --- Selection switches: IZ                                    ---
%      ---                                                           ---
%      ---    'D' Included when dump is wanted                       ---
%      ---    'K' Included always when quick capability wanted       ---
%      ---    'M' Included always when macro capability wanted       ---
%      ---    'P' Included to make compiler use quick procedures     ---
%      ---    'I' Included to make compiler use inserted mnemonics   ---
%      ---    'Z' Included at system generation (for "ZIMULA")       ---
%      ---                                                           ---
%      -----------------------------------------------------------------

%SELECT Z

begin

%SPORT ON
%REUSE ON
%-Z %RECORD ON

%+I %INSERT $SIMSRC/fec/common.mne

% INSERT $SIMSRC/fec/scoder.mne
%INSERT C:/GitHub/SimulaCompiler/Simula/src/sportFEC/sim/scoder.mne

%+I %INSERT $SPORTLIB/rtsinit.mne

      visiblegenerator class codegenerator0;
      begin ref(semchecker) checker;

         short integer maxtagstack; ! Upper bound of tagstack ;

%title ******   Conversion FEC representation => RTS repr.   ******

%      for several of the arrays, Z-selection will set the exact bounds;
%      NOTE: IELSE is "legal" type (to avoid index errors in case of
%            type errors detected in checker)
%            rank(IELSE) = 15 !!!

%+Z      short integer array arr1elttag(1:15);
%+Z      short integer array arr2elttag(1:15);
%+Z      short integer array arr3elttag(1:15);
%-Z      short integer       arr1elttag(  15);
%-Z      short integer       arr2elttag(  15);
%-Z      short integer       arr3elttag(  15);
         ! *** legal: SIMULA types (1-dim, 2-dim, multi-dim) ***;

%+Z      short integer array typetag(1:15);
%-Z      short integer       typetag(  15);
         !*** legal: SIMULA types + IVALU ***;

%+Z      short integer array type_pro_tag(1:15);
%-Z      short integer       type_pro_tag(  15);
         ! *** legal: SIMULA types ***;
         ! Gives tag of the type procedure records defined
           in RTS, which are to be used as prefix for
           a type procedure record generated by FEC ;

%+Z      short integer array e_fnp_ass1(1:15);
%+Z      short integer array e_fnp_ass2(1:15);
%-Z      short integer       e_fnp_ass1(  15);
%-Z      short integer       e_fnp_ass2(  15);
         ! *** legal: SIMULA types ***;
         ! Gives the profile/body tag of the routine Enp<type> ;

%+Z      short integer array e_fnp_acc1(1:15);
%+Z      short integer array e_fnp_acc2(1:15);
%-Z      short integer       e_fnp_acc1(  15);
%-Z      short integer       e_fnp_acc2(  15);
         !*** legal: SIMULA types ***;
         ! Gives the profile/body tag of the routine Enc<type> ;

%+Z      short integer array resulttag(1:15);
%-Z      short integer       resulttag(  15);
         ! *** legal: SIMULA types ***;
         ! Gives tag of the record attribute <type>pro.val ;

%+Z      short integer array quantvarianttag(1:15);
%-Z      short integer       quantvarianttag(  15);
         ! *** legal: SIMULA types + ILABE, PROC, ARRA ;
         ! Gives tag of the attribute in some of the variants
           of the record quant defined in RTS ;

%+Z     short integer array fnp_pro_1(3:6 !ISHOR:ILONG; );
%+Z     short integer array fnp_pro_2(3:6 !ISHOR:ILONG; );
%-Z     short integer       fnp_pro_1(  6);
%-Z     short integer       fnp_pro_2(  6);
         ! *** legal: arithmetic types ***;
         ! Give profile/body tag of the routine FNP_PRO_<type> ;

%+Z      short integer array litpardesvarianttag(1:15);
%-Z      short integer       litpardesvarianttag(  15);
         !*** legal: SIMULA types ***;

%+Z      short integer array fpt_profile(1:15);
%+Z      short integer array fpt_body   (1:15);
%-Z      short integer       fpt_profile(  15);
%-Z      short integer       fpt_body   (  15);
         !*** legal: SIMULA types ***;

%+Z      text array followSL(0:5);
%-Z      text       followSL(  5);
         !*** the most common values of "staticencl" ***;

%-I %INSERT $SPORTLIB/rtsinit.dcl
% - contains declarations to be visible within the code generator
%title ****** the "assembly stack" with connected procedures ******

%+Z      short integer array asdstack(0:maxasd); !zero never used;
%-Z      character           asdstack(  31    ); !zero never used;
         ! character asd,curasd - declared in visiblegenerator;
         ! asd is top of asdstack - NOTE: asd<>0 => save/restore;

%-I %+PQ     prior
%-I          procedure pushasd;
%-I          ! Called from outbseg, outskipif, outif, expandsave;
%-I          begin
%-I                if curasd >= maxasd then fatal0(246) else
%-I                begin curasd:=curasd+1; asdstack(curasd):=asd end;
%-I          end;

%-I %+PQ     prior
%-I          procedure popasd;
%-I          ! Called from outeseg, outendskip, outendif, expandrestore;
%-I          begin asd:=asdstack(curasd);
%-I                curasd:=curasd-1 end;

%-I %+PQ prior
%-I      procedure checkasdzero;
%-I      ! Called from outeseg, outempty, outendskip, outlabeldef,
%-I        outgoto, outfjumpif, outfdest, setbdest (outbdest), outbjump,
%-I        expandrestore ;
%-I      begin
%-I      if asd <> 0 then asderror(176);
%-I      end;

%-I %+PQ     prior
%-I          procedure checkequalandpop;
%-I          begin if asd <> asdstack(curasd) then asderror(177);
%-I                asd:=asdstack(curasd); curasd:=curasd-1;
%-I          end;
%title ******   The system for handling indices   *******

         !*** NOTE: the index zero must NOT be used ***;
%+Z      short integer array indexused(0:255 !max_index;);
%-Z      character           indexused(  255 !max_index;);

%+Z      short integer curindex;  !last generated index;
%+Z      short integer freeindex; !next available;
%-Z      character     curindex;  !last generated index;
%-Z      character     freeindex; !next available;

%-I %+PQ     prior
%-I          procedure getnewindex;
%-I          begin ! short integer i,j;
%-I              if freeindex<>zero then begin
%-I                 curindex:=freeindex; freeindex:=indexused(freeindex)
%-I              end else
%-I              fatal0(249); !all indices used;
%-I   EXIT: end;

%+PQ     prior
         boolean procedure nonewindex;
         begin
%+Z            short integer i,j;
%-Z            character     i,j;
%+S            Freq(112):=Freq(112)+1;
               j:=10; !leave at least 10 free;
               i:=freeindex;
               while j<>zero do begin
                  if i=zero then begin nonewindex:=true; goto EXIT end;
                  j:=j-1; i:=indexused(i);
               end;
               nonewindex:=false;
               curindex:=freeindex; freeindex:=indexused(freeindex);
   EXIT: end;

%-I      procedure releaseIndex(index); short integer index;
%-I      begin indexused(index):=freeindex; freeindex:=index end;
%title *****   utilities that should NEVER be swapped   *****

%-I %+PQ     prior
%-I          procedure outtag(t); short integer t;
%-I          begin out2byte(t);
%-I          end;

%+PQ     prior
         procedure outsint(i); short integer i;
         begin ! Outputs a positive short integer constant;
%+S            Freq(107):=Freq(107)+1;
               if i < 10 then out2byte(i+304)
          else if i < 100 then begin
                  outbyte(2); outbyte(i//10+48); outbyte(rem(i,10)+48);
               end else begin
                  leftsintbuf.putint(i); i:=6;
                  while loadchar(leftsintbuf,i)<>' ' do i:=i-1;
                  i:=6-i;
                  outbyte(i); outtext(leftsintbuf.sub(8-i,i));
               end;
         end;

         procedure outinteger(i); integer i;
         begin ! Outputs a direct integer constant;
%+S            Freq(115):=Freq(115)+1;
               leftintbuf.putint(i); i:=11;
               while loadchar(leftintbuf,i)<>' ' do i:=i-1;
               i:=11-i;
               outbyte(i); outtext(leftintbuf.sub(13-i,i));
         end;

      end codegenerator0;

end SCODER0;
