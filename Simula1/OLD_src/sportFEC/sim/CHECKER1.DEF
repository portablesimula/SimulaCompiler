External class BUILDER2;

BUILDER2 class CHECKER1;
%      -----------------------------------------------------------------
%      ---  COPYRIGHT 1988 by                                        ---
%      ---  Simula a.s.                                              ---
%      ---  Oslo, Norway                                             ---
%      ---                                                           ---
%      ---                 P O R T A B L E     S I M U L A           ---
%      ---              F R O N T - E N D    C O M P I L E R         ---
%      ---         S e m a n t i c   C h e c k e r     P a r t  1.   ---
%      ---                                                           ---
%      --- Selection switches: DKIRZH                                ---
%      ---                                                           ---
%      ---    'c' Do NOT reverse C-procedure parameter list          ---
%      ---        (it should be done by BEC)                         ---
%      ---    'D' Included when dump is wanted                       ---
%      ---    'K' Included always when quick capability wanted       ---
%      ---    'P' Included to make compiler use quick procedures     ---
%      ---    'I' Included to make compiler use inserted mnemonics   ---
%      ---    'R' Included for full real capability                  ---
%      ---    'Z' Included during system generation (for "ZIMULA")   ---
%      ---                                                           ---
%      -----------------------------------------------------------------

%SELECT Z

begin

%SPORT ON
%REUSE ON
%-Z %RECORD ON

%+I %INSERT $SIMSRC/fec/common.mne
%+I %INSERT $SIMSRC/fec/scope.mne

prechecker class semchecker1;
hidden protected fkind,ftype,actualkind;
begin
      boolean inarraybound;      ! Used to check for use of 'this' or
                                   local quantities within array bounds;
      boolean implNone;          ! FALSE if no nonecheck for IN/IS/INSP;
      character fkind,ftype,actualkind;
      short integer c; !TEMP use - should change name!!!;
      short integer t;
          ! these are used for checking in different subclasses of
            operation ;
      short integer opttop;
      integer NargUnknown=1000; ! Used for formal array/procedure;

      ref(exp)exptop;
      ref(exp)expv;
      ref(nextargumentproducer) lastnap;
      ref(quantity)textclass;
        ! denotes the declquant of the brecord repr. "class text";
      ref(quantity)cquant; ! tmp use in checker2 ;
      ref(quantity)readonly; ! holds meaning for init. assign to RO attr;
      ref(quantity)actqty; ! actual.meaning to coder (DCLS/DCLI);
      ref(brecord)cbrec;   ! tmp use in dotident only;
      ref(quantity)q;
        ! Used e.g. to hold the array quantity during array declaration;
      ref(symbolbox) opdSymb,stepfastSymb;
      ref(boolconst)true_const,false_const;
      ref(textconst)notext_const;
      ref(valassign) valassList;
      ref(refassign) refassList;
      ref(simpleIdent) simpleList;
      ref(valuerel) valrelList;
      ref(arithconst) aconstList;

      text etxt1,etxt2; ! used for diagnostics ;

%-I   procedure popExpStack;
%-I   begin
%-I %+D     if exptop==none or else exptop==exptop.pred
%-I %+D     then internerr('!8!',sourceline);
%-I         exptop:-exptop.pred;
%-I   end;

%+PQ  prior
      procedure MaybeConvert(typ1,typ2); character typ1, typ2;
      begin 
%+S         Freq(77):=Freq(77)+1;
            if typ1=ISHOR then typ1:=IINTG;
            if typ2=ISHOR then typ2:=IINTG;
            if typ1<>typ2 then begin
               opc:=IPRHI; opt:=typ1; call(coder) end
      end;

%title ***  E x p r e s s i o n s  ***

% cl coding: - NOTE: sequence is significant (min case-size in Scoder)
  character      !0       initial setting for assign and identifier;
       IEEXPcl= '!1!',  ! expression - initial setting otherwise;
       IIFcl=   '!2!',  ! test expression (in if-expression);
       IIFSBcl= '!3!',  ! test expression (in if-statement);
       ITOcl=   '!4!',  ! target ;
       IACTEcl= '!5!',  ! actual ;
       ITEXTcl= '!6!',  ! text identifier in front of :=
                          or  .<text attribute> ;
       IMXMXcl= '!6!';

      class exp(pred,ch);
            ref(exp)pred;      ! links the exp objects to form a stack ;
            character ch;      ! "checker-code", see 'exp' subclasses  ;
    virtual:procedure emit
            is procedure emit;
            ;
            procedure sameAs   ! PARAMETER =/= NONE !!!;
            is boolean procedure sameAs(e); ref(exp) e;
            ;
%+D         procedure dump;
      begin character type;       ! val-type or IREF, ITEXT            ;
            character cl;         ! classification - see below         ;
            character ctype;      ! indicates the exp subclass         ;
%+Z         short integer issimple;
%-Z         character issimple;   !   0: this expr is not simple,      ;
                                  !   1: simpleIdent not by name,      ;
                      ! ?? ;      !   2: operation, left is simpleIdent;
                      ! ?? ;      !   3: operation, left is array elt  ;
                      ! ?? ;      ! > 3: array element (argumented)    ;
            character kind;       ! meaning.kind if appropriate        ;
            ref(quantity)qual;    ! qualification  - see below         ;
            ref(quantity)meaning; ! meaning if identifier or the like  ;

%+D         procedure expdump(T); text T;
%+D         inspect sysout do begin
%+D               outtext("   " & T); outchar(' ');
%+D               outtext(DB(rank(type)));
%+D               outtext(if cl=NUL then "     " else
%+D                       if cl=IEEXPcl then " expr" else
%+D                       if cl=IIFcl   then " IFex" else
%+D                       if cl=IIFSBcl then " IFst" else
%+D                       if cl=ITOcl   then "   to" else
%+D                       if cl=IACTEcl then " acte" else
%+D                       if cl=ITEXTcl then " text" else "illegal cl");
%+D               outtext(if issimple<>0 then " S" else "  ");
%+D               if qual=/=none then begin
%+D                  outtext(" QUAL:" & qual.symb.symbol);
%+D                  if option(rank('T'))<>NUL then begin
%+D                     outimage; outtext("   "); qual.dump end
%+D               end;
%+D         end;

%+D         procedure dump; inspect sysout do
%+D         begin expdump("  " & DB(rank(ch))); outimage end;

            boolean procedure sameAs(e); ref(exp) e; ;
            ! virtual match: always FALSE;

            procedure emit; ; !virtual match;

            procedure incompTypes(ltype,rtype); character ltype,rtype;
%           begin if ltype<>IELSE then begin if rtype<>IELSE then begin
%                    diag(0):-errmsg(rank(ltype));
%                    diag(1):-errmsg(rank(rtype));
%                    diag(2):-errmsg(rank(ch));
%                    error0(400);
%                 end end;
            begin if rtype<>IELSE then begin
                     diag(2):-errmsg(rank(ch)); error2xx(400,ltype,rtype)
                  end;
                  StopScode; type:=IELSE;
            end;

            procedure typeError(n); short integer n;
            if type<>IELSE then begin
               diag(0):-errmsg(rank(type)); error0(n);
               StopScode; type:=IELSE;
            end;

      end exp;

% qual only used for type=IREF,ITEXT, and in the classes Classcomparator,
%      instqual and localobj.
%
%  If a reference or value relation is:
%     - the test-expression of an if-expression, cl = IIF
%     - the test-expression of an if- or while-statement, cl = IIFSB
%     - the test-expression of a while-for-element, cl = IWHIL
%    (see LITHSB:, LIWHDO: and the emit procedures of ifexp,
%     whileforelem, refrel and valuerel).

%  ITEXT is used for identifier'cl, when its type=ITEXT and it is
%  followed by := or .<text attribute>.
%  If identifier'kind is K_proc, ITEXT is used
%  only when the identifier is to be interpreted as the result variable
%  of a procedure with type text.

      exp class rockBottom;
      !*** bottom of expression stack - emit should never be called ***;
      begin procedure emit; internerr('!8!',sourceline);
      end;

%title ***   O p e r a t i o n  -  E x p i n p a r   ***
      exp class operation(left,right); ref(exp)left,right;
      begin ! An operation with one or two operands;
%             If there are two operands they shall be type compatible,
%             independent of which kind of operation.
%             'ch' is the operator. right=/=none always.

%+D         procedure dump; inspect sysout do
%+D         begin expdump("  " & DB(rank(ch))); outimage;
%+D               if left=/=none then left.dump;
%+D               if right=/=none then right.dump;
%+D         end dump;

            boolean procedure sameAs(e); ref(exp) e;
            begin
%-Z %IMPLNONE OFF
                  if e in operation then begin
                     if left==none then begin
                        if e qua operation.left==none then goto CR end
                else if e qua operation.left=/=none then begin
                        if left.sameAs(e qua operation.left) then
                     CR:   sameAs:=right.sameAs(e qua operation.right);
                     end;
                  end;
            end;

%           if e in operation then sameAs:=
%              ( (left==none and then e qua operation.left==none)
%                or else left.sameAs(e qua operation.left) )
%              and then right.sameAs(e qua operation.right);

      end;


      operation class expinparantes;
      begin ! ch=IRGPA, this operation represents an expression
              within (  ),the expression denoted by right (left==none);

%+D         procedure dump; inspect sysout do
%+D         begin outtext("   ("); right.dump; end;

            procedure emit;
            begin right.cl:=IEEXPcl; right.emit end;

            if right.ctype=IIDN then checkasexp(right qua identifier);
            cl:=IEEXPcl;
            type:=right.type; qual:-right.qual;
%+S         Freq(78):=Freq(78)+1;
      end expinparantes;
%title ***   B o o l e a n   o p e r a t o r s   ***
      operation class boolop;
      begin ! ch=ICAND,ICOR,IAND,IOR,IEQV,IIMP  type=IBOOL, qual==none.
              The case ch=INOT does not occur (repl. by '.. equ false');

            procedure emit;
            begin left.cl:=IEEXPcl; left.emit;
                  !L3-> infix operator (dummy coder call);
                  !last;opc:=ch;
                  right.cl:=IEEXPcl; right.emit;
                  !L3-> postfix operator;
                  opc:=ch; !opi:=0; call(coder);
            end emit;

%+S         Freq(79):=Freq(79)+1;
%           if left=/=none then begin
               if left.ctype=IIDN then checkasexp(left qua identifier);
               if left.type<>IBOOL then error2xx(429,left.type,ch);
%           end;
            if right.ctype=IIDN then checkasexp(right qua identifier);
            cl:=IEEXPcl;
            if right.type<>IBOOL then error2xx(430,right.type,ch);
            type:=IBOOL
      end boolop;
%title ***   Operation:  r e f   r e l a t i o n   ***
      operation class relation;
      begin character opttype; ! of operands (arithmetic,ICHAR,ITEXT);
      end;

      relation class refrel;
      begin ! ch=IRFEQ,IRFNE    type=IBOOL, qual==none,
              opttype=type of operands (IREF,ITEXT);
            ! cl=IEEXP,IIF,IIFSB.
            ! left==none: compare right to notext;

            procedure emit;
            begin
                  right.cl:=IEEXPcl;
                  inspect left do begin
                     cl:=IEEXPcl;
                     if opttype=ITEXT then begin
                        !L3->(prefix operator,opttype) (dummy call);
                        !last;opc:=this refrel.ch;
                        emit;
                        !L3->(infix operator) - TEXT;
                        opc:=IVSPC; call(coder);
                        right.emit;
                        opc:=IPSPC; opihi:=this refrel.ch;
                     end
                     else begin !opttype<>ITEXT, i.e. IREF/IPTR;
                        emit;
                        !last;opc:=this refrel.ch;
                        right.emit;
                        opc:=this refrel.ch;
                     end;
                  end
                  otherwise inspect right do begin ! compare w/notext ;
                     if ch=IIDN or else ch=IIDNP
                     then cl:=ITEXTcl;
                     emit; !may change right.cl;
                     optx:=if cl=ITEXTcl then '!1!' else NUL;
                     opc:=IGO; opihi:=this refrel.ch;
                  end;
                  !L3->(postfix operator,cl);
                  opilo:=cl; call(coder);
            end emit;

%+S         Freq(80):=Freq(80)+1;
            if left==none then opttype:=ITEXT !NB;
            else begin
               opttype:=left.type;
               if left.ctype=IIDN then checkasexp(left qua identifier);
            end;
            if right.ctype=IIDN then checkasexp(right qua identifier);
            cl:=IEEXPcl;
            ctype:=IEQ;
            ! ******   type check   ****** ;
            switch(NUL:IELSE) opttype begin
            when IREF, ITEXT do
                 if opttype<>right.type then begin
                    if right.type<>IREF and then right.type<>ITEXT
                    then error2xx(432,right.type,ch)
                    else incompTypes(opttype,right.type);
                 end;
            when IPTR  do begin
            !*** NOTE: allow relation between CLASS and RECORD ref ***;
                 if opttype<>right.type then begin
                    if right.type<>IREF 
                    then incompTypes(opttype,right.type);
                 end end;
            when IELSE do ;
            when NONE do begin
               error2xx(431,opttype,ch); opttype:=IELSE; end;
            end case;

            type:=IBOOL;
      end;
%title ***   Operation:  v a l u e   r e l a t i o n   ***
      relation class valuerel;
      begin ! Value relation, ch=(ILT,ILE,IEQ,IGE,IGT),  type=IBOOL,
              qual==none, ch=IEQV (chg to IEQ) signals bool compare 
            ! cl=IEEXP,IIF,IIFSB,IWHIL. IIF, IIFSB or IWHIL means that
              this is a test-expression, of an if-expression, an
              if/while-statement or an while-forelement respectively ;

            procedure emit;
            begin left.cl:=right.cl:=IEEXPcl;
                  if opttype=ITEXT then begin
                     !L3->(prefix operator) dummy call;
                     !last;opc:=ch;
                     left.emit;
                     !L3->(infix operator) , ITEXT;
                     opc:=ICL; call(coder);
                     right.emit;
                     !L3->(postfix operator) , ITEXT;
                     opc:=ISMCL; opihi:=ch;
                  end
                  else begin
                     left.emit;
                     if opttype<>left.type
                     then MaybeConvert(opttype,left.type);
                     !last;opc:=ch;
                     right.emit;
                     if opttype<>right.type
                     then MaybeConvert(opttype,right.type);
                     !L3->(postfix operator);
                     opc:=ch;
                  end;
                  opilo:=cl; call(coder);
                  valrelList:-this valuerel;
            end emit;

         while true do begin !*** reuse loop ***;

            exptop:-this valuerel;
%+S         Freq(81):=Freq(81)+1;
            opttype:=left.type; ctype:=IEQ;
            if left.ctype=IIDN then checkasexp(left qua identifier);
            if right.ctype=IIDN then checkasexp(right qua identifier);
            cl:=IEEXPcl;
            ! ******   type check   ****** ;
            switch(NUL:IELSE) opttype begin
            when IBOOL,IREF do
                 if ch=IEQV then ch:=IEQ else goto TypErr;
%+Z         when ICHAR,ISHOR,IINTG,IREAL,ILONG do
%-Z         when       ISHOR,IINTG,IREAL,ILONG do
                 switch(NUL:IELSE) right.type begin
%+Z              when ICHAR,ISHOR,IINTG,IREAL,ILONG do begin
%-Z              when       ISHOR,IINTG,IREAL,ILONG do begin
%+Z                   !generate character compare in char/int relations;
%+Z                   rtype:=right.type;
%+Z                   if (opttype<=IINTG and then rtype=ICHAR) or else
%+Z                      (opttype=ICHAR and then
%+Z                        (rtype=IINTG or rtype=ISHOR))
%+Z                   then opttype:=ICHAR else
                      if right.type>opttype then opttype:=right.type;
                 end;
                 when IELSE do ;
                 when  NONE do error2xx(432,right.type,ch);
                 end case;
%+Z         when       ITEXT,IPTR do
%-Z         when ICHAR,ITEXT,IPTR do
                 if opttype<>right.type
                 then incompTypes(opttype,right.type);
            when IELSE do ;
            when  NONE do begin
       TypErr:   error2xx(431,opttype,ch); opttype:=IELSE end;
            end case;

%           if nearly(opttype)=IINTG and then nearly(rank(rtype))=IINTG
            type:=IBOOL;
%-Z %setopt +D
            detach;
%-Z %setopt -D
            valrelList:-none;
            right:-exptop; left:-right.pred; pred:-left.pred;
            issimple:=0;
         end *** reuse ***;
      end valuerel;
%title ***   A r i t h m e t i c    o p e r a t o r s   ***
      operation class arithop;
      begin ! Arithmetic operation, type=resulting type, qual==none;
%             ctype=IUPLS
%             after the actions of arithop ltype and rtype are <> IELSE.
%             NOTE: left may be(come) NONE as result of optimizations!!!
%           character ltype,rtype;

            procedure emit;
            begin inspect left do begin
                     cl:=IEEXPcl; emit;
                     if this arithop.type<>type
                     then MaybeConvert(this arithop.type,type);
                  end;
                  !L3->infix operator (dummy call);
                  !last;opc:=ch;
                  right.cl:=IEEXPcl; right.emit;
                 if type<>right.type then MaybeConvert(type,right.type);
                  !L3->postfix operator;
                  opc:=ch; !opi:=0; opt:=type; call(coder);
            end emit;

%+S         Freq(82):=Freq(82)+1;
            if right.kind<>K_ident then begin if right.ctype=IIDN
            then checkasexp(right qua identifier) end;
            if left.ctype=IIDN then begin
               if left.kind<>K_ident then checkasexp(left qua identifier)
            end
       else if left.ch=ICONS then begin
               if ch=IPLUS or else ch=IMULT then begin !swap;
                  expv:-left; left:-right; right:-expv end;
            end;
            type:=rtype:=right.type; ! ??? right.cl:=IEEXP;
            ltype:=left.type;
            cl:=IEEXPcl; ctype:=IUPLS;
            ! ******   type check   ****** ;
            switch(NUL:IELSE) type begin
%+Z         when ICHAR,ISHOR do begin
%-Z         when       ISHOR do begin
                 type:=IINTG; goto CHKcomp end;
            when IINTG,IREAL,ILONG do !check compatibility;
      CHKcomp:   switch(NUL:IELSE) left.type begin
%+Z              when ICHAR,ISHOR,IINTG do;
%-Z              when       ISHOR,IINTG do;
                 when IREAL,ILONG do
                      if type<left.type then type:=left.type;
                 when  NONE do begin
                      ltype:=IINTG; error2xx(429,left.type,ch) end;
                 end case;
            when  NONE do begin
                 ltype:=rtype:=IINTG;
                 error2xx(430,type,ch); type:=IELSE; end;
            end case;

      end arithop;


      arithop class integerdivide;
      begin ! ch=IIDIV - operands must be int type, no implicit conv;

%+S         Freq(83):=Freq(83)+1;
            if ltype>=IREAL then left. typeError(302);
            if rtype>=IREAL then right.typeError(303);
            type:=IINTG;
      end integerdivide;


      arithop class divide;
      begin ! ch=ISLAS;

%+S         Freq(84):=Freq(84)+1;
            if type<IREAL then type:=IREAL;
      end divide;
%page
      arithop class power;
      begin                ! ch=IPOWE, left=base, right=exp;
            character basetype;
            procedure emit;
            begin inspect left do begin cl:=IEEXPcl; emit end;
                  !L3->(infix IPOWE);
                  opc:=IPOWE; opilo:='!1!';
                  opt:=right.type; optx:=basetype; call(coder);
                  right.cl:=IEEXPcl; right.emit;
                  !L3->(postfix IPOWE);
                  opc:=IPOWE; !opi:=0;
                  opt:=right.type; optx:=basetype; call(coder);
            end emit;

%+S         Freq(85):=Freq(85)+1;
            if ltype=ILONG then begin
               if rtype=IREAL then type:=IREAL end;
            !*** type from arithop changed since drpower has type REAL;
            basetype:=ltype;
      end power;


      arithop class unary;
      begin ! ch=IUMNS (unary plus is skipped in pass1),  right==left;

            procedure emit;
            begin inspect left do begin cl:=IEEXPcl; emit;
%+Z                  if type=ICHAR then begin !convert to integer;
%+Z                     opc:=IPRHI; opt:=IINTG; call(coder) end;
                  end;
                  !L3->(IUMNS);
                  opc:=IUMNS; !opi:=0 - opt:=type; call(coder);
            end emit;

%+S         Freq(86):=Freq(86)+1;
      end unary;
%title ***   c l a s s   c o m p a r e   (IN,IS)   ***
      relation class classcomparator;
      begin !ch=(IIN,IIS), right==expression preceding IN/IS, left==none
             type=IBOOL, qual==class quantity;

%+D         procedure dump; inspect sysout do
%+D         begin expdump("  " & DB(rank(ch))); outimage;right.dump end;

            procedure emit;
            begin right.cl:=IEEXPcl; right.emit;
                  !L3->(IN/IS,qual);
%-Z %IMPLNONE OFF
                  if right.ch=ITHIS !is localobject; then implnone:=false;
                  opc:=ch; coder.opq:-qual; opilo:=cl; call(coder);
            end emit;

%+S       if ch=IIN then Freq(87):=Freq(87)+1 else Freq(88):=Freq(88)+1;
            if right.ctype=IIDN then checkasexp(right qua identifier);
            cl:=IEEXPcl; ctype:=IEQ;
            qual:-qualification;
            if qual.kind<>K_class then error1id(243,opdSymb) else
            if right.type <> IREF then begin if right.type <> IELSE
            then error0(if ch=IIN then 153 else 154) end;
            inspect right.qual do begin
               if kind=K_record then error1id(243,opdSymb) else
               if GiveNotes then begin
                  if subclass(right.qual,qual) then begin
                     if ch=IIN then note1id(394,opdSymb);
                  end else
                  if subclass(qual,right.qual) then !ok;
                  else note1id(if ch=IIN then 392 else 393,opdSymb);
            end end;
            type:=IBOOL;
      end classcomparator;
%title ***   i n s t a n t   q u a l i f i c a t i o n   (QUA)   ***
      operation class instqual;
      begin ! ch=IQUA, right==qualified expression, left==none,
              type=IREF, qual==class quantity,
              L3opq==the quantity to be sent with IQUA;
            ref(quantity)L3opq;

%+D         procedure dump; inspect sysout do
%+D         begin expdump("  " & DB(rank(ch))); outimage;right.dump end;

            procedure emit;
            begin right.cl:=IEEXPcl; right.emit;
                  if L3opq=/=none
                  then begin !L3->(QUA,qualification or none);
                     opc:=IQUA; coder.opq:-L3opq; call(coder);
                  end;
            end;

%+S         Freq(89):=Freq(89)+1;
            if right.ctype=IIDN then checkasexp(right qua identifier);
            cl:=IEEXPcl; type:=right.type;
            if type <> IREF then begin
               if type <> IELSE and type <> IPTR
               then error1id(313,opdSymb) end;
            qual:-qualification;
            if right.qual=/=none then begin
               if qual.kind=K_class then begin
                    if right.qual==qual then begin
                       if GiveNotes then note1id(395,opdSymb);
                    end
               else if subclass(right.qual,qual) then
               else if subclass(qual,right.qual) then begin
                       if NoneCheck or else QuaCheck then L3opq:-qual
                    end
                    else QERR: error2quants(402,qual,right.qual);
               end
          else if qual.kind=K_record then begin
                  if right.qual.kind=K_record then begin
                     if not subclass(right.qual,qual)
                     then error1id(-241,opdSymb);
                  end else goto QERR;
               end
               else begin qual:-right.qual; error1id(335,opdSymb) end;
            end;
      end instqual;
%title ***   L o c a l   o b j e c t   (THIS)   ***
      operation class localobject;
      begin !*** ch=ITHIS, left==none, right==dummy ref  ***;
            !*** type=IREF, qual==class quantity         ***;
            ref(quantity)L3opq; ! the quantity to be sent with ITHIS;

%+D         procedure dump; begin expdump("  THIS");sysout.outimage end;

            procedure emit;
            begin opc:=ITHIS; coder.opq:-L3opq; call(coder);
                  opc:=IQUA; !*** to avoid ridiculuos none-check ***;
            end;

%+S         Freq(90):=Freq(90)+1;
            cl:=IEEXPcl;
            type:=IREF;
            qual:-meaningof(opdSymb);
            if qual == none then qual:-newnotseen(opdSymb);
            ! block level of class body if qual is a class ;
            if qual.kind <> K_class then begin
               error1qlin(328,qual); qual:-none end
            else begin
               inspect getClass(qual,char(rank(qual.encl.blev)+1))
               do begin
                  ! a matching class is found;
                  if inarraybound then begin
                     if descr.blev=cblev
                     then error1id(314,opdSymb) end;
                  L3opq:-display(rank(descr.blev)).declquant;
                  while L3opq.kind=K_labbl do L3opq:-L3opq.prefqual;
                  ! L3opq denotes the first non-label declquant  at
                    this block level;
                  if L3opq.kind=K_prefbl then error1id(315,opdSymb)
             else if L3opq.kind=K_class then L3opq.descr.thisused:=true;
                  L3opq:-this quantity; ! i.e. qual;
               end
               otherwise begin ! no matching class found;
                   error1id(311,opdSymb); L3opq:-qual;
                   ! in case of "out of place" the wrong class is taken
                     as qualification of top of stack;
               end;
            end;
EXIT: end localobject;
%title ***   t e x t   c o n c a t e n a t i o n   ***

      exp class textconc;
      begin ! ch = ICONC ;
            short integer ntext; !*** number of operands ***;
            ref(textoperand) first, last;

            procedure insert;
            begin ref(exp) op;  op:-exptop;
                  while op.ch=IRGPA !is expinparantes;
                     do op:-op qua expinparantes.right;
                  if op.ch=ICONC !is textconc; then begin
                     ntext:=ntext+op qua textconc.ntext;
                     last.next:-op qua textconc.first;
                     last:-op qua textconc.last end
                  else begin
                     ntext:=ntext+1;
                     last :-last.next:-new textoperand(op);
                  end;
            end;

            procedure emit;
            begin if ntext>0 then begin
                     opc:=ICONC; opihi:=char(ntext);
                     call(coder); !*** prefix;
             NXT:    first.emit; first:-first.next;
                     opc:=ICONC;
                     if first=/=none then begin !*** more to come;
                        !opi:=0; call(coder); goto NXT; end;
                     opilo:='!1!'; call(coder); !** last operand;
                  end;
            end;

      end textconc;

      class textoperand(actual); ref(exp) actual;
      begin ref(textoperand) next;

            procedure emit;  begin actual.cl:=IEEXPcl; actual.emit end;

            !*** check here that actual is text-primary ***;
            if actual.ctype=IIDN then checkasexp(actual qua identifier);
            if actual.type<>ITEXT then begin
               if actual.type<>IELSE then error0(155);
               actual:-dummytxtop.actual;
            end;

      end textoperand;

      ref(textoperand) dummytxtop;
%title ***   a s s i g n m e n t   ***
%       exp class assign(target,source); ref(exp)target,source;
%       begin
%          ! ch=(IASSG,IDENO);
%          ! issimple eqv (target is single, no-name identifier and
%                          this is not text value assign) ;
%          ! cl=IEEXP means that this is a sub-assignment, i.e. the
%                     source of a multiple assignment ;
% 
% %+D      procedure dump; inspect sysout do
% %+D      begin
% %+D            target.dump;
% %+D            outtext(if this assign is valassign
% %+D                    then "  :=  " else "  :-  ");
% %+D            outtext("  type:" & DB(rank(type)) & "  cl:");
% %+D               outchar(char(rank(cl)+48));
% %+D            outimage;
% %+D            source.dump;
% %+D      end dump;
% 
%       end assign;


%page
%       assign class valassign;
      exp class valassign(target,source); ref(exp)target,source;
      begin
%        ! issimple: =1 if simple assignment ;
%        ! ch=IASSG: ordinary assignment statement,
%          type=target.type   ctype=0
%          qual==(none,textclass);

%+D      procedure dump; inspect sysout do
%+D      begin expdump("VALASS"); outimage;
%+D            target.dump; source.dump;
%+D      end dump;

         procedure emit;
         begin
%              ! target.cl has already been given appropriate value;
%              ! The case type=ITEXT given special treatment ;

            if type=ITEXT then begin ! text value assignment ;
               target.emit;
               ! L3 -> END-EXPR-TARGET ;
               opc:=IEXTR ;
               opt:=if target.cl=IEEXPcl then INOTE else INOTY ;
               if cl=IEEXPcl then opilo:='!1!'; ! sub-assignment ;
               call(coder);

               source.cl:=IEEXPcl;
               source.emit;
               ! L3 -> TEXT-VAL-ASS ;
               opc:=IVALU;
               opt:=if target.cl=IEEXPcl then INOTE else INOTY ;
% after if     if cl=IEEXPcl then opilo:='!1!'; ! sub-assignment ;
% after if     call(coder);
            end text value assignment
%page
            else begin
               if
%                 issimple <> crtblev      and then
                  source.ctype=IUPLS !in arithop; and then
                  source qua operation.left=/=none and then
                  target.sameAs(source qua operation.left)
               then begin
                  target.emit;
                  opc:=IINSP; call(coder);
                  if source.type<>source qua operation.left.type
                  then MaybeConvert(source.type,
                                    source qua operation.left.type);
                  source qua operation.left:-none;
                  issimple:=0;
               end
               else begin
                  if issimple=0 then begin
                     target.emit;
                     !L3->END-TARGET (dummy call);
                     !last;opc:=ITO;
                  end;
               end;
               source.cl:=IEEXPcl; source.emit;
               if type<>source.type then MaybeConvert(type,source.type);

               ! emit the appropriate <assign> operator,
                 IASSG (ASSIGN), INAME (ASS-TO-NAME),
                 ISIMU (SIMPLE-ASS) or IDCLC (RESULT-ASS) ;
               opt:=type; opc:=IASSG;
               if target.ctype=IIDN then begin
%+Z               if issimple<>0 and then target is dotident then begin
%+Z                  target.emit; opc:=ITO end else
%-Z %IMPLNONE OFF
                  inspect target.meaning do begin
                     coder.opq:-this quantity;
                     if categ=C_virt then coder.opq:-match;
                     if issimple<>0 then begin
                        if kind=K_proc then opc:=IDCLC else opc:=ISIMU end
                     else if categ=C_name then opc:=INAME;
                  end
               end;
            end *** type<>ITEXT ***;
            if cl=IEEXPcl then opilo:='!1!'; !This is sub-assignment;
            call(coder);
            target:-source:-none; !*** reuse ***;
            qual:-meaning:-none;  !*** reuse ***;
            valassList:-this valassign;
         end valassign'emit;
%page
      while true do begin !*** reuse loop ***;
%+S      Freq(91):=Freq(91)+1;
         type:=target.type;

         ! ******   type check   ****** ;
         switch(NUL:IELSE) type begin
         when IREF do
              if source.type=IREF then begin !*** replace by refassign;
                 error0(-159);
                 if refassList==none
                 then new refassign(pred,IDENO,target,source)
                 else call(refassList);
                 valassList:-this valassign; goto EXIT
              end else error0(156);
         when IELSE do ;
%+Z      when ICHAR,ISHOR,IINTG,IREAL,ILONG do
%-Z      when       ISHOR,IINTG,IREAL,ILONG do
              switch(NUL:IELSE) source.type begin
%+Z           when IBOOL,      ITEXT,INOTY do
%-Z           when IBOOL,ICHAR,ITEXT,INOTY do 
         NONCOMP:  incompTypes(type,source.type);
              when IREF  do error0(157);
              end case;  ! - other cases are compatible;
         when NONE do
              if type<>source.type then goto NONCOMP;
         end case;

         if source.ctype=IIDN then begin if source.kind<>K_ident
         then checkasexp(source qua identifier) end;

         ! test on assignable kind of target;
         if target.ctype=IIDN then begin
                 target.cl:=if target qua identifier.type=ITEXT
                            then ITEXTcl else ITOcl;
               switch(NUL:K_max) target.kind begin
                 when K_ident,K_error do begin
                    issimple:=target.issimple;
                    if target.meaning.protect='!2!' then begin
                       if readonly==target.meaning then readonly:-none
                       else target qua identifier.identError(253);
                    end;
                 end;
                 when K_rep    do target qua identifier.identError(340);
                 when K_array  do target qua identifier.identError(340);
                 when K_label  do target qua identifier.identError(341);
                 when K_switch do target qua identifier.identError(342);
                 when K_class  do target qua identifier.identError(343);
                 when K_record do target qua identifier.identError(343);
                 when K_proc   do begin
                    ! identifier of procedure kind as target:
                      result variable or text procedure call ;
                      if target qua identifier.result then begin
                         issimple:=1;
                         if target.type=INOTY
                         then target qua identifier.identError(338) end
                 else if target.type=ITEXT then begin
                         checkasexp(target qua identifier);
                         target.cl:=IEEXPcl; ! text procedure call ;
                       end else target qua identifier.identError(339);
                    end;
                 when NONE do internerr('!8!',sourceline);
           end case
%+D        otherwise internerr('!8!',sourceline);
         end
    else if target.ctype=IIDNP then begin
%-Z %IMPLNONE OFF
            inspect target qua argumented do begin
               this valassign.issimple:=issimple;
               cl:=ITOcl;
               switch(NUL:K_max) ident.kind begin
               when K_error,K_array,K_rep do
                    if ident .meaning.protect='!2!' then begin
                       if readonly==ident .meaning then readonly:-none
                       else ident.identError(253);
                    end;
               when NONE do
                 if type=ITEXT then cl:=IEEXPcl  ! text procedure call ;
                 else  ! type <> ITEXT and kind <> K_array/error,
                         i.e. kind=K_proc/class/label/switch ;
                      ident.identError(344);
               end case;
            end
         end
    else if target.ch=IRGPA !is expinparantes; then begin
            target.cl:=IEEXPcl;
            if target.type <> ITEXT then error0(158);
         end
    else if target.ch=ICONS !in const; then begin
            target.cl:=IEEXPcl; error0(152) end
         else error0(150);
         exptop:-this valassign;
      EXIT:
%-Z %setopt +D
         detach;
%-Z %setopt -D
         valassList:-none;
%        pred:-exptop.pred.pred; target:-exptop.pred; source:-exptop;
         source:-exptop; target:-source.pred; pred:-target.pred;
         cl:=ctype:=kind:=NUL; issimple:=0;
      end *** reuse loop ***;
      end valassign;
%title ***   R e f e r e n c e   a s s i g n m e n t   ***
%       assign class refassign;
      exp class refassign(target,source); ref(exp)target,source;
      begin
%        ! issimple: <>NUL if simple assignment ;
%        ! ch=IDENO: ordinary ref assignment statement,
%          type=target.type (IREF or ITEXT),
%          qual==target.qual;

         boolean implqua; ! true if implicit qua test is to be produced;

%+D      procedure dump; inspect sysout do
%+D      begin expdump("REFASS"); outimage;
%+D            target.dump; source.dump;
%+D      end dump;

         procedure emit;
         begin
%-Z %IMPLNONE OFF
            if
%                 issimple <> crtblev      and then
%-Z %IMPLNONE OFF
               (source is dotident and then
                source qua dotIdent.dotexp=/=none and then
                source qua dotIdent.dotexp.type<>ITEXT and then
                target.sameAs(source qua dotIdent.dotexp))
            then begin
               target.cl:=ITOcl; target.emit;
               opc:=IINSP; call(coder);
               if nonecheck then begin opc:=IQUA; call(coder) end;
               opc:=IDOT; coder.opq:-source.meaning;
               call(coder);
               source qua dotIdent.dotexp:-none;
               issimple:=0;
% after if     source.cl:=IEEXPcl; source.emit;
% after if     opc:=IASSG;
% after if     if cl=IEEXPcl then opilo:='!1!'; ! sub-assignment ;
% after if     call(coder);
            end
            else begin
               if issimple=0 then begin
                  target.cl:=ITOcl; target.emit;
                  !L3->END-TARGET (dummy call);
                  !last;opc:=ITO;
               end;
            end;

            source.cl:=IEEXPcl;  source.emit;
            if implqua then begin !L3->(IMPL-QUA,qualification);
               opc:=INONE; coder.opq:-qual; call(coder);
            end;

            ! emit the appropriate <assign> operator
              IASSG (ASSIGN), INAME (ASS-TO-NAME),
              ISIMU (SIMPLE-ASS) or IDCLC (RESULT-ASS) ;
            opt:=type; opc:=IASSG;
            if target.ctype=IIDN then begin
%+Z            if issimple<>0 and then target is dotident then begin
%+Z               target.cl:=ITOcl; target.emit; opc:=ITO end else
%-Z %IMPLNONE OFF
               inspect target.meaning do begin
                  coder.opq:-this quantity;
                  if categ=C_virt then coder.opq:-match;
                  if issimple<>0 then begin
                     if kind=K_proc then opc:=IDCLC else opc:=ISIMU end
                  else if categ=C_name then opc:=INAME;
               end
            end
       else if issimple<>0 then begin
               target.cl:=ITOcl; target.emit; opc:=ITO;
            end;
            if cl=IEEXPcl then opilo:='!1!'; !This is sub-assignment;
            call(coder);
            target:-source:-none; !*** reuse ***;
            qual:-meaning:-none;  !*** reuse ***;
            refassList:-this refassign;
         end refassign'emit;

      while true do begin !*** reuse loop ***;

%+S      Freq(92):=Freq(92)+1;
         type:=target.type;
         ! ******   type check   ****** ;
         switch(NUL:IELSE) type begin
         when IBOOL,ICHAR,ISHOR,IINTG,IREAL,ILONG do
              if type = source.type then begin
                 error0(-159);
                 if valassList==none
                 then new valassign(pred,IASSG,target,source)
                 else call(valassList);
                 refassList:-this refassign; goto EXIT
              end
         else if source.type=IREF or else source.type=ITEXT
              then begin typeError(304); type:=source.type; end
              else incompTypes(type,source.type);
         when IREF,ITEXT,IPTR do
              if type = source.type then begin
                 if target.qual==none then  qual:-source.qual
                 else begin
                    qual:-target.qual;
                    if source.qual==none then !implqua:=false; else
                    if subclass(source.qual,qual) then !...; else
                    if subclass(qual,source.qual) then begin
%-Z %IMPLNONE OFF
                       if source is newident then goto QE;
                       implqua:=QuaCheck and then qual.kind=K_class;
                    end else begin
                       QE:error2quants(403,qual,source.qual) end;
                 end;
              end
         else source.typeError(305);
         when IELSE do
              type:=source.type;
         end case;

         if source.ctype=IIDN then begin if source.kind<>K_ident
         then checkasexp(source qua identifier) end;

         ! test on assignable kind of target;
         if target.ctype=IIDN then begin
                 switch(NUL:K_max) target.kind begin
                 when K_ident,K_error do begin
                    issimple:=target.issimple;
                    if target.meaning.protect='!2!' then begin
                       if readonly==target.meaning then readonly:-none
                       else target qua identifier.identError(253);
                    end;
                    end;
                 when K_array,K_rep do
                    target qua identifier.identError(347);
                 when K_label do
                    target qua identifier.identError(348);
                 when K_switch do
                    target qua identifier.identError(349);
                 when K_class,K_record do
                    target qua identifier.identError(350);
                 when K_proc do
                    if target qua identifier.result then begin
                       issimple:=1;
                       if target.type=INOTY
                       then target qua identifier.identError(345) end
                    else target qua identifier.identError(346);
                 when NONE do internerr('!8!',sourceline);
%-D              end case;
%+D              end otherwise internerr('!8!',sourceline);
         end
    else if target.ctype=IIDNP then begin
%-Z %IMPLNONE OFF
            inspect target qua argumented do begin
               this refassign.issimple:=ident.issimple;
               switch(NUL:K_max) ident.kind begin
               when K_error,K_array,K_rep do
                    if ident .meaning.protect='!2!' then begin
                       if readonly==ident .meaning then readonly:-none
                       else ident.identError(253);
                    end;
               when none do ident.identError(351);
               end case;
            end
         end
         else error0(160);
         exptop:-this refassign;
      EXIT:
%-Z %setopt +D
         detach;
%-Z %setopt -D
         refassList:-none;
%        pred:-exptop.pred.pred; target:-exptop.pred; source:-exptop;
         source:-exptop; target:-source.pred; pred:-target.pred;
         cl:=ctype:=kind:=NUL; issimple:=0; implQua:=false;
      end *** reuse loop ***;
      end refassign;
%title ***   c o n d i t i o n a l   e x p r   ***
      operation class ifexp(testexp); ref(exp)testexp;
      begin ! ch=IELSE, left denotes then-exp and right denotes else-exp,
              type=resulting type, qual==resulting qualification;

%+D         procedure dump; inspect sysout do
%+D         begin expdump("IFEXPR"); outimage;
%+D               outtext("   if"); testexp.dump;
%+D               outtext(" then"); left.dump;
%+D               outtext(" else"); right.dump;
%+D         end dump;

            procedure emit;
            begin !L3->IF-EXPR (dummy call);
                  notinconditional:=false; generalgoto:=ingotostmt;
                  !last;opc:=IIF;
                  testexp.cl:=if testexp.ctype=IEQ
                              then IIFcl else IEEXPcl;
                  ! The code for a relational expression as test
                    expression can be optimized ;
                  testexp.emit;
                  !last;opc:=ITHEN;
                  !L3->THEN-EXPR - may be dummy call;
                  if testexp.ctype<>IEQ then call(coder);
                  left.cl:=IEEXPcl; left.emit;
                  if type<>left.type
                  then MaybeConvert(type,left.type);
                  !L3->ELSE-EXPR; opc:=IELSE; call(coder);
                  right.cl:=IEEXPcl; right.emit;
                  if type<>right.type
                  then MaybeConvert(type,right.type);
                  !L3->END-EXPR; opc:=IEEXP; call(coder);
            end emit;

%+S         Freq(93):=Freq(93)+1;
            type:=left.type; qual:-left.qual;
            if left.ctype=IIDN then checkasexp(left qua identifier);
            if right.ctype=IIDN then checkasexp(right qua identifier);
            cl:=IEEXPcl;
            if testexp.type <> IBOOL then begin if testexp.type<>IELSE
            then error0(161) end;
            if testexp.ctype=IIDN
            then checkasexp(testexp qua identifier);

            ! ******   type check   ******;
            switch(NUL:IELSE) type begin
%+Z         when ICHAR,ISHOR,IINTG,IREAL,ILONG do
%-Z         when       ISHOR,IINTG,IREAL,ILONG do
                 switch(NUL:IELSE) right.type begin
%+Z              when ICHAR,ISHOR,IINTG,IREAL,ILONG do
%-Z              when       ISHOR,IINTG,IREAL,ILONG do
                      if type<right.type then type:=right.type;
                 when IELSE do ;
%+Z              when IBOOL,      ITEXT do
%-Z              when IBOOL,ICHAR,ITEXT do
                      if type<>right.type then
            NONCOMP:     incompTypes(type,right.type);
                 when NONE do goto NONCOMP;
                 end case;
            when IREF do
                 if right.type=type then begin ! qualification check;
                    if qual =/= right.qual then begin
                       if qual == none then qual:-right.qual
                  else if right.qual=/=none then begin
                            ref(quantity)qx,qy;
                            qx:-qual; qy:-right.qual;
                            while qx.plev>qy.plev do qx:-qx.prefqual;
                            while qy.plev>qx.plev do qy:-qy.prefqual;
                            while qx=/=qy and then qx.plev>one do
                            begin qx:-qx.prefqual; qy:-qy.prefqual end;
                            if qx==qy then qual:-qx
                            else error2quants(404,left.qual,right.qual)
                       end;
                    end;
                 end
            else goto NONCOMP;
            when IELSE do begin
                 type:=right.type; qual:-right.qual end;
            when  NONE do
                 !*** includes PTR - no qual check ***;
                 if type<>right.type then goto NONCOMP;
            end case;

      end ifexp;
%title ***   C o n s t a n t s   ***
      exp class const;
      begin ! ctype=type of constant, qual==(none,textclass),
              NB: exptop in const == exptop.ch=ICONS
              ch (=constkind)=ICONS,ISCST;
            character ixhi,ixlo;

            procedure emit;
            begin
                  opc:=type;
%                 literal:-nameof(ixhi,ixlo); call(coder);
                  opihi:=ixhi; opilo:=ixlo; call(coder);
                  if this const is arithconst
                  then aconstList:-this const;
            end;

            boolean procedure sameAs(e); ref(exp) e;
            if e.ch = ICONS then begin if e qua const.ixlo=ixlo
            then sameAs:= e qua const.ixhi=ixhi end;

%+D         procedure dump; inspect sysout do
%+D         begin expdump(" CONST");
%+D               outtext("VALUE:" & nameof(ixhi,ixlo) ); outimage;
%+D         end;

%+S         Freq(94):=Freq(94)+1;

      end const;

      const class arithconst; ;

      const class textconst;
      begin ref(identifier) id;

            !*** NOTEXT is the only text const with ixhi=0 ***;

            procedure emit;
            begin 
%                 if id =/= none then begin !named constant;
%                    if id.dotexp =/= none then begin
%                       !*** eval of dotexp here (SIDE EFFECTS!!!)
%                            (QUA/NONE TESTS!!!)
%                            "dotexp.emit" - see identifier
%                            "POP"         - get rid of eval result
%                            WILL BE IMPL. IF ERROR REPORT!!!;
%                    end;
%                 end;
                  if ixhi=NUL then begin !notext;
                     opc:=ITEXT;
                  end
% V                  opc:=ICONS; literal:-nameof(ixhi,ixlo) end
             else if id==none then begin !string (not named const);
%                    opc:=IEXNM; literal:-nameof(ixhi,ixlo) end
                     opc:=IEXNM; opihi:=ixhi; opilo:=ixlo end
                  else begin
                     opc:=IDENO; coder.opq:-id.meaning end;
                  call(coder);
            end;

      end;


      const class valconst;
      begin !simplified emit for BOOL, CHAR, REF;

            procedure emit;
            begin
                  opc:=type;
                  opilo:=ixlo; call(coder);
            end;
      end;

      valconst class refconst;
      begin
%+D         procedure dump; inspect sysout do
%+D         begin outtext("   NONE"); outimage end;
      end;

      valconst class charconst;
      begin
%+D         procedure dump; inspect sysout do
%+D         begin expdump("cCONST");
%+D               outtext("VALUE:"); outint(rank(ixlo),0);
%+D               outtext("  (" & DB(rank(ixlo)) & ")"); outimage;
%+D         end;
      end;

      valconst class boolconst;
      begin
%+D         procedure dump; inspect sysout do
%+D         begin expdump("bCONST");
%+D               outtext("VALUE:" & nameof(ixhi,ixlo) ); outimage;
%+D         end;
      end;

%title ***  P r e  -  I d e n t i f i e r  ***

%+PQ  prior
      procedure checkasexp(id); ref(identifier) id;
%     ! is called to check that a single identifier is a complete
%       expression, i.e. that it is not a label or switch or a
%       class/procedure identifier without specified parameters;

      begin
%+S        Freq(96):=Freq(96)+1;
         switch(NUL:K_max) id.kind begin
           when K_proc,K_class do
               if id.meaning.descr=/=none then begin
                 if id.meaning.descr.npar>0 then id.identError(352) end;
           when K_array,K_rep,K_switch do id.identError(353);
         end case;
%+PQ     id:-none;
      end;

      exp class identifier;
      begin
%             ch=(IIDN,IIDNP,IDOT,IDOTP,INEW,INEWP,IBPRF,IBLKB),
%             ch=IBPRF: single class ident as prefix to block,
%             ch=IBLKB: ident as part of argumented as prefix to block,
%                       meaning then denotes the class quantity,
%                       if none then the prefixed block is treated as
%                       a normal block.
%
%             type= if class generator then IREF else
%                   if block prefix then undefined else meaning.type
%
%             ctype = IIDN
%
%             qual==if class generator then meaning else
%                   if prefixed block then prefix class else
%                   if type=ITEXT then textclass else meaning.qual
%

%+D      procedure dump; inspect sysout do
%+D      begin
%+D         expdump(if ch=IIDN or ch=IIDNP or
%+D                    ch=IDOT or ch=IDOTP then " IDENT"
%+D                 else if ch=INEW or ch=INEWP
%+D                 then "   NEW"
%+D                 else !  ch=IBPRF ; "PREFIX"  );
%+D         if meaning=/=none then begin
%+D            outtext("(" & meaning.symb.symbol & ")"); outimage;
%+D            if option(rank('T'))<>NUL then meaning.dump;
%+D         end else outimage;
%+D         if ctype=IIDN then begin
%+D            if this identifier is dotIdent then begin
%+D               outtext(" DOT");
%+D               this identifier qua dotIdent.dotexp.dump;
%+D         end end;
%+D      end dump;

         procedure identError(n); short integer n;
         begin error1qlin(n,meaning); kind:=K_error; type:=IELSE end;

         boolean procedure result;
         begin ref(quantity) blquant;
%+Z         short integer procblev;
%-Z         character     procblev;
            result:=false;
%              Called from valassign and refassign, kind=K_proc always
%              Result delivers true if this is a direct identifier
%              (not remotely accessed), and we are currently enclosed
%              by the procedure of which this is the identifier, i.e.
%              the procedure is on display.
%              Type of procedure <> INOTY is not checked here ;

            if ch=IIDN then begin if meaning=/=none then begin
               procblev:=rank(meaning.encl.blev)+1;
%               blev of procedure if it is on display.
%               NB! Cannot use meaning.descr.blev, since meaning may be
%                   a virtual, which maybe has no descriptor.
               if procblev > 5 and procblev <= rank(cblev) then begin
                  blquant:-display(procblev).declquant;
                  ! Get outermost prefix, i.e. ignore all label-
                    blocks, and possibly the body of the procedure:;
                  while blquant.kind=K_labbl
                     do blquant:-blquant.prefqual;
                  if blquant.kind=K_proc then blquant:-blquant.prefqual;
                  result:= (if meaning.categ=C_virt then
                            meaning.match else meaning)==blquant;
               end;
            end end;
         end result;

         procedure NamedConstant;
         ! replace identifier with const value on exptop ;
         begin ref(const) Nconst;
               if meaning.special = '!2!' then begin
                 inspect meaning.descr do begin

                  switch(NUL:ITEXT) type begin
                  when IBOOL do
                       Nconst:-new boolconst(pred,ICONS);
                  when ICHAR do
                       Nconst:-new charconst(pred,ICONS);
                  when ISHOR,  !*** cannot occur ***;
                       IINTG, IREAL, ILONG do
                       Nconst:-new arithconst(pred,ICONS);
                  when IREF  do
                       Nconst:-new refconst(pred,ICONS);
                  when ITEXT do begin
                       Nconst:-new textconst(pred,ICONS);
                       Nconst.qual:-textclass;
                       Nconst qua textconst.id:-this identifier end;
                  end case;
                  Nconst.ixhi:=blnohi; Nconst.ixlo:=blnolo;
                  Nconst.type:=Nconst.ctype:=type; Nconst.cl:=IEEXPcl;
                  pred:-none; exptop:-Nconst;
                 end inspect
                 otherwise goto NOTDEF;
               end
               else if meaning.special='!3!'
               then begin !use of const before definition;
         NOTDEF: identError(332);
                 meaning.special:=NUL; !meaning.descr:-none;
               end
         end NamedConstant;

%        procedure checkReadonly;
%        begin character blevel; boolean isBAD;
%              ref(quantity) qty;
%              if this identifier is dotident then isBAD:=true
%              else inspect meaning.encl do begin
%                 if preinsp=/=none then begin
%                    blevel:=cblev;
%                    while blevel <> NUL do begin
%                       qty:-display(rank(blevel)).declquant;
%                       while qty=/=none do begin
%                          if qty.descr==this brecord then begin
%                             isBAD:=inspected=blevel;
%                             goto tst;
%                          end;
%                          qty:-qty.prefqual;
%                       end;
%                       blevel:=char(rank(blevel)-1);
%                    end;
%                    internerr('!11!',sourceline); NOT FOUND????
%                 end;
%              end;
%        tst:  if isBAD then identError(253);
%        end;

         procedure emit; ! of identifier ;
         begin
            switch(NUL:IMXMXcl) cl begin
            when IEEXPcl do begin
    !.......;  switch(NUL:INEWP) ch begin
               when IBPRF,IBLKB do begin
                  ! Expand the corresponding structure: ;
                  blockpref:-meaning; allocate;
                  coder.opq:-getBrc(lastblhi,lastbllo).declquant;
                  opc:=IBLKB; call(coder);
                  if ch=IBPRF then begin
                     if meaning=/=none then begin
                        !L3->(PRF no param) PARAM-BEGIN - END-PREF-PAR ;
                        opc:=IBEFO; !opi:= 0; call(coder);
                     end;
                     enterblock;
                  end
               end;
               when IDOTP do begin
                  opc:=IDOTP; coder.opq:-meaning; call(coder); end;
               when IIDNP,INEWP do begin
                  opc:=IIDN; coder.opq:-meaning; call(coder); end;
               when INEW do begin
                  opc:=IIDN; goto IDNout end;
               when IIDN,IDOT do begin
                  opc:=ch;
          IDNout: coder.opq:-meaning; call(coder);
                  switch(NUL:K_max) kind begin
                  when K_proc do begin !L3->PARAM-BEGIN;
                       lastopc:=opc; opc:=IPROC; !opi:=0; call(coder);
                       lastopc:=IPROC;
                       opc:=if meaning.categ=C_local or else
                               meaning.categ=C_extnal or else
                               (meaning.categ=C_virt and then
                                meaning.descr=/=none)
                            then !L3->CH-PARAM-END; IEPRM
                            else !L3->(UCH-PARAM-END,number actuals);
                                 IUPLS;
                       call(coder); end;
                  when K_class do begin ! kind=K_switch impossible ?;
                     !L3->PARAM-BEGIN - CH-PARAM-END;
                     opc:=IAT;  !opi:= 0;  call(coder); end;
                  end case;
               end IIDN,INEW;
               end ***case***;
            end IEEXPcl;
%page
            when ITEXTcl,ITOcl do begin
                 coder.opq:-meaning;
                 if kind=K_proc then begin !L3->(RESULT,meaning);
                    opc:=IDCLP;
                    if meaning.categ=C_virt
                    then coder.opq:-meaning.match;
                 end
                 else begin !L3->(SINGLE-VAR,meaning);
                    opc:=IIDNP; if cl=ITEXTcl then opilo:='!1!';
                 end;
                 call(coder);
            end;
            when IACTEcl do begin !L3->(SINGLE-ACT.,meaning);
                 lastopc:=opc; opc:=ISSWA; coder.opq:-meaning;
                 call(coder);
            end;
            when NONE do !strange cl,identifier.emit;
                 internerr('!8!',sourceline);
            end case;

            if this identifier is simpleIdent
            then simpleList:-this identifier qua simpleIdent;
         end identifier'emit;

%+S      Freq(95):=Freq(95)+1;

      end identifier;
%title ***   Identifier:  s i m p l e   ***
      identifier class simpleIdent;
      begin !ch=IIDN      ,IIDNP;

         boolean procedure sameAs(e); ref(exp) e;
         if kind<>K_proc then begin if issimple<>0 then begin
%-Z %IMPLNONE OFF
            if e is simpleIdent then sameAs:= e.meaning==meaning;
         end end;

            ctype:=IIDN;
         while true do begin !*** reuse loop ***;

            exptop:-this identifier; ! may be overwritten below;
            meaning:-meaningof(opdSymb);

            if meaning==none then begin
               meaning:-newnotseen(opdSymb);
               type:=IELSE;; kind:=K_error;
               !UndeclIdent(337,this quantity);
               error1id(337,opdSymb); meaning.dim:=2;
               qual:-none; issimple:=0;
            end
            else begin
               type:=meaning.type; kind:=meaning.kind;
               qual:-if type=ITEXT then textclass else meaning.prefqual;
               ! common testing on constant elements and
                 illegal use of identifiers within array bounds;

               issimple:=1;
               switch(NUL:C_Max) meaning.categ begin
               when C_local,C_extnal do
                    if meaning.special > '!1!'
%                      and then kind=K_ident !exclude array;
%                      and then ch<>IIDNP 
                    then NamedConstant
               else if inarraybound then begin
                       if meaning.encl.rtblev=cblev
                       then errQT(meaning,316)
                    end;
               when C_name do issimple:=0;
               when C_virt do
                    if inarraybound then errQT(meaning,312);
               end case;
% --           if meaning.categ<>C_name then issimple:=1;
% --           if meaning.special > '!1!'
% --           then NamedConstant
% --      else if inarraybound then begin
% --              if meaning.categ=C_local or meaning.categ=C_extnal
% --              then begin
% --                 if meaning.encl.rtblev=cblev
% --                 then errQT(meaning,316)
% --              end
% --         else if meaning.categ=C_virt then errQT(meaning,312)
% --           end
            end;

            switch(NUL:K_max) kind begin
            when K_ident,K_label do
                 if ch=IIDNP then identError(357);
            when K_class do
                 if opttop <> 0 then begin
                    identError(334); type:=IREF; qual:-meaning;
                    ch:=INEW; ! taken as new ... ;
                 end;
            end case;

%-Z %setopt +D
            detach;
%-Z %setopt -D
            simpleList:-none; cl:=NUL; pred:-exptop;
         end *** reuse ***;

      end simple identifier;
%title ***   Identifier:  d o t   ***
      identifier class dotIdent(dotexp);
            ref(exp) dotexp; !*** may become NONE ***;
      begin !ch=IDOT,IDOTP;

         procedure emit;
         begin
               inspect dotexp do begin
                  cl:=IEEXPcl;
                  if type=ITEXT then begin
                     if ctype=IIDNP then begin
                        if this exp qua argumented.ident.kind=K_array
                        or this exp qua argumented.ident.kind=K_rep
                        then cl:=ITOcl;
                     end
                else if ctype=IIDN then begin
                       if kind<>K_proc then begin
        ! ???? ;        cl:=ITEXTcl; this dotident.cl:=IEEXPcl end
%                       ! text procedure interpreted as procedure call ;
                     end
                  end;
                  emit;
               end;
   
               if cl=IEEXPcl then begin
                  inspect dotexp do begin
                     !Note: cl= (IEEXP,ITO,ITEXT) set above;
                     if type=ITEXT -- or else ctype=ITEXT
                     then opc:=
                        if cl=ITOcl or else cl=ITEXTcl
                        then !L3->TEXT-VAR-DOT; INOTY
                        else !L3->TEXT-EXP-DOT; INOTE
                     else begin
                        if opc<>IQUA then begin if nonecheck
                        then begin opc:=IQUA; call(coder) end end;
                        opc:=IDOT
                     end;
                     coder.opq:-this dotident.meaning; call(coder);
                  end;
                  if ch=IDOT then begin
                     !Identifier not followed by arguments;
                     switch(NUL:K_max) kind begin
                     when K_proc do begin !L3->PARAM-BEGIN;
                        lastopc:=opc; opc:=IPROC; !opi:=0; call(coder);
                        lastopc:=IPROC; opc:=IEPRM;
                        switch(NUL:C_max) meaning.categ begin
                        when C_local,C_extnal do ;
                        when C_virt do
                             if meaning.descr==none then opc:=IUPLS;
                        when NONE do opc:=IUPLS;
                        end case;
%                       opc:=if meaning.categ=C_local or else
%                               meaning.categ=C_extnal or else
%                              (meaning.categ=C_virt and then
%                               meaning.descr=/=none)
%                            then !L3->CH-PARAM-END; IEPRM
%                            else !L3->(UCH-PARAM-END,number of actuals);
%                                 IUPLS;
                        call(coder);
                     end;
                     when K_class do begin ! kind=K_switch impossible (?);
                        !L3->PARAM-BEGIN - CH-PARAM-END;
                        opc:=IAT;  !opi:= 0;  call(coder);
                     end;
                    end case;
                  end;
               end cl=IEEXP
               else begin
                  if opc<>IQUA then begin if nonecheck
                  then begin opc:=IQUA; call(coder) end end;
                  coder.opq:-meaning;
                  if cl=ITEXTcl or else cl=ITOcl then begin
                     !L3->(DOT-VAR,meaning);
                        opc:=IDOTP;
                  end
             else if cl=IACTEcl then begin
                     opc:=ILFPA;    !L3->(DOT-ACTUAL,meaning);
                  end
             else internerr('!8!',sourceline);
                  call(coder);
               end;
         end dotIdent'emit;

         boolean procedure sameAs(e); ref(exp) e;
         if kind<>K_proc then begin if meaning.categ<>C_name then begin
          if dotexp=/=none then begin
%-Z %IMPLNONE OFF
           if e is dotIdent then begin if e.meaning==meaning then begin
            if e qua dotIdent.dotexp=/=none
            then sameAs:=dotexp.sameAs(e qua dotIdent.dotexp);
         end end end end end;

            exptop:-this identifier; ! may be overwritten below;
            ctype:=IIDN;
            if dotexp.type <> IELSE then begin
               if dotexp.ctype=IIDN
               then checkasexp(dotexp qua identifier);
               if dotexp.qual==none then begin error0(163); goto NQ end;
               if dotexp.type=IREF  then !ok;  else
               if dotexp.type=ITEXT then !ok;  else
               if dotexp.type=IPTR  then !ok;  else
                  error0(162);
            end
            else begin !IELSE or no qualification;
       NQ:     meaning:-newnotseen(opdSymb); goto found end;

%         ! try to identify the remote attribute, result in meaning;
            cbrec:-dotexp.qual.descr;
            meaning:-cbrec.favirt; !Look through virtuals at this plev;
            while meaning=/=none do begin
                  if meaning.symb==opdSymb then begin
                     if meaning.visible=NUL then goto found end;
                  meaning:-meaning.next end;

   newplev: meaning:-cbrec.fpar;
            while meaning=/=none do begin
                  if meaning.symb==opdSymb then begin
                     if meaning.visible=NUL then goto found end;
                  meaning:-meaning.next end;
            if cbrec.declquant.plev <> zero then begin
               cbrec:-cbrec.declquant.prefqual.descr;  goto newplev end;

%           ! not found, generate an error quantity;
            meaning:-newnotseen(opdSymb); meaning.dim:=2;
            error2quants(405,meaning,dotexp.qual);

    found:  type:=meaning.type; kind:=meaning.kind;
            qual:-if type=ITEXT then textclass  else meaning.prefqual;
            if type=ILABE
            then identError(if kind=K_label then 354 else 355);
            if kind=K_ident then begin
               if ch=IDOTP then identError(357) else
               if meaning.special > '!1!' then NamedConstant
%+Z       else if meaning.categ<>C_name then issimple:=1;
            end
%+Z             else issimple:=dotexp.issimple;
            cbrec:-none; !*** GC ***;
            ;

      end dot identifier;
%title ***   Identifier:  n e w / p r e f i x   ***

      identifier class newIdent;
      begin !ch=INEW,INEWP;
            ctype:=IIDN;
            qual:-meaning:-qualification;
            type:=IREF; kind:=K_class; !denotes generator;
            if qual.kind <> K_class then begin
               type:=IELSE; error1id(335,opdSymb); end;
      end newidentifier;


      identifier class prefIdent;
      begin !ch=IBPRF;
%         ! exptop:-this identifier; ctype:=IIDN; symx:-opdSymb;
          ! exptop:-this identifier; ctype:=IIDN;
            meaning:-meaningof(opdSymb);
            if meaning == none then meaning:-newnotseen(opdSymb);
            if meaning.kind <> K_class then begin
                  identError(333); meaning:-none end
       else if meaning.descr.npar>0 then identError(352);
            cl:=IEEXPcl;

      end prefix identifier;
%title ***  A r g u m e n t s  ***
      exp class pre_argumented(ident,arguments,noofexpargs,noofactargs);
            ref(identifier)ident; ref(argument)arguments;
            short integer noofexpargs,noofactargs;
      begin ! ch=IBPRF indicates that this argumented is a prefix to
              a prefixed block;

%+D         procedure dump; inspect sysout do
%+D         begin ident.dump; outtext(" ARG===>>");
%+D               arguments.dump; outtext(" <<===ARG");outimage;
%+D         end dump;

            procedure emit; ! of argumented ;
%-Z %IMPLNONE OFF
            begin inspect ident do begin
                     cl:=IEEXPcl; emit;
                     switch(NUL:K_max) kind begin
                      when K_proc do begin lastopc:=opc; opc:=IPROC end;
                      when K_class do
                           opc:=if this pre_argumented.ch=IBPRF
                                then IBEFO else IAT;
                      when K_rep   do begin
                           opc:=ISWEE; end;
                      when K_array do begin
                           opc:=ICAPE; end;
                      when K_switch do begin
                           !last;opc:=ICAPE; goto LOUT end;
                      when NONE do goto LOUT;
                     end case;
                     opilo:=char(noofactargs); call(coder);lastopc:=opc;
               LOUT: if meaning =/= none or else
                        this pre_argumented.ch <> IBPRF
                     then arguments.emit;
                  end;
%                 if ch=IBPRF and ident.meaning == none then !nothing;
%                 else arguments.emit;
                  if ident.kind=K_error then ! nothing  ; else
                  if ch=IBPRF then begin !L3->END-PREF-PAR;
                        opc:=IBEGI;call(coder);
                        enterblock;
                  end
                  else begin
                     switch(NUL:K_max) ident.kind begin
                         when K_array,K_rep do
                        opc:=if cl=IACTEcl then IARRA else
                             if cl=IEEXPcl then IARGE else INEWP;
                     when K_switch do
                        opc:=if cl=IACTEcl then IARRA else IAFTR;
                     when K_proc do
                        opc:=if arguments qua parameter.formal==none
                             then IUPLS else IEPRM;
                     when K_class do opc:=IACTV;
                     when NONE do internerr('!8!',sourceline);
                          !strange ident.kind, argumented.emit;
                     end case;
                     opilo:=char(noofactargs); call(coder);
                  end;
            end emit;

      end pre_argumented;
%page
      pre_argumented class argumented;
      begin
            short integer i; character searched,atype,ftype;
            ref(symbolbox) symx; ref(extquantity)q; ref(parameter)p;

            boolean procedure sameAs(e); ref(exp) e;
            begin ref(argument) arg1,arg2;
                  if e.ctype=IIDNP then begin
                   if e.meaning==ident.meaning then begin
                   if ident.sameAs(e qua argumented.ident)
                  then begin
                     arg1:-arguments; arg2:-e qua argumented.arguments;
                     while arg1=/=none do begin
                           if arg2==none then goto EX;
                           if not arg1.actual.sameAs(arg2.actual)
                           then goto EX;
                           arg1:-arg1.nextarg; arg2:-arg2.nextarg
                     end;
                     sameAs:=true;
%                    while arg1=/=none do begin
%                          if arg1.actual.sameAs(arg2.actual)
%                          then begin sameAs:=true;
%                               arg1:-arg1.nextarg; arg2:-arg2.nextarg
%                          end
%                          else begin sameAs:=false; arg1:-none end;
%                    end
                  end end end;
       EX:  end;

         ! contains the checking of argumented ;
         ! and parameter type checking for system procedures ;

%+S      Freq(97):=Freq(97)+1;
         type:=ident.type; qual:-ident.qual; meaning:-ident.meaning;
         ctype:=IIDNP;
         if ch=IBPRF then
         begin
            ! argumented prefix to block;
            if ident.kind <> K_class then begin if ident.kind <> K_error
            then begin
               ident.identError(333);
               meaning:-ident.meaning:-none; !treated as a normal block;
            end end;
            ident.ch:=IBLKB;
         end
    else
%-Z %IMPLNONE OFF
         if meaning is extquantity then
%-Z %IMPLNONE OFF
         inspect meaning qua extquantity do begin

%        Check for possible overloading. Three cases:
%        - overloading on first     parameter  (  0<longindic<10 )
%        - overloading on strongest parameter  ( 10<longindic<20 )
%        - overloading on second    parameter  ( 20<longindic<30 )
%        Note: the skip of special cases (clf=Clf005)
%         -  the (TEMP) resetting of overload-identifier - this should
%         -  really be done in BUILDER2.expandexternals. (see use of ix)

            if longindic<>NUL then begin
                 i:=rank(longindic); p:-arguments; q:-this quantity;
                 searched:=p.actual.type; symx:-symb;
                 if searched=ISHOR then searched:=IINTG;
                 if i > 20 then begin i:=i-20; goto SEARCH2 end
            else if i > 10 then begin
                    i:=i-10;
                    if p.nextarg.actual.type>searched then begin
            SEARCH2:   searched:=p.nextarg.actual.type;
                       if searched=ISHOR then searched:=IINTG;
                    end;
                    while i>=0 do begin
                       if q.descr.fpar.next qua quantity.type>=searched
                       then goto OL;
                       q:-q.next; i:=i-1;
                    end
                 end
            else if i > 0 then begin
                    while i>=0 do begin
                       if q.descr.fpar.type>=searched
                       then begin
            OL:           this argumented.ident.meaning:-q;
                          this argumented.ident.type:=
                          this exp.type:=q.type;
                          q.symb:-symx;
                          q:-q.descr.fpar;
                          while q=/=none and then p=/=none do begin
                             p.formal:-q; q:-q.next; p:-p.nextarg;
                          end;
                          goto TYPCHK;
                       end;
                       if q.clf=Clf005 then q:-q.next;
                       !*** skip value-overloading ***;
                       q:-q.next; i:=i-1;
                    end;
                 end;

                 !*** NOW type checking of parameters may be performed ;
       TYPCHK:   p:-arguments;
                 while p =/= none do begin
                    ftype:=p.formal.type;
                    if ftype <> p.actual.type then begin
                       ! ******   type check   ****** ;
                       switch(NUL:IELSE) p.actual.type begin
%+Z                    when ICHAR,ISHOR,IINTG,IREAL,ILONG do
%-Z                    when       ISHOR,IINTG,IREAL,ILONG do
                            switch(NUL:IELSE) ftype begin
%+Z                         when IBOOL,      IREF,IPTR,ITEXT,INOTY do
%-Z                         when IBOOL,ICHAR,IREF,IPTR,ITEXT,INOTY do
                                 p.errARG(426);
                            end case;
                       when IELSE do ;
                       when  NONE do 
                            if ftype < INOTY then p.errARG(426);
                       end case;
                    end ftype<>atype;
                    p:-p.nextarg;
                 end *** parameter type check ***;
%      TYPCHK:   if arguments=/=none then begin
%                   p:-arguments;
%                   while true do inspect p do begin
%                     if formal.type <> actual.type then begin
%                      ftype:=formal.type;
%                      ! ******   type check   ****** ;
%                      switch(NUL:IELSE) actual.type begin
% +Z                    when ICHAR,ISHOR,IINTG,IREAL,ILONG do
% -Z                    when       ISHOR,IINTG,IREAL,ILONG do
%                           switch(NUL:IELSE) ftype begin
% +Z                         when IBOOL,      IREF,IPTR,ITEXT,INOTY do
% -Z                         when IBOOL,ICHAR,IREF,IPTR,ITEXT,INOTY do
%                                errARG(426);
%                           end case;
%                      when IELSE do ;
%                      when  NONE do 
%                           if ftype < INOTY then errARG(426);
%                      end case;
%                     end ftype<>atype;
%                     p:-nextarg;
%                   end otherwise goto EXTYPC;  EXTYPC:
%                end *** parameter type check ***;

            end *** overloading ***;

            !*** test for illegal actual to standard proc. name param;
%-Z %IMPLNONE OFF
            if arguments is parameter then begin
            if clf=Clf010 or clf=Clf007 then begin
               p:-arguments;
               while p=/=none do begin
                inspect p.formal do begin
                  if categ=C_name then begin !by-name to standard proc.;
                     if p.actual.ctype<>IIDN then p.errARG(433);
                     if p.actual.type<>type then p.errArg(434);
                  end;
                end;
                p:-p.nextarg;
               end;
            end end;

         end external quantity block;

         if noofexpargs <> noofactargs then begin
            etxt1:-qlin(ident.meaning); etxt2:-leftint(noofexpargs);
            error2(if noofactargs > noofexpargs then 407 else 408,
                   etxt1,etxt2);
         end;

      end argumented;
%title ***   n e x t a r g u m e n t p r o d u c e r   ***

      class nextargumentproducer;
      begin
         boolean inuse;
         character kind; ! denotes the kind: K_array/switch/proc/class;
         short integer count;
%          ! hold the number of expected parameters. Is
%            counted 1 down for each actual parameter, and when
%            the expected number is reached there are generated
%            dummy parameters for the rest of the actuals;
         short integer noofexpargs; ! number of expected arguments;
         short integer argno;       ! argument number;
         short integer preflvl;
         ref(nextargumentproducer) pred, suc;
         ref(identifier)ident;
         ref(argument)firstarg,lastarg;
         ref(quantity)testquant;
           ! denotes the array/procedure/class quantity to be tested;
         ref(parameter) newpar; ref(index) newindex; !avoid SAVE;
         ref(quantity) cquant; ref(brecord)cbrec;
%+Z      ref(quantity) array prefixChain(0:64);
%-Z      ref(quantity)       prefixChain(  64);

         pred:-lastnap;
         firstarg:-new argument(0,none);
         !*** inuse false, see class argument ***;

       while true do begin
         detach;
         ident:-exptop; kind:=ident.kind; inuse:=true;
         lastarg:-firstarg; firstarg.nextarg:-none;
         noofexpargs:=argno:=0;

%        if kind<>K_ident and then kind<>K_label
%                         and then kind<>K_error
%        then begin
         if kind = K_ident or else kind = K_label or else kind = K_error
         then !testquant==none;
         else begin
            if ident.meaning.categ=C_local or else
               ident.meaning.categ=C_extnal or else
               kind=K_array or else kind=K_rep or else kind=K_switch
            then testquant:-ident.meaning
       else if ident.meaning.categ=C_virt and ident.meaning.descr=/=none
            then testquant:-ident.meaning.match;
         end;
%-Z %setopt +D
         detach; ! get first index/parameter if any;
%-Z %setopt -D
         if testquant==none then begin
            ! Undeclared "procedure" or formal procedure or simple,
              generate a dummy parameter for each call;
            noofexpargs:=NargUnknown;

    dummy:  while inuse do begin
               argno:=argno+1;
               newpar:- new parameter(argno,exptop,none);
               lastarg:-lastarg.nextarg:-newpar; newpar:-none;
               popExpStack; ! unstacks the actual;
               detach;
            end;
%           goto endofuse;
         end *** testquant==none ***

         else switch(NUL:K_max) testquant.kind begin
         when K_array,K_rep do begin
            noofexpargs:=if testquant.categ=C_local or else
                            testquant.categ=C_extnal then testquant.dim
                         else NargUnknown;  !in case of formal array;

  GENINDEX: while inuse do begin
               argno:=argno+1;
               newindex:-new index(argno,exptop);
               lastarg:-lastarg.nextarg:-newindex; newindex:-none;
               popExpStack; ! unstacks the actual;
%-Z %setopt +D
               detach; ! get next index;
%-Z %setopt -D
            end;
%           goto endofuse;
         end *** array ***;

         when K_switch do begin
            noofexpargs:=1; goto GENINDEX end;

         when none do begin ! must be class or procedure;
            cbrec:-testquant.descr;
            preflvl:=1; prefixChain(1):-cbrec.fpar;
% ???       if kind=K_class and then
% ???          testquant.descr.stmtag=NUL and then
% ???          testquant.descr.dcltag=NUL and then
% ???          testquant.descr.inrtag=NUL
% ???       then ident.issimple:=crtblev;
            while cbrec.declquant.plev > one do begin
               cbrec:-cbrec.declquant.prefqual.descr;
               preflvl:=preflvl+1; prefixChain(preflvl):-cbrec.fpar;
            end;
            cbrec:-none;

            noofexpargs:=count:=testquant.descr.npar;
            while count > 0 and then preflvl <> 0 and then inuse
            do begin
                  cquant:-prefixChain(preflvl);
                  prefixChain(preflvl):-none; preflvl:=preflvl-1;
                  goto enter; !NB;
                  while cquant=/=none and then inuse do begin
                        count:=count-1; argno:=argno+1;
                        newpar:- new parameter(argno,exptop,cquant);
                        if exptop.ch = ICONS then  !nothing;
                        else ident.issimple:=0;
                        lastarg:-lastarg.nextarg:-newpar; newpar:-none;
                        popExpStack; ! unstacks the actual;
                        detach; ! get next parameter;
                        cquant:-cquant.next;
               enter:   if cquant=/=none then begin
                           if cquant.categ=C_local or else
                              cquant.categ=C_extnal
                           then cquant:-none end;
                  end;
                  ! cquant==none or not inuse;
            end;
            cquant:-none;
            while preflvl <> 0 do begin !*** GC ***;
                  prefixChain(preflvl):-none; preflvl:=preflvl-1 end;
            ! count=0 or not inuse;
            if inuse then begin if count=0 then goto dummy end;
               ! too many parameters, generate dummy parameters
                 for the rest of the actual parameters;
%-c         if testquant.kind=K_proc and then testquant.dim=rank(Cindex)
%-c         then begin !*** reverse parameter list for C procedure ***;
%-c            ref(argument) curarg,arglist;
%-c            arglist:-lastarg;
%-c            while lastarg=/=firstarg do begin
%-c               curarg:-firstarg;
%-c               while curarg.nextarg=/=lastarg
%-c               do curarg:-curarg.nextarg;
%-c               lastarg.nextarg:-if curarg=/=firstarg
%-c                                then curarg else none;
%-c               lastarg:-curarg;
%-c            end;
%-c            firstarg.nextarg:-arglist; 
%-c         end;

         end proc or class testing;
         end *** case ***;

%      endofuse:
         if noofexpargs=NargUnknown then
         begin
            ! formal procedure/array;

            noofexpargs:=argno;
%+N         recordactualuse(ident.meaning,argno);
         end;
         testquant:-none;
         !*** drop these before final detach of used 'lastnap';
       end *** reuse loop ***;

      end nextargumentproducer;
%title ***   a r g u m e n t  -  i n d e x   ***
      class argument(argno,actual);
            short integer argno; ref(exp)actual;
      virtual:procedure emit
              is procedure emit;
              ;
%+D           procedure dump;
      begin
            ref(argument)nextarg;

            boolean procedure sameAs(e); ref(exp) e;
                 ;

            procedure errARG(eax); short integer eax;
            begin text etxt1,etxt2;
                  etxt1:-" par#" & leftint(argno) & " ";
                  etxt2:-qlin(lastnap.ident.meaning);
                  error2(eax,etxt1,etxt2);
            end;

      end argument;


      argument class index;
      begin ! array index ;

%+D         procedure dump;
%+D         begin outtext(" INDEX #");
%+D               outint(argno,0); outchar(':'); actual.dump;
%+D               if nextarg=/=none then nextarg.dump;
%+D         end dump;

            procedure emit;
            begin actual.cl:=IEEXPcl; actual.emit;
                  if actual.type <> IINTG
                  then MaybeConvert(IINTG,actual.type);
                  if nextarg=/=none then begin
                     !L3->INDEX-COMMA; opc:=ICOMA; call(coder);
                     nextarg.emit;
                  end;
            end emit;

%+D         if actual==none then !??? how can this ever occur ???;
%+D         else begin
               ! ******   type check   ****** ;
               switch(NUL:IELSE) actual.type begin
%+Z            when IBOOL,      IREF,IPTR,ITEXT,INOTY do
%-Z            when IBOOL,ICHAR,IREF,IPTR,ITEXT,INOTY do
                    errARG(419);
               end case;

               if actual.ctype=IIDN
               then checkasexp(actual qua identifier);
%+D         end;
      end index;
%title ***  Procedure / Class  Parameter  ***
      argument class parameter(formal); ref(quantity)formal;
      begin boolean implqua; ! true if implicit qua is to be produced ;
            character clf;   ! attr classification ;

%+D         procedure dump;
%+D         begin outtext(" PARAM #"); outint(argno,0);
%+D               outtext(" formal:");
%+D               if formal=/=none then
%+D               begin if option(rank('T'))<>NUL then formal.dump
%+D                     else outtext("(" & formal.symb.symbol & ")");
%+D               end else outtext("none");
%+D               outimage; outtext(" actual:"); actual.dump;
%+D         end dump;

            procedure emit;
%-Z %IMPLNONE OFF
            inspect actual do begin
                  coder.opq:-formal;
                  if formal==none or else formal.categ=C_name
                  then begin
                     !test here for readonly, since it's the easiest!;
                     if meaning=/=none then begin
                      if meaning.protect='!2!' then begin
                        if !actual.; ctype=IIDN
                        then actual qua identifier.identerror(253)
                        else if !actual.; ctype=IIDNP
                        then actual qua argumented.ident.identerror(253)
                      end;
                     end;
%                    opc:=if (actual.ctype=IIDN and then actual.ch=ISIDN
%                             and then actual.cl <> IEEXPcl)  or else
%                            (actual.ch=ISCST and actual.ctype<=ITEXT)
%                         then IDCLS  !L3->(SINGLE-STRONG,formal/none);
%                         else IDCLI; !L3->(EXP-STRONG,formal/none);
% --- SIDN ut        if actual.ctype=IIDN and then actual.ch=ISIDN
%        the test below is enough since that's a single identifier
                     if ch=IIDN and then cl <> IEEXPcl
%                    then opc:=IDCLS !L3->(SINGLE-STRONG,formal/none);
                     then begin opc:=IDCLS; !L3->(SINGLE-STRONG,formal/none);
                                actqty:-meaning;
                     end
                else if ch = ICONS then begin
                        opc:=IDCLS; call(coder);
                        cl:=IEEXPcl;
                        switch(NUL:IELSE) type begin
                        when IBOOL,ICHAR,IREF do begin
                             opc:=ISCST; opt:=type;
                             opilo:=this exp qua const.ixlo;
                             call(coder); goto NxtArg;
                             end;
                        when ITEXT do begin
                             if this exp qua const.ixhi=NUL
                             then begin !notext;
                                opt:=ITEXT; opc:=ISCST; end
                             else begin
                                opc:=ICONS;
% V                             literal:-nameof(this exp qua const.ixhi,
% V                                             this exp qua const.ixlo)
                                opihi:=this exp qua const.ixhi;
                                opilo:=this exp qua const.ixlo;
                             end;
                             call(coder); goto NxtArg;
                             end;
                        when ISHOR,IINTG,IREAL,ILONG do begin
                             opc:=ISCST; opt:=type;
% V                             literal:-nameof(this exp qua const.ixhi,
% V                                             this exp qua const.ixlo)
                                opihi:=this exp qua const.ixhi;
                                opilo:=this exp qua const.ixlo;
                             call(coder); goto NxtArg;
                             end;
                        end;
                        goto NxtArg;
                     end 

                     else opc:=IDCLI; !L3->(EXP-STRONG,formal/none);
                     call(coder);
                     cl:=
                       if (ctype=IIDN or else ctype=IIDNP)
                           and then cl <> IEEXPcl
                       then IACTEcl  else IEEXPcl;
                     emit;
                     if ((ctype=IIDN or else ctype=IIDNP)
                         and then cl=IACTEcl)
%                      or else (ctype<=ITEXT and ch=ISCST)
                     then !nothing;
                     else begin !L3->(EXP-ACTUAL,actual.type);
                        opc:=IRGPA; opt:=type;
                        if opt=IREF then coder.opq:-qual;
                        call(coder);
                     end;
                  end else
                  begin ! formal=/=none and formal.categ <> C_name;
                     !L3->(WEAK-PAR,formal);
                     opc:=IFRMP; call(coder);
                     if ctype=IIDN then begin if cl<>IACTEcl
                     then cl:=IEEXPcl end;
                     emit;
                     if formal.kind=K_ident then begin
                           ftype:=formal.type;
                           if formal.type<>type
                           then MaybeConvert(formal.type,type)
                      else if implqua then begin
                              !implqua:=false;
                              !L3->(IMPL-QUA,qualification); opc:=INONE;
                              coder.opq:-formal.prefqual; call(coder);
                           end;
                     end;
                  end;
       NxtArg:    if nextarg=/=none then nextarg.emit;
            end emit;

%           boolean procedure sameclass(q1,q2); ref(quantity) q1,q2;
%           begin !check whether actual/formal parameter qualifications
%                  actually describe the same external class, in which
%  inline coded    case the result is true (may occur if one is brought
%  until we may    in implicitly at a deeper block level);   
%  find another   if q1 is extquantity then begin
%  use for it      if q2 is extquantity then begin
%                   if q1.symb==q2.symb then sameclass:=
%                      q1.descr qua extbrecord.checklo
%                     =q2.descr qua extbrecord.checklo and then
%                      q1.descr qua extbrecord.checkhi
%                     =q2.descr qua extbrecord.checkhi;
%                 end end;
%           end;

%+D         if option(rank('T'))<>NUL then begin
%+D            outimage; outtext("begin parameter-checking: ");
%+D            outimage; outtext("formal:"); outimage;
%+D            if formal=/=none then formal.dump else outtext("none");
%+D            outimage; outtext("actual:"); outimage; actual.dump;
%+D            outimage; outtext("stack picture"); outimage;
%+D            for expv:-exptop,expv.pred
%+D            while expv=/=none do expv.dump;
%+D         end;
%           if lastnap.inuse then begin
%              !*** lastnap not inuse means: parameter generated from
%                   activateprelude or end of activation statement;
               if formal==none then begin
                  if actual.ctype=IIDN then begin
                     cquant:-actual.meaning;
                     if cquant.kind=K_class then begin
                        checkasexp(actual qua identifier);
                        actual.cl:=IEEXPcl; end
                else if cquant.kind=K_proc then begin
%-Z %IMPLNONE OFF
                        if cquant is extquantity and then
                            cquant qua extquantity.clf > Clf001
                        then begin
                           ! system defined procedure/function;
                           if cquant.type <> INOTY and then
                              cquant.descr.npar=0
                           then begin !function call assumed;
                              if GiveNotes then note0(294);
                              actual.cl:=IEEXPcl;
                           end else errARG(420);
                        end else actual.cl:=IACTEcl;
                     end
                     else actual.cl:=IACTEcl;
                  end
             else if actual.ctype=IIDNP then begin
                     actual.cl:=
                     if actual qua argumented.ident.kind=K_array or else
                        actual qua argumented.ident.kind=K_rep   or else
                        actual qua argumented.ident.kind=K_switch
                     then IACTEcl else IEEXPcl;
                  end
                  else actual.cl:=IEEXPcl;
               end
               else begin
                  ! procedure or class parameter testing, formal=/=none;
                  ftype:=formal.type; fkind:=formal.kind;
%-Z %IMPLNONE OFF
                  clf:=if formal is extquantity
                       then formal qua extquantity.clf else Clf003;
   
   !?;            if fkind=K_error or actual.type=IELSE then !nothing;
                  else begin
                     if actual.ctype=IIDN then begin
                        cquant:-actual.meaning;
                        actualkind:=cquant.kind;
                        switch(NUL:K_max) fkind begin
                         when K_ident,K_label do begin
                           if actualkind=K_ident or else
                              actualkind=K_label
                           then actual.cl:= if formal.categ=C_name
                                            then IACTEcl else IEEXPcl
                           else begin
                              checkasexp(actual qua identifier);
                              if (actualkind=K_proc and then
                                  actual.type<>INOTY) or else
                                 actualkind=K_class !generator;
                              then begin
                                 actualkind:=K_ident;actual.cl:=IEEXPcl;
                              end;
                           end;
                         end;
                         when K_proc do begin
                           if actualkind=fkind then begin
%-Z %IMPLNONE OFF
                              if cquant is extquantity and then
                                 cquant qua extquantity.clf>Clf001
                              then errARG(420) !system def.d procedure ;
                              else actual.cl:=IACTEcl;
                           end;
                         end;
                         when K_array,K_rep,K_switch do begin
                           if actualkind=fkind then actual.cl:=IACTEcl;
                         end;
                         when none do actual.cl:=IEEXPcl;
                        end case;
                     end
                else if actual.ctype=IIDNP then begin
                        actualkind:=actual qua argumented.ident.kind;
                        ! actualkind=K_array/switch/proc/class/error;
                        actual.cl:=IEEXPcl; !default value;
                        if fkind=K_ident then begin
                           if actualkind=K_proc or else actualkind=K_class
                           then ! type procedure call or class generator;
                              actualkind:=K_ident
                           else
                           if actualkind=K_array
                           or actualkind=K_rep
                           then begin
                              actual.cl:= if formal.categ=C_name
                                          then IACTEcl else IEEXPcl;
                              actualkind:=K_ident; !subscription;
                           end;
                        end else
                        if fkind=K_label then begin
                           if actualkind=K_switch then begin
                              actual.cl:= if formal.categ=C_name
                                          then IACTEcl else IEEXPcl;
                              actualkind:=K_label;
                           end;
                        end else
                        if actualkind<>K_error then actualkind:=K_ident;
                     end
                else if actual.ch = ICONS  then actualkind:=K_ident
                else
%-Z %IMPLNONE OFF
                     if actual in operation
                     then actualkind:=if actual.type=ILABE
                                      then K_label else K_ident
                else
                     if actual.ch=ICONC !is textconc;
                     then actualkind:=K_ident
                  end;

                  if fkind = actualkind then begin
                  switch(NUL:K_max) fkind begin
                  when K_error do ;
                  when K_array do begin !actual must be identifier;
%+Z                    if not actual.ctype=IIDN
%+Z                    then internerr('!8!',sourceline);
                       if (ftype <> actual.type or else
                           (ftype=IREF and then actual.meaning.prefqual
                                                =/= formal.prefqual) )
                          and then clf<>Clf017
                                 ! clf =Clf017: anytype parameter ;
                       then errARG(422);
                       end;
                  when K_proc  do       !actual must be identifier;
                       if formal.categ=C_unspec then begin
                          if not actual.ctype=IIDN
                          then internerr('!8!',sourceline);
                          if not subordinate(actual
                                             .meaning,formal)
                          then errARG(423);
                       end;
                  when NONE    do begin
                       if actual.type<>ftype then begin
                       switch(NUL:IELSE) actual.type begin
%+Z                    when ICHAR,ISHOR,IINTG,IREAL,ILONG do
%-Z                    when       ISHOR,IINTG,IREAL,ILONG do
                            switch(NUL:IELSE) ftype begin
%+Z                         when ICHAR,ISHOR,IINTG,IREAL,ILONG do;
%-Z                         when       ISHOR,IINTG,IREAL,ILONG do;
                            when NONE do goto ERRchk;
                            end case;
                       when INOTY do errARG(424);
%+Z                    when IBOOL,      IREF,ITEXT do
%-Z                    when IBOOL,ICHAR,IREF,ITEXT do
                ERRchk:     if ftype=IELSE then !OK;
                       else if ftype=INOTY then errARG(425)
                       else if clf<>Clf016 and then clf<>Clf018
                            then errARG(426)
                       else !formal.encl must be extbrec;
                            if formal.encl.declquant
                               qua extquantity.longindic = NUL
                            then errARG(426);
                            !*** else overloadable;
                       end case end if
                  else if ftype=IREF  !and actual.type=IREF ; or else
                          ftype=IPTR  !and actual.type=IPTR ;
                       then begin !local block to avoid swelling class inst.;
                          ref(quantity)actqty,cquant;
                          actqty:-actual.qual; cquant:-formal.prefqual;
                        if actqty=/=cquant then begin
                        if actqty=/=none then begin
                        if cquant=/=textclass
                       then begin ! qualification check as for :-;
                             if subclass(cquant,actqty)
                             then implqua:=QuaCheck and ftype=IREF
                        else if subclass(actqty,cquant)
                             then !ok; implqua:=false
                             else begin !*** check here for dual ext decl ***;
                                if ftype=IPTR or else (SportOk and then
                                !  sameclass(cquant,actqty);
                                   actqty is extquantity and then
                                   cquant is extquantity and then
                                   actqty.symb==cquant.symb  and then
                                   actqty.descr qua extbrecord.checklo
                                  =cquant.descr qua extbrecord.checklo and then
                                   actqty.descr qua extbrecord.checkhi
                                  =cquant.descr qua extbrecord.checkhi)
                                then begin errARG(-427); implqua:=false end
                                else errARG(427);
                             end;
                       end end end end;
                      end normal type check;
                  end case; end

             else if actualkind=K_error or actual.type=IELSE or
                     fkind=K_error then ! no testing, dummy actual exp ;
                  else errARG(421);

                  !testing on actual parameters to external non-Simula  
                   procedures with binding                            ;

                  if clf=Clf002 then begin
                     if formal.categ=C_name then begin
                        if actual.ctype=IIDN  then !ok;
                   else if actual.ctype=IIDNP then begin
                           if actual qua argumented.ident.meaning.kind
                              = K_array then !ok; else goto ER4 end
                   else if actual.ch = ICONS then begin
                           if actual.type=ITEXT then errARG(-245)
                           !*** accept text constants by address (???);
                           else if actual.type<>IREF then goto ER4;
                        end
                        else begin
                        ER4: error0(if actual.ch=ICONS
                                    then 178 else 179); StopScode;
                        end;
                     end;
                  end;
               end;
%+D            if option(rank('T'))<>NUL then begin
%+D                  outtext("end parameter-checking");outimage;
%+D                  outtext("stack picture");outimage;
%+D                  for expv:-exptop,expv.pred
%+D                      while expv=/=none do expv.dump;
%+D            end;
%           end *** lastnap.inuse ***;
parameterexit:
      end parameter;
%title ***  S W I T C H  ***
      exp class switchdef;
      begin ref(quantity) sw; ref(switchelement)elements;
            boolean plain;
            ! plain is true iff all the switch elements are local
              labels (categ=C_local and declared at the same blocklevel
              as the switch);

            procedure checkplainswitch;
            begin ref(switchelement)swel;
                  swel:-elements;
                  while swel=/=none do
                  begin if swel.blocklevel <> sw.encl.blev then
                        begin goto E; ! not a plain switch ; end;
                        swel:-swel.next;
                  end;
                  plain:=true;
            E:end;

            procedure emit;
            begin ref(switchelement)swel;
                  opc:=ISWIT;
                  coder.opq:-if sw.categ=C_virt and then sw.match=/=none
                             then sw.match else sw;
                  opilo:=if plain then '!1!' else '!2!'; call(coder);
                  swel:-elements;
                  while swel=/=none do
                  begin swel.emit;
                        notinconditional:=true;  ! (dummy call) ;
                        !last;opc:=ISWEE;
                        swel:-swel.next;
                  end;
                  opc:=ISWDE; call(coder);
            end emit;

      end switchdef;

      class switchelement(labelexp); ref(exp)labelexp;
      begin
            character     blocklevel;
%           ! blocklevel = if <labelexp is local/global label> then
%                             <block level of the label> else 0     ;
%           ! blocklevel=0 indicates that the corresponding switch is
%             not plain (block level of a label cannot be zero if it is
%             declared at the same block level as a switch)   ;
            ref(switchelement)next;

            procedure emit;
            begin labelexp.cl:=IEEXPcl; labelexp.emit end;

            if labelexp.type <> ILABE then begin if labelexp.type <> IELSE
            then error0(164) end;
            if labelexp.ctype=IIDN then begin
               checkasexp(labelexp qua identifier);
               if labelexp.meaning.categ=C_local
               then blocklevel:=labelexp.meaning.encl.blev ;
            end;
      end switchelement;
%title *****   recordactualuse   *****

%+N   procedure recordactualuse(meaning,actualargs);
%+N   ref(quantity)meaning; short integer actualargs;
%+N   begin ref(formal)form; ref(actualuse)act;
%+N         formcond:=actcond:=true;
%+N         form:-display(cblev).formals;
%+N         act:-new actualuse(linenr,actualargs);
%+N         while true do inspect form do begin
%+N            if ident=meaning.ident then begin
%+N               !insert new actualuse in this list;
%+N               act.next:-actuals; actuals:-act;
%+N               goto EXIT;
%+N            end;
%+N            form:-next; 
%+N         end
%+N         otherwise inspect new formal(meaning.kind,act) do begin
%+N            ident:=meaning.ident; next:-display(cblev).formals;
%+N            display(cblev).formals:-this formal; goto EXIT;
%+N         end;
%+N   EXIT:
%+N   end recordactualuse;

      ref(quantity)procedure qualification;
      begin ! if opdSymb is a class/record identifier the corresponding
              class quantity is delivered , else none;
            ref(quantity) cquant;
%+S         Freq(98):=Freq(98)+1;
            cquant:-meaningof(opdSymb);
            if cquant==none then cquant:-newnotseen(opdSymb);
            qualification:-cquant;
      end;

%+PQ  prior
      procedure enterblock;
      begin cblev:=char(rank(cblev)+1); crtblev:=char(rank(crtblev)+1);
            if rank(cblev) > maxblev then fatal0(299);
            inspect brctab(rank(lastblhi)) do begin
               inspect val(rank(lastbllo))             do begin
                   if kind=K_class then begin
                      if declquant.plev>one
                      then hide(declquant.prefqual,false);
                      unprotect(declquant);
                   end
              else if kind=K_prefbl then hide(declquant.prefqual,false);
                   makevisblock(this brecord);
               end;
               val(rank(lastbllo)):-none;
            end;
%+S         Freq(99):=Freq(99)+1;
      end;

end semchecker1;

end CHECKER1;
