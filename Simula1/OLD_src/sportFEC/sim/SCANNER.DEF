External class ERRMSG;
% External class ERRMSG="C:\GitHub\SimulaCompiler\Simula/src/sportFEC/bin/ERRMSG.jar";

ERRMSG class SCANNER;
%      -----------------------------------------------------------------
%      ---  COPYRIGHT 1988 by                                        ---
%      ---  Simula a.s.                                              ---
%      ---  Oslo, Norway                                             ---
%      ---                                                           ---
%      ---                 P O R T A B L E     S I M U L A           ---
%      ---              F R O N T - E N D    C O M P I L E R         ---
%      ---                   T h e    S c a n n e r                  ---
%      ---                                                           ---
%      --- Selection switches: DKIPMRZ                               ---
%      ---                                                           ---
%      ---    'D' Included when dump is wanted                       ---
%      ---    'I' Included to make compiler use inserted mnemonic    ---
%      ---    'K' Included always when quick capability wanted       ---
%      ---    'M' Included always when macro capability wanted       ---
%      ---    'P' Included to make compiler use quick procedures     ---
%      ---    'R' Included if full REAL capability wanted            ---
%      ---    'Z' Included at system generation (for "ZIMULA")       ---
%      ---                                                           ---
%      -----------------------------------------------------------------

%SELECT Z

begin

%SPORT ON
%REUSE ON
%-Z %RECORD ON

%+I %INSERT $SIMSRC/fec/common.mne
%+I %INSERT $SIMSRC/fec/parser.mne

% INSERT $SIMSRC/fec/scanner.mne
%INSERT C:/GitHub/SimulaCompiler/Simula/src/sportFEC/sim/SCANNER.MNE

%     communication scanner -> parser/errmsg/L2coder:
      short integer extid;
      integer repcount;  ! set by parser, #elts in repetition;
      ref(recognizer) lexScanner;

      procedure setP1line;
            line:-lexscanner.line.sub(1,lexscanner.linelength-1);

      procedure P1error(n); short integer n;
      begin setP1line; outP1message(lexscanner.linepos+1,n,'!2!');
      end;

      procedure P1warn(n); short integer n;
      begin setP1line; outP1message(lexscanner.linepos+1,n,'!1!');
      end;

%title *** DUMP PROCEDURES ***

%+D   procedure dump_opt(opt); character opt;
%+D   begin outtext(" OPT*"); outint(rank(opt),3); outchar('=');
%+D         outtext(DB(rank(opt))); end;

%+D   procedure dump_opd(opdhi,opdlo,optx); character opdhi,opdlo,optx;
%+D   begin text t; outtext(" OPD=");
%+D         if optx<>NUL then begin
%+D            outtext(DB(rank(optx))); outchar(' ');
%+D            if optx=ICHAR then begin
%+D               if opdlo>' ' and opdlo<'!127!' then outchar(opdlo)
%+D               else begin outchar('!'); outint(rank(opdlo),0);
%+D                          outchar('!') end end
%+D            else begin t:-nameof(opdhi,opdlo);
%+D               if t.length<=13 then outtext(t) else
%+D               begin outtext(t.sub(1,12)); outchar('+') end;
%+D            end;
%+D         end else begin 
%+D            outint(rank(opdhi),0); outchar(','); outint(rank(opdlo),0) end;
%+D   end of dump_opd;

%+D   procedure dump(who); text who;
%+D   begin if pos>1 then outimage; outtext(who);
%+D         if optx<>NUL then begin !*** DUMP THE PASSED OPERAND ***;
%+D            dump_opd(opdhi,opdlo,optx);
%+D            if lexScanner.opdline <> linenr then begin
%+D               outtext(" (l."); outint(lexScanner.opdline,5); outchar(')');
%+D         end end;
%+D         dump_opt(opt); outimage; !*** DUMP THE PASSED OPERATOR *** ;
%+D   end of dump;

%     **********   option(rank('2'))  tracing   *********

%+D   procedure WWW(t); text t; inspect sysout do
%+D   begin if pos>=50 then outimage; setpos(50); outtext(t) end;

%+D   procedure W0(t); text t;
%+D   begin WWW(t); sysout.outimage; end;
%+D
%+D   procedure W1(t,i); text t; short integer i; inspect sysout do
%+D   begin WWW(t); outint(i,5); outimage; end;
%+D
%+D   procedure W3(t,i1); text t; character i1; inspect sysout do
%+D   begin WWW(t); outtext(DB(rank(i1))); outimage; end;
%+D
%+D   procedure W8(t,i1,i2,i3,i4,i5,i6,i7,i8);
%+D   text t; short integer i1,i2,i3,i4,i5,i6,i7,i8; inspect sysout do
%+D   begin WWW(t); outint(i1,2);outint(i2,2);outint(i3,2);
%+D         outint(i4,2);outint(i5,2);outint(i6,2);
%+D         outint(i7,2);outint(i8,2); outimage; end;

%title *****   Macro handling: DefineLit   *****;

%+Z %+M component class DefineLit;
%+Z %+M begin ref(component) prev;
% %DEFINE is assumed to occur as declaration, i.e. optx=...=NUL
%+Z %+M       text defval; ref(symbolbox) defsym;
%+Z %+M       short integer pos1,pos2;
%+Z %+M
%+Z %+M       procedure detachswap;
%+Z %+M             detach;
%+Z %+M
%+Z %+M       prev:-parser; parser:-this component;
%+Z %+M       detachswap;
%+Z %+M
%+Z %+M   L:  if opt<>IEQ or else optx<>INOTY then goto ERR;
%+Z %+M       defsym:-boxof(opdhi,opdlo);
%+Z %+M       pos1:=lexscanner.linepos; detachswap;
%+Z %+M       if opt=ISMCL or else opt=ICOMA then begin
%+Z %+M          inspect new Macro(defsym) do begin
%+Z %+M             mhi:=opdhi; mlo:=opdlo; moptx:=optx;
%+Z %+M             P1coder.makevis(this Macro);
%+Z %+M          end;
%+Z %+M          if opt=ICOMA then begin detachswap; goto L end;
%+Z %+M       end
%+Z %+M       else ERR:  P1error(293);
%+Z %+M
%+Z %+M       parser:-prev;
%+Z %+M       inspect lexscanner do begin
%+Z %+M          atom:=EOL; linepos:=linelength end;
%+Z %+M       detachswap;
%+Z %+M end DefineLit;

%title *****   Macro handling: DefineMacro   *****;

%     DefineMacro is activated when %MACRO is recognised. The macro body
%     is read lien by line, each line is split if the parameter marker
%     (*/<integer>) is seen (see MacroLine below). The final line of
%     all macro definitions is the 'EOFline', i.e. a MacroLine
%     containing "%eof'!7!'". This line will, when the macro is expanded
%     cause current input (the macro) to be closed.
%
%     Note: if %MACRO was conditionally compiled, i.e. preceded by
%           selector testing (%+/-...), this PREFIX is stripped off
%           each line if present. The test is a text value compare,
%           no attempt is made to make any selector test. Thus, the
%           sequence of multi tests MUST BE THE SAME!!! (this does not
%           apply to the macro NAME, however).

%+M   component class DefineMacro;
%+M   begin ref(component) prev;
% %MACRO is assumed to occur as declaration, i.e. optx=...=NUL
%+M         text prefix; short integer preflng,linlen,startpos,scanpos;
%+M         text thisline;
%+M         prev:-parser; parser:-this component;
%+M         inspect lexscanner do
%+M         prefix:-if linepos>7 then copy(line.sub(1,linepos-7))
%+M                 else notext;
%+M         preflng:=prefix.length;
%+M         detach; !get macro name;
%+M         parser:-prev; prev:-none;
%+M         if cs<>IIDN or opt<>ICL then begin
%+M            P1warn(292); ! ??? and some more ... ;
%+M         end;
%+M         inspect new Macro(boxof(opdhi,opdlo) qua identsymbol)
%+M         do begin
%+M            last:-this sembox;
%+M            while true do begin
%+M         NXT:  inspect cursource do call(this input)
%+M               otherwise ; !ERROR;
%+M               linlen:=lexscanner.linelength;
%+M               if loadchar(line,0)='%' then begin
%+M                  if loadchar(line,1)=' ' then goto NXT;
%+M                  if linlen>=(preflng+9) then begin
%+M                     if prefix=line.sub(1,preflng) and then
%+M                        lowcase(copy(line.sub(preflng+1,9)))
%+M                         = "%endmacro"
%+M                     then goto EXIT;
%+M                  end;
%+M                  if linlen>=preflng and then
%+M                     prefix=line.sub(1,preflng)
%+M                  then begin thisline:-
%+M                             line.sub(preflng+1,linlen-preflng);
%+M                     goto scan;
%+M                  end;
%+M               end;
%+M               thisLine:-line.sub(1,linlen); 

%page

%+M         SCAN: !*** scan for macro parameter subst */int ***;
%+M               startpos:=1;
%+M         SCN:  while thisline.more do begin
%+M                  if thisline.getchar='*' then begin
%+M                     scanpos:=thisline.pos+1;
%+M                     if thisline.getchar='/' then begin
%+M                        if digit(thisline.getchar)
%+M                        then inspect new MacroLine do begin
%+M                           last:-last.next:-this MacroLine;
%+M                           while digit(thisline.getchar) do;
%+M                           par:=thisline.sub(scanpos,
%+M                                        thisline.pos-scanpos).getint;
%+M                           if par>npar then npar:=par;
%+M                           line:-copy(thisline
%+M                                  .sub(startpos,scanpos-startpos-2));
%+M                           startpos:=thisline.pos-1; goto SCN;
%+M                        end;
%+M                     end;
%+M                     thisline.setpos(scanpos-1);
%+M                  end;
%+M               end;
%+M               last:-last.next:-new MacroLine;
%+M               last qua macroLine.line:-
%+M                  copy(thisline.sub(startpos,thisLine.pos-startpos));
%+M               last qua macroLine.par:=-1;
%+M            end;
%+M   EXIT:    last.next:-EOFline;
%+D %+M        if option(rank('1'))<>NUL then dump;
%+M            P1coder.makevis(this Macro);
%+M         end;
%+M         inspect lexscanner do begin
%+M            linepos:=linelength; atom:=EOL end;
%+M   end;

%title *****   Macro handling: Macro and MacroLine   *****;

%     Macro constitutes the "head" of the definition, and is entered
%     into the symbol table 'curmeaning' field. All MacroLine's of
%     the body are linked to the 'next' field of Macro.
%
%     A DEFINED litteral is represented directly in mhi/mlo/moptx
%
%+M   sembox class Macro(symb);
%+M         ref(identsymbol) symb;
%+M   begin ref(sembox) last;
%+M         short integer npar;
%+Z %+M     character mhi,mlo,moptx; 

%+D %+M     procedure dump;
%+D %+M     if moptx<>NUL then dump_opd(mhi,mlo,moptx) else
%+D %+M     begin ref(MacroLine) first;
%+D %+M           if pos>1 then outimage;
%+D %+M           outtext("MACRO " & symb.symbol); outimage;
%+D %+M           first:-next; setpos(5);
%+D %+M           while first=/=none do begin
%+D %+M              if first.par>=0 then begin
%+D %+M                 outtext(first.line);
%+D %+M                 outtext(" :: */"); outint(first.par,0) end
%+D %+M              else begin
%+D %+M                 outtext(first.line.sub(1,first.line.length-1));
%+D %+M                 outimage; setpos(5) end;
%+D %+M              first:-first.next;
%+D %+M           end;
%+D %+M           setpos(1);
%+D %+M     end;

%+M   end;

%     MacroLine contains a) (part of) a body line, and b) a parameter
%     number. If the parameter number is zero, the line does not
%     contain any parameter markers. If a parameter marker is found
%     in a line, the line is split at that point, its 'par' is set to
%     the parameter number, and a new MacroLine is created for the
%     remainder of the line (and the process is repeated so that a
%     single body line may become many MacroLine's).
%
%     Note: the scanning for parameter markers is context insensitive.
%           Thus, parameter markers will have effect within comments,
%           identifiers, literals etc.  Note also, that parameter
%           markers given as actual parameters in a call may cause
%           unintended (lack of) effect.
 
%+M   sembox class MacroLine;
%+M   begin text line; short integer par;
%+M   end;

%+M   ref(MacroLine) EOFline;  ! constant;

%title *****   Macro handling: MacroCall   *****;

%     MacroCall is activated when the macro name is recognized as an
%     identifier. If the immediately following character is a left
%     parenthesis '(', this is taken as the start of a list of actual
%     parameters (terminated by a MATCHING right parenthesis).
%
%     The parameter list scanning is context insensitive. Thus, the
%     three characters '(', ')' and ',' are recognized in ANY context.
%     Actual parameters may, however, contain BALANCED pairs of
%     parentheses; within such a pair comma will NOT be seen as a
%     parameter separator.
%
%     MacroCall is substituted as current source, and the scanner is
%     reactivated. Whenever cursource is called, MacroCall will
%     deliver the next MacroLine.line, possible concatenated with
%     parameter value(s).

%     Note: Any call may have any number of parameters (incl. none).
%           Any parameter not given has the value NOTEXT; superfluous
%           parameters are skipped. The value of parameter zero (0) is
%           the macro name.
%           No spaces or other separators are inserted when line
%           fragments and parameter values are concatenated - actual
%           parameters may be e.g. identifier fragments.

%+M   input class MacroCall(mac);
%+M         ref(Macro) mac;
%+M   begin short integer npar;      ! number of parameters in call;
%+M         short integer parlevel;  ! parenthesis nesting level;
%+M         ref(MacroLine) last;
%+M         text array param(0:mac.npar);
%+M         text lexline;            ! saved state ;
%+M         short integer lexpos;    !             ;
%+M         short integer lexlen;    ! of scanner  ;
%+M
%+D %+M     procedure dump;
%+D %+M     begin ref(MacroLine) last;
%+D %+M           last:-mac.next;
%+D %+M           if pos>1 then outimage;
%+D %+M           while last.next=/=none do begin
%+D %+M              if last.par>=0 then begin
%+D %+M                 outtext(last.line); outtext(param(last.par)) end
%+D %+M              else begin
%+D %+M                 outtext(last.line.sub(1,last.line.length-1));
%+D %+M                 outimage end;
%+D %+M              last:-last.next;
%+D %+M           end;
%+D %+M           if pos>1 then outimage;
%+D %+M     end;
%+M
%+M         procedure close;
%+M         begin restoreScannerState; end;
%+M
%+M         procedure storechar;
%+M         begin if not t.more then begin
%+M                  t:-t & blanks(10); t.setpos(t.length-9) end;
%+M               t.putchar(lexscanner.atom);
%+M         end;
%+M
%+M         last:-mac.next; param(0):-mac.symb.symbol;
%+M         while last =/= none do begin
%+M            detach;
%+M            line:-last.line;
%+M            while last.par>=0 do begin
%+M               line:-line & param(last.par) &
%+M                     last.next qua MacroLine.line;
%+M               last:-last.next;
%+M            end;
%+M            lexscanner.linelength:=line.length;
%+M            lexscanner.line:-line;
%+M            last:-last.next;
%+M         end;
%+M   end;

      class input(inserted);
            boolean inserted;      ! true if this module is INSERT'ed;
      virtual: procedure close is procedure close; ;
      begin boolean liston;              ! stacked listing flag;
            character lexatom;           ! stacked scanner state;
            short integer lexpos,lexlen; ! stacked scanner state;
            text lexline;                ! stacked scanner state;
            short integer linlen;
            ref(input) prev;
            text t;

            procedure saveScannerState;
            inspect lexscanner do 
            begin lexatom:=atom; lexline:-line;
                  lexpos:=linepos; lexlen:=linelength;
                  liston:=listingon;
                  if inserted then incrlnr:=listingon:=false;
                  prev:-cursource; cursource:-this input;
                  !*** force an immediate call on cursource ***;
                  atom:=EOL; linepos:=linelength;
            end;

            procedure restoreScannerState;
            begin inspect lexscanner do begin
                     linepos:=lexpos; linelength:=lexlen;
                     atom:=lexatom; line:-lexline;
                  end;
                  listingon:=liston;
                  line:-lexscanner.line;
                  cursource:-prev; prev:-none;
                  if cursource=/=none
                  then incrlnr:=not cursource.inserted;
            end;

      end;


      input class SourceElt(fname);
            text fname;            ! source file file name;
      begin
            ref(infile) sf;        ! actual source file;
            text newim;            ! temp when inrecord;
            ref(input) inpt;       ! temp, file loop check;

            procedure close;
            begin if sf=/=sysin then sf.close;
                  restoreScannerState;
            end close;

            inspect lexscanner do begin
               !*** force reading when this input is closed ***;
               atom:=EOL; linepos:=linelength end;
            saveScannerState;
            lexscanner.line:-line:-blanks(  80+1  );
            if lowcase(copy(fname)) <> "sysin" then begin
               inpt:-prev;
               while inpt=/=none do begin
                  if inpt is SourceElt and then
                     inpt qua SourceElt.fname=fname
                  then begin diag(0):-fname; fatal0(237) end;
                  inpt:-inpt.prev;
               end;
               sf:-new infile(fname); sf.image:-line.sub(1,80);
               if not sf.open(sf.image) then openerror(fname);
            end else begin
               sf:-sysin; sf.image:-line.sub(1,80);
            end;
            while true do begin
               detach;
    NEXTIMAGE: if sf.inrecord then begin
%-Z %IMPLNONE OFF
            INRL: newIm:-newIm & sf.image; sf.image:-blanks(10);
                  if sf.inrecord then goto INRL;
                  t:- blanks(1); t:- sf.image.sub(1,sf.image.pos-1) & t;
                  lexScanner.line:- newIm & t; newIm:-notext;
                  line:-lexScanner.line;
                  if line.length>256 then begin
                     linlen:=255; P1warn(277);
                     lexScanner.line:-line:-line.sub(1,256);
                  end
                  else linlen:=line.length-1;
                  sf.image:-line.sub(1,linlen);
               end else
               begin
                  if sf.endfile then begin
                     line:-lexscanner.line:-"%eof!7!"; linlen:=4;
                     ! close called from directive ;
                     goto EXIT;
                  end;
                  linlen:=sf.image.pos-1;
               end;
%+S            SrcLine(linlen):=SrcLine(linlen)+1;
               if incrlnr then linenr:=linenr+1;
               if listingon then inspect listfile do begin
                  outint(linenr,6);  outtext(": ");
                  outtext(sf.image.sub(1,if linlen<listlength
                                then linlen else listlength));
                  outimage;
               end;
               if linlen = 0 then goto NEXTIMAGE;
               if linlen>signiflength then linlen:=signiflength;
               storechar(EOL,line,linlen);
      EXIT:    lexscanner.linelength:=linlen+1;
            end of source input read loop;
      end SourceElt;

      boolean incrlnr;  ! true if current module is not inserted;
      ref(input) cursource;
      boolean dummygen; ! dummy generation of blocks, see parser;

%+Z   boolean array selector(0:127);
%-Z   boolean       selector(  127);

      procedure SetSelectors(t,val); text t; short integer val;
      begin short integer i; boolean b;
            if val=0 then
            for i:= 47 step 1 until 127 do selector(i):=false;
            b := val <> 2; t.setpos(1);
            while t.more do begin
                  i:=rank(t.getchar); if i>127 then i:=i-128;
                  if i>47 then selector(i):=b;
            end;
      end;


%title ***  R E C O G N I Z E R  ***
%
% Class RECOGNIZER receives text lines one by one (in 'line') and
%       passes the located tokens to syntax PARSER.
%       Note that
%       - directive lines are treated before this scanner is entered
%       - empty lines are treated before this scanner is entered
%       - 'line' is stripped before entry, i.e. line.last=EOL
%
% Each retrieved token falls into one of the following two categories:
%       - operator (i.e. most keywords or the special symbols)
%       - operand  (identifiers, literals and keyword-literals)
%
% The following conventions are used as regards the communication
% between the scanner and the parser:
%
%   1) The tokens are passed in global variables OPT and (OPD,OPTX).

%   2) The operators are represented in OPT by corresponding I-symbol.

%   3) Operands are represented in OPD and OPTX by index and type, resp.
%
%   4) Whenever an operator is recognized, the parser is activated
%      to do further processing. If on the other hand the retrieved item
%      is an operand it is kept aside until the operator following it is
%      identified and the two are then passed over together (in OPD and
%      OPT respectively). Note: OPTX=0 in case that the item immedia-
%      tely preceding the currently passed operator is also an operator,
%      and that composite operators (e.g. 'or else') are passed as such.

%   5) While two operators may follow each other, operands must always
%      be separated by at least 1 operator. The scanner does NOT detect
%      this erroneous situation, it must be handled by the parser.

%   6) The position of the passed operand (operator) within the program
%      text is indicated by OPDLINE and OPDPOS (LINENR,OPTPOS) values;

%   7) The scanner will attempt to recover from detected errors. In most
%      cases, a missing character (such as a terminating " for a string)
%      is inserted.
%page
component class recognizer;
hidden protected skipzeroes,nxtsym,eqopt,
                 ampcount,i,startpos,hashpos,textpos,
                 startline,tempt,
                 scanahead,ISOcode;
begin
      boolean skipzeroes;          ! skip insignific. zeroes in number;
      character atom;              ! current input character;
      character nxtsym;            ! - scanning after keyW;
      character curidhi,curidlo;
      short integer hashpos;       ! hashbuf.pos - 1  (see loadchar);
      short integer linepos;
      short integer linelength;
      short integer opdpos;
      short integer optpos;
      short integer ampcount;      ! counting ampersands in number;
      short integer textpos;       ! hashbuf.pos - 1 for strings;
      short integer eqopt;
      short integer opdline;
      short integer i;             ! local temps;
      short integer startpos;      ! pos of first char;
      integer startline;           ! line number for start of operand;
      text hashbuf;          ! identifier, number and string buffer;
      text line;
      text curtitle;
      text tempt;                  ! temp. used locally;

%+Z   character array InputClass(0:255)
%-Z   character       InputClass(  255)
%     Skip_cl,    Illegal_cl, Illegal_cl, Illegal_cl, Illegal_cl, 
%        NUL         SOH         STX         ETX         EOT
%     Illegal_cl, Illegal_cl, Illegal_cl, Format_cl,  Format_cl,  
%        ENQ         ACK         BEL         BS          HT
%     Format_cl,  Format_cl,  Format_cl,  Format_cl,  Graphic_cl, 
%        LF          VT          FF          CR          SO
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%        SI          DLE         DC1         DC2         DC3
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%        DC4         NAK         SYN         ETB         CAN
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%        EM          SUB         ESC         FS          GS
%     Graphic_cl, Graphic_cl, Format_cl,  Basic_cl,   Basic_cl,   
%        RS          US          SP          !           "
%     Graphic_cl, Graphic_cl, Graphic_cl, Basic_cl,   Basic_cl,   
%        #           $           %           &           '
%     Basic_cl,   Basic_cl,   Basic_cl,   Basic_cl,   Basic_cl,   
%        (           )           *           +           ,
%     Basic_cl,   Basic_cl,   Basic_cl,   Digit_cl,   Digit_cl,   
%        -           .           /           0           1
%     Digit_cl,   Digit_cl,   Digit_cl,   Digit_cl,   Digit_cl,   
%        2           3           4           5           6
%     Digit_cl,   Digit_cl,   Digit_cl,   Basic_cl,   Basic_cl,   
%        7           8           9           :           ;
%     Basic_cl,   Basic_cl,   Basic_cl,   Graphic_cl, Graphic_cl, 
%        <           =           >           ?           @
%     Letter_cl,  Letter_cl,  LetterC_cl, Letter_cl,  Letter_cl,  !A..;
%     Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  
%     Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  
%     Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  
%     Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  
%     Letter_cl,  Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%        Z           [           \\           ]           hat
%     Uscore_cl,  Letter_cl,  Letter_cl,  Letter_cl,  LetterC_cl, 
%        _           `           a           b           c
%     Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  
%     Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  
%     Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  
%     Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  Letter_cl,  
%     Letter_cl,  Letter_cl,  Letter_cl,  Graphic_cl, Graphic_cl, 
%        x           y           z           {           |
%     Graphic_cl, Graphic_cl, Skip_cl,    Graphic_cl, Graphic_cl, 
%        }           ~           DEL         128         129  ...
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, Graphic_cl, 
%     Graphic_cl
      ;

%+PQ  prior
      procedure illegalChar;
      begin diag(0):-leftint(isorank(atom)); P1warn(276) end;

%+PQ  prior
      procedure nextLine;
      begin
      REP:  inspect cursource do call(this input)
            otherwise detach; !cursource none: end of source;
            atom:=loadchar(line,0); linepos:=1;
            while atom='%' do begin
               directive; if atom=EOL then goto REP end;
      end;

%title ***  R E C O G N I Z E R : directive  ***

      procedure directive; !*** returns next char (or EOL) in atom ***;
      begin character d; short integer i; text t,u;
            short integer cswa, cswb,startpos;

            text procedure linefield;
            begin short integer i;
                  while linepos<linelength do begin
                     nextChar;
                     if atom <> ' ' then goto L1;
                  end;
                  if u="select" then goto E; !linefield=notext is ok;
                  goto DIRWARN; !otherwise, notext not allowed;
              L1: i:=linepos;
                  while atom<>' ' and atom<>EOL do nextChar;
                  linefield:-copy(line.sub(i,linepos-i));
        E:  end;

            short integer procedure bytefield;
            begin text t; short integer result;
                  t:-linefield;
                  result:=if digit(t.getchar) and then t.length<=3
                          then t.getint else -1;
                  if result<0 or result>255 then goto DIRWARN;
                  bytefield:=result;
            end;

            procedure nextChar;
            begin atom:=loadchar(line,linepos); linepos:=linepos+1;
                  if atom='!9!' !TAB; then atom:=' ' else
                  if atom>'!127!' then atom:=char(rank(atom)-127) end;

            boolean procedure onoff;
            begin text t; t:-linefield; lowcase(t);
                  if t =  "on"  then onoff:=true
             else if t <> "off" then goto DIRWARN;
            end;

            startpos:=linepos;             -- first char is '%';
            nextChar;
            if atom = ' ' or else atom = EOL then goto SKIPLINE;

            if atom='+' then begin
               ! NOTE: selector(' ') is false ;
  SELPLUS:     while atom='+' or else selector(isorank(atom))
                  do nextChar;
               if atom=' ' then goto SELECTED;
               if atom<>'-' then goto SKIPLINE;
            end;
            if atom='-' then begin
  SELMINUS:    while atom='-' or else not selector(rank(atom)) do begin
                  nextChar;
                  if atom='+' then goto SELPLUS;
                  if atom=' ' then begin
  SELECTED:          ! remove select part from line and scan remainder;
                     if linepos >= linelength then goto SKIPLINE;
                     nextchar; goto EXIT;
                  end;
               end;
               goto SKIPLINE;
            end;

            linepos:=startpos; u:-linefield; lowcase(u);

            if u="title" then begin
               curtitle:-if linelength<=startpos+8 then notext
                         else copy(line.sub(startpos+7,linelength-8));
               curtitle:-sportid & " " & curtitle;
               goto PG;
            end;

            if u="page" then begin
  PG:          if listingon then inspect listfile do begin
                  eject(1); outtext(curtitle);
                  setpos(listlength-5); outint(page,5);
                  outimage; outimage;
               end;
            end
       else if u="copy" or u="insert" then begin
               t:-linefield; if t==notext then goto DIRWARN;
               new SourceElt(u="insert",t); goto EXIT;
            end
       else if u="eof" then begin
               cursource.close; if cursource == none then detach;
               goto EXIT;
            end
       else if u="definition" then begin
               recomp:=false; definition:=true end
       else if u="implementation" then begin
               recomp:=true;  definition:=false end
%      else if u="source" then    listingon:=listfile=/=none
%      else if u="nosource" then  listingon:=false
       else if u="list" then begin
               if onoff then listingon:=listfile=/=none
               else          listingon:=false;
            end
       else if u="nodummy" then dummygen:= not onoff
       else if u="slength" then begin
               i:=bytefield; signiflength:=i;
            end
       else if u="select" then begin
                  i:=0; t:-linefield;
                  if t="+" then begin i:=1; t:-linefield end
             else if t="-" then begin i:=2; t:-linefield end;
                  SetSelectors(t,i);
            end
       else if u="record" then Simuletta:= onoff
%+MZ   else if u="define" then begin
%+MZ           new DefineLit; goto EXIT end
%+M    else if u="macro" then begin
%+M            new DefineMacro; goto EXIT end
% %+M    else if u="endmacro" then begin
% %+M            if not (parser is macro_parser) then goto DIRWARN;
% %+M            parser qua macro_parser.terminate;
% %+M            linelength:=2; linepos:=0;
% % M            line:="; ";  ! terminate possible END-comment;
% %+M            storechar(';',line,0); storechar(EOL,line,1); goto EXIT;
% %+M         end
%+K    else if u="globali" then begin
%+K            opn:=IBLNO; call(P1coder);
%+K         end
%+D    else if u="setopt" then begin
%+D            simsymbol:-blanks(96); d:=' ';
%+D            while d=' ' do begin nextChar;  LOADD:  d:=atom end;
%+D            if d='+' or d='-' then begin while true do begin
%+D               nextChar;
%+D               if atom='+' or atom='-' then goto LOADD;
%+D               if atom=EOL or else atom=' ' then goto ENDP;
%+D               setopt(atom,if d='+' then '1' else NUL);
%+D            end end;
%+D    ENDP:   for i:=0 step 1 until 95
%+D             do simsymbol.putchar(option(i)); DEFCONST;
%+D            opdhi:=hashhi; opdlo:=hashlo; opn:=ISSWB; call(P1coder);
%+D         end
       else begin !*** output of switch/option setting to pass 2;
               if u="boundcheck" or u="nonecheck" or
%+Z               u="implnone" or
                  u="quacheck"   or u="reuse"     or u="sport"
               then begin
                  if onoff then cswb:=1 else cswb:=0;
                  if u="sport" then SportOK:= cswb=1;
                  cswa:= if u="boundcheck" then 256
                    else if u= "nonecheck" then 257
                    else if u=  "quacheck" then 258
                    else if u=     "reuse" then 259
%+Z                 else if u=  "implnone" then 260
                    else 261; ! "sport" ;
               end
          else if u="setswitch" then begin
                  cswa:=bytefield; cswb:=bytefield
               end
               else begin
                    cswa:=987; ! Signals unknown directive;
                    simsymbol:-line.sub(startpos,linelength-startpos+1);
                    DEFCONST;
                    cswb:=rank(hashhi)*256+rank(hashlo);
               end;
               P1coder.cswa:=cswa;
               P1coder.cswb:=cswb; opn:=ISSWA; call(P1coder);
            end;
            if false then begin
  DIRWARN:     if GiveNotes then P1warn(278) end;
  SKIPLINE: atom:=EOL; ! line processed, get next;
  EXIT:                ! ctnue on current line;
      end directive;

%title ***  R E C O G N I Z E R : graphic/national chars  ***

%+PQ  prior
      procedure ScanPastFormat;  ! Don't call from ScanComment! ;
      begin
            short integer startpos;
%+S         Freq(8):=Freq(8)+1;
     SCN1:  switch(NUL:Skip_cl) InputClass(rank(atom)) begin
            when Graphic_cl,Illegal_cl do begin
                 if
%+D                 atom = EOL and then
                    linepos = linelength
                 then begin nextLine; goto SCN1 end;
                 if maxnumoftags>0 then IllegalChar;
                 ! no error message after final end (CTRL-Z!!!);
                 goto SCAN end;
            when LetterC_cl do begin
                 startpos:=linepos; call(IdScanner);
                 if simsymbol <> "comment" then begin
                    linepos:=startpos; atom:='c'; goto EXIT end;
                 goto L1 end;
            when Exclam_cl do begin L1:
                 while atom<>';' do begin
                     if linepos < linelength then begin
                        atom:=loadchar(line,linepos); linepos:=linepos+1
                     end else nextLine;
                 end;
                 goto SCAN end;
            when Skip_cl,Format_cl do begin
     SCAN:       atom:=loadchar(line,linepos); linepos:=linepos+1;
%+D              if linepos > linelength
%+D              then internerr('!2!',sourceline);
                 goto SCN1 end;
%           when Letter_cl,Digit_cl,Uscore_cl,Basic_cl do goto EXIT;
            end case;
 EXIT:end;


%+PQ  prior
      procedure scanahead;
      begin
            while true do begin
               atom:=loadchar(line,linepos); linepos:=linepos+1;
%+D            if linepos > linelength then internerr('!2!',sourceline);
               switch(NUL:Skip_cl) InputClass(rank(atom)) begin
               when Skip_cl do;
               when Basic_cl,Letter_cl,Digit_cl,Exclam_cl,Format_cl,
                    LetterC_cl,Uscore_cl,Graphic_cl do goto EXIT;
               when Illegal_cl do begin
                    if atom = EOL then goto EXIT;
                    IllegalChar end;
               end case;
            end loop;
EXIT: end;


%     procedure ScanComment;
%     !*** NB - ignores illegal characters in comments ***;
%     begin
%     SCAN: while atom<>';' do begin
%                 if linepos < linelength then begin
%                    atom:=loadchar(line,linepos); linepos:=linepos+1;
%                 end else detach;
%           end;
%           atom:=' ';
%     end;

      procedure ISOcode;
      begin short integer oldpos,i,j;
            procedure getDigit;
            if InputClass(rank(atom)) = Digit_cl then begin
               j:=j+1; i:=10*i + isorank(atom) - 48; !isorank('0');
               ScanAhead;
%+S            Freq(9):=Freq(9)+1;
            end;
            oldpos:=linepos; ScanAhead;
%+S         Freq(9):=Freq(9)+1;
            getDigit; getDigit; getDigit; !*** max 3 digits ***;
            if j=0 or else i>255 or else atom<>'!' then begin
               atom:='!'; linepos:=oldpos end
            else atom:=isochar(i);
      end;

%+P   prior
      procedure OperandToParser;
      inspect parser do
      begin opt:=IROPD; getopt:=true;
%+S         PaFreq(rank(cs)):=PaFreq(rank(cs))+1;
%+D         if option(rank('1'))<>NUL then dump("scanner:");
%+D         if option(rank('2'))<>NUL
%+D         then W1("NEXT:"&DB(rank(cs)),rank(cs));
            call(this component !parser; );
            cs:=opt:=optx:=opdhi:=opdlo:=NUL;
      end;
%title ******   i d e n t i f i e r    s c a n   ******
      ref(identifierScanner) IdScanner;

      class identifierScanner;
            !*** NB: atom is always id-constituent at entry ***;
      hidden protected atomcl,hashbuf,hashpos;
      begin character atomcl;
            short integer hashpos;
            text hashbuf;

         hashbuf:-blanks(72); detach;
         while true do begin
            hashpos:=0;

     TEST:
               switch(NUL:Skip_cl) InputClass(rank(atom)) begin
               when Letter_cl,LetterC_cl,Uscore_cl,Digit_cl do begin
                    storechar(atom,hashbuf,hashpos); hashpos:=hashpos+1;
     SCAN:          atom:=loadchar(line,linepos); linepos:=linepos+1;
%+D                 if linepos>linelength then internerr('!2!',sourceline);
                    goto TEST;
                    end;
               when Graphic_cl,Illegal_cl do begin
                    if linepos=linelength then goto idterm;
                    IllegalChar; goto SCAN end;
               when Exclam_cl,Basic_cl,Format_cl do goto idterm;
               when NONE do goto SCAN;
               end case;

   idterm:  simsymbol:-lowcase(hashbuf.sub(1,hashpos));
%-Z %setopt +D
            detach;
%-Z %setopt -D

         end reuse-loop;
      end ***IdentifierScanner***;

%title ******   n u m b e r   s c a n   ******
       ref(unsignedInteger) unsignedInt;

       class unsignedInteger;
             !*** NB: atom is always digit at entry ***;
             !        (but maybe it's zero)            ;
       hidden protected radix,startpos,hexradix,decradix,i;
       begin character radix;
             short integer startpos,i;
             character hexradix= '!64!', ! char(rank('0') + 16); 
                       decradix= '!58!'; ! char(rank('0') + 10);

          detach;
          while true do begin
             startpos:=hashpos; radix:=decradix;
             while true do begin
                switch(NUL:'!255!') atom begin

                when '!1!':'!6!','!14!':'!31!','!35!','!36!','!63!',
%-A                  '!64!','!37!',
                     '!91!':'!94!','!96!','!123!':'!126!',
                     '!128!':'!255!' do
                     IllegalChar;

                when NUL,'_','!127!' do ;

                when EOL do begin
                     if linepos=linelength then goto nterm;
                     IllegalChar end;

                when 'r','R' do begin
                     i:=hashpos-startpos;
                     if (i=1 or else i=2) and then radix=decradix
                     then begin
                        i:=hashbuf.sub(startpos+1,i).getint;
                        if i=2 or i=4 or i=8 or i=16 then begin
                           radix:=char(48 !rank('0'); +i);
                           atom:='R'; goto digit;
                     end end;
                     goto nterm end;

                when '0' do
                     if not skipzeroes then begin
                        storechar(atom,hashbuf,hashpos);
                        hashpos:=hashpos+1 end;

                when '1':'9' do begin
                     if atom>=radix then begin
                        P1error(183); atom:='0' end;
             digit:  skipzeroes:=false;
                     storechar(atom,hashbuf,hashpos);
                     hashpos:=hashpos+1; end;

                when 'a':'f','A':'F' do begin
                     if radix<>hexradix then goto nterm;
                     if atom>='a' then atom:=char(rank(atom)-32);
                     goto digit end;

                when NONE do
                     goto nterm;

                end;

                atom:=loadchar(line,linepos); linepos:=linepos+1;
%+D             if linepos > linelength then internerr('!2!',sourceline)

             end  USLOOP;

      nterm: skipzeroes:=false;
             if startpos=hashpos then begin !*** store at least 1 zero;
                storechar('0',hashbuf,hashpos); hashpos:=hashpos+1 end
        else if radix<>decradix then begin
%+Z             short integer array Dec(0:100); !100 is enough!!!;
%-Z             short integer       Dec(  100); !100 is enough!!!;
                short integer carry,j; character k,N;
                if loadchar(hashbuf,hashpos-1)='R' then begin
                   !no legal digit found after R, it was not a radix
                    number after all!!!;
                   hashpos:=hashpos-1; radix:=decradix; goto nterm;
                end;
                ! Dec holds the partially converted number as decimal
                  digits, with Dec(k) being the most significant. The
                  digits move up thru the array during the algorithm;
                N:=char(hashpos);
                hashpos:= startpos + (if radix=hexradix then 3 else 2);
                N:=char(rank(N)-hashpos); radix:=char(rank(radix)-48);
                while N <> NUL do begin N:=char(rank(N)-1);
                    carry:=rank(loadchar(hashbuf,hashpos))-48;
                    if carry>9 then carry:=carry-7; !A->10, etc.;
                    hashpos:=hashpos+1;
                    for j:=0 step 1 until rank(k) do begin
                        carry:=carry + Dec(j)*rank(radix);
                        Dec(j):=rem(carry,10); carry:=carry//10;
                    end;
                    while carry<>0 do begin k:=char(rank(k)+1);
                        Dec(rank(k)):=rem(carry,10); carry:=carry//10;
                    end;
                end;
                hashpos:=startpos; k:=char(rank(k)+1);
                while k<>NUL do begin k:=char(rank(k)-1);
                    storechar(char(Dec(rank(k))+48),hashbuf,hashpos);
                    hashpos:=hashpos+1;
                end;
                !Now, the decimal number is stored in hashbuf, and
                 hashpos is correctly positioned at first free;
             end radix to decimal convert;

%-Z %setopt +D
             detach;
%-Z %setopt -D
          end reuse-loop;
       end ***unsignedInteger***;

%title ******   RECOGNIZER:   M a i n   L o o p    ******

               detach;  !*** to do initialisations ***;
               nextLine; goto ASSESS;
      NxtChar: atom:=loadchar(line,linepos); linepos:=linepos+1;
%+D            if linepos > linelength then internerr('!2!',sourceline);
               goto ASSESS;  !*** skip parser call;

      ReadPC:  atom:=loadchar(line,linepos); linepos:=linepos+1;
%+D            if linepos > linelength then internerr('!2!',sourceline);
      ParserC: inspect parser do begin
                  getopt:=true;
                  if optx=NUL then begin cs:=opt; getopt:=false end;
%+S               PaFreq(rank(cs)):=PaFreq(rank(cs))+1;
%+D               if option(rank('1'))<>NUL then dump("scanner:");
%+D               if option(rank('2'))<>NUL
%+D               then W1("NEXT:"&DB(rank(cs)),rank(cs));
                  call(this component !parser; );
                  opt:=optx:=opdhi:=opdlo:=NUL;
               end;

 ASSESS:    optpos  := linepos;

        switch(NUL:'!255!') atom begin

        when ';' do begin
%-A          opt:=ISMCL; goto ReadPC end;
%+A          goto NxtChar end;

        when EOL do begin
             if linepos = linelength then begin nextLine; goto ASSESS end;
             IllegalChar; goto NxtChar end;

        when ':' do begin
%+D          scanahead;
%-D          atom:=loadchar(line,linepos); linepos:=linepos+1;
             if atom = '=' then begin opt:= IASSG; goto ReadPC end;
%-A          if atom = '-' then begin opt:= IDENO; goto ReadPC end;
             opt:= ICL;  goto ParserC end;

        when ',' do begin
             opt:=ICOMA; goto ReadPC end;

        when '(' do begin
             opt:=ILFPA; goto ReadPC end;

        when ')' do begin
             opt:=IRGPA; goto ReadPC end;

        when '.' do begin
             scanahead;
%            atom:=loadchar(line,linepos); linepos:=linepos+1;
             if InputClass(rank(atom))=Digit_cl then begin
                if optx<>NUL then OperandToParser;
                goto ndot end;
             opt:=IDOT; goto ParserC; end;

%-A     when '!' do begin
%-A          goto SawComment end;

        when '&' do begin
%+D          scanahead;
%-D          atom:=loadchar(line,linepos); linepos:=linepos+1;
             if InputClass(rank(atom))=Digit_cl or else atom='&' or else
                atom='-' or else atom='+'
             then begin
                if optx<>NUL then OperandToParser;
                goto nampsand end;
             opt:=ICONC; goto ParserC; end;

        when '*' do begin
             scanahead;
%            atom:=loadchar(line,linepos); linepos:=linepos+1;
%-A          if atom = '*' then opt:= IPOWE
%-A          else begin opt:= IMULT; goto ParserC end;
%+A          opt:= IMULT;
             end;

        when '+' do begin
             opt:=IPLUS;
             end;

        when '-' do begin
             opt:= IMINU;
             scanahead;
%            atom:=loadchar(line,linepos); linepos:=linepos+1;
             if atom='-' then begin
                if not SportOK then P1warn(233);
                nextLine; goto ASSESS;
             end;
             goto ParserC;
             end;

        when '/' do begin
             scanahead;
%            atom:=loadchar(line,linepos); linepos:=linepos+1;
%-A          if atom <> '/' then begin opt:=ISLAS; goto ParserC end;
%-A          opt:= IIDIV end;
%+A          opt:= ISLAS end;

        when '<' do begin
%+D          scanahead;
%-D          atom:=loadchar(line,linepos); linepos:=linepos+1;
             if atom = '>' then       opt:= INE else
             if atom <>'=' then begin opt:= ILT; goto ParserC end
             else                     opt:= ILE; end;

        when '=' do begin
%+D          scanahead;
%-D          atom:=loadchar(line,linepos); linepos:=linepos+1;
%+A          opt:= IEQ;
%-A          if atom = '=' then begin opt:= IRFEQ; goto ReadPC end;
%-A          if atom <>'/' then begin opt:= IEQ; goto ParserC end;
%-A          opt:= IRFNE;
%-A %+D      scanahead;
%-A %-D      atom:=loadchar(line,linepos); linepos:=linepos+1;
%-A          if atom <> '=' then begin P1warn(273); goto ParserC end;
             end;

        when '>' do begin
%+D          scanahead;
%-D          atom:=loadchar(line,linepos); linepos:=linepos+1;
             if atom <> '=' then begin opt:=IGT; goto ParserC end;
             opt:= IGE end;

%+A     when '!64!' do !commercial at;
%+A          opt:= IADDR;

%+A     when '!37!' do !percent;
%+A          opt:= IPCNT;

        when NUL,'!127!','!8!':'!13!','!32!' do
             goto NxtChar;

%title ***  R E C O G N I Z E R : string  -  character  ***

        when '"' do begin
             if optx<>NUL then OperandToParser;
             opdline := linenr; textpos:=0;
 QUOTE:      startpos:=linepos;  i:=textpos;
   QREP1:    
             atom:=loadchar(line,linepos); linepos:=linepos+1;
             if atom<>'"' then begin
                if atom <> EOL or else linepos < linelength then begin
                   if atom='!' then ISOcode;
                   storechar(atom,hashbuf,textpos); textpos:=textpos+1;
                   goto QREP1
                end;
                !*** insert missing " before rpar, semic or EOL ***;
                linepos:=startpos;      textpos:=i;
                while linepos<linelength do begin
                   atom:=loadchar(line,linepos); linepos:=linepos+1;
                   if atom=')' or atom=';' then goto QWARN;
                   textpos:=textpos+1;
                end;
   QWARN:       P1warn(275);
             end
             else begin !*** " found, check for "" ***;
                scanahead;
%               atom:=loadchar(line,linepos); linepos:=linepos+1;
                if atom='"' then begin
                   storechar(atom,hashbuf,textpos); textpos:=textpos+1;
                   goto QUOTE end;
             end;
             scanPastFormat;
             if atom='"' then begin
                if hashbuf.length-textpos < 80 then begin
                   !*** make room for largest poss. concatenation ***;
                   tempt:-blanks(80); hashbuf:- hashbuf & tempt end;
                goto QUOTE;
             end;
             optx:=ITEXT; parser.cs:=ICONS;
             if textpos=0 then opdlo:=INOTE !empty string==notext;
             else begin
                simsymbol:-hashbuf.sub(1,textpos);
                DEFCONST;
                opdhi:=hashhi; opdlo:=hashlo;
                if hashbuf.length > 80 then hashbuf:- blanks(80);
                !*** avoid storage waste of large text constants ***;
             end;
             goto OPERAND2 end;

        when ''' do begin
             if optx<>NUL then OperandToParser;
             scanahead;
%            atom:=loadchar(line,linepos); linepos:=linepos+1;
             if atom=EOL then begin
                P1error(182); nextLine; goto ASSESS end;
             if atom='!' then ISOcode;
             opdlo:=atom; optx:=ICHAR; parser.cs:=ICONS;
             scanahead;
%            atom:=loadchar(line,linepos); linepos:=linepos+1;
             if atom=''' then begin
                scanahead;
%               atom:=loadchar(line,linepos); linepos:=linepos+1;
%+D             if linepos > linelength then internerr('!2!',sourceline)
             end else begin
                P1warn(274); if atom='!' then scanahead;
             end;
             goto OPERAND end;

%title ***  R E C O G N I Z E R : Number  ***

        when '0':'9' do begin
     numr:  if optx<>NUL then OperandToParser;
            skipzeroes:=atom='0'; call(unsignedInt); optx:=IINTG;
            if atom='.' then begin scanahead;
%+S            Freq(9):=Freq(9)+1;
     ndot:     optx:=IREAL;
               storechar('.',hashbuf,hashpos); hashpos:=hashpos+1;
               if InputClass(rank(atom))<>Digit_cl then goto NumERR;
               call(unsignedInt);
            end;
            if atom='&' then begin scanahead;
%+S            Freq(9):=Freq(9)+1;
     nampsand: optx:=IREAL; !***ILONG;
               storechar('&',hashbuf,hashpos); hashpos:=hashpos+1;
               if atom='&' then begin optx:=ILONG; scanahead;
%+S               Freq(9):=Freq(9)+1;
               end;
               if atom='+' then begin scanahead;
%+S               Freq(9):=Freq(9)+1;
               end
          else if atom='-' then begin
                  storechar(atom,hashbuf,hashpos); hashpos:=hashpos+1;
%+S               Freq(9):=Freq(9)+1;
                  scanahead end;
               if InputClass(rank(atom)) = Digit_cl then begin
                  skipzeroes:=atom='0'; call(unsignedInt) end
               else begin
     numERR:      storechar('0',hashbuf,hashpos); hashpos:=hashpos+1;
                  P1error(181); !invalid numerical constant;
                  while InputClass(rank(atom)) = Digit_cl or else
                        atom='&' or else atom='.'
                     do scanahead;
               end;
            end;
            simsymbol:-hashbuf.sub(1,hashpos); hashpos:=0;
            DEFCONST; opdhi:=hashhi; opdlo:=hashlo;
            parser.cs:=ICONS; goto OPERAND;
        end;
%title  ******   I d e n t i f i e r   ******;

%+Z     when '_' do begin
%+Z         if option(rank('X'))<>NUL then goto idscan;
%+Z         IllegalChar; goto NxtChar end;

        when 'A':'Z','a':'z' do begin
    idscan: i:=linepos; ! == POS of first ident character ;
    idloop:
%+D         if linepos>linelength then internerr('!2!',sourceline);
            switch(NUL:'!255!') loadchar(line,linepos) begin
            when '0':'9','a':'z','A':'Z','_' do
                 begin !*** identifier constituents ***;
                 linepos:=linepos+1; goto idloop; end;
            when NUL:'!6!','!14!':'!31!','!35!':'!37!','!63!','!64!',
                 '!91!':'!94!','!96!','!123!':'!255!' do
       Lidi:     begin linepos:=i;
                 call(IdScanner); end;
            when EOL do begin !*** end-of-line or illegal ***;
                 if linepos<>linelength-1 then goto Lidi;
                 goto idterm end;
            when NONE do begin !*** identifier terminators ***;
     idterm:     atom:=loadchar(line,linepos); linepos:=linepos+1;
                 simsymbol:-line.sub(i,linepos-i);
                 end;

            end identifier scan;

           DEFIDENT;
           curidhi:=hashhi; curidlo:=hashlo;

 IdentifierFound:
%+M        inspect boxof(curidhi,curidlo) qua identsymbol.curmeaning do
%+Z %+M    if this sembox qua macro.moptx<>NUL then begin
%+Z %+M       if optx<>NUL then OperandToParser;
%+Z %+M       parser.cs:=ICONS;
%+Z %+M       opdhi:=this sembox qua macro.mhi;
%+Z %+M       opdlo:=this sembox qua macro.mlo;
%+Z %+M       optx :=this sembox qua macro.moptx; goto OPERAND end else
%+M         inspect new MacroCall(true,this sembox) do begin
%+M            ScanPastFormat;
%+M            if atom = '(' then begin
%+M               parlevel:=npar:=1;
%+M         NXT:  while parlevel <> 0 do begin
%+M                  scanahead;
%+M                  while atom=EOL do begin
%+M                     atom:=' '; storechar; nextLine end;
%+M                  if atom=',' then begin if parlevel=1 then begin
%+M         NP:         if npar<=mac.npar
%+M                     then param(npar):-copy(t.sub(1,t.pos-1));
%+M                     t.setpos(1); npar:=npar+1; goto NXT end
%+M                  end
%+M             else if atom='(' then parlevel:=parlevel+1
%+M             else if atom=')' then begin
%+M                     parlevel:=parlevel-1;
%+M                     if parlevel=0 then goto NP
%+M                  end;
%+M                  storechar;
%+M               end;
%+M               scanahead;
%+M            end;
%+M            saveScannerState; !activates the macro as current input;
%+D %+M        if option(rank('1'))<>NUL then dump;
%+M            goto ASSESS;
%+M         end;

%title ******   RECOGNIZER:  Identifier found   ******

           if curidhi<>NUL or else curidlo>IFALS then begin
 SAWRID:      if optx<>NUL then OperandToParser;
              optx:=INOTY; parser.cs:=IIDN;
 RESKW:       opdhi:=curidhi; opdlo:=curidlo;
 OPERAND:     opdline := linenr;         !*** from number and ident;
 OPERAND2:    opdpos  := optpos; goto ASSESS;
           end;

%          if curidlo <= IFALS and then curidhi = NUL then begin
              ! ***** keyword *****;
              opt:=curidlo;      !*** operator:  ;
              switch(NUL:IFALS) curidlo begin

%-A           when ICOMN do begin
%-A SawComment:    while atom<>';' do begin
%-A                      if linepos < linelength then begin
%-A                         atom:=loadchar(line,linepos);
%-A                         linepos:=linepos+1;
%-A                      end else nextLine;
%-A                end;
%-A                goto NxtChar end;

%-A           when IAND do begin
%-A                nxtsym:=ITHEN; eqopt:= rank(ICAND) end;

%-A           when ISWIT do begin
%-A                if SportOK then begin ScanPastFormat;
%-A                  if atom='(' then begin opt:=ICASE; goto ReadPC end;
%-A                end;
%-A                goto ParserC; end;

%-A           when IWHEN do begin
%-A                if SportOK then begin
%-A                   nxtsym:=INONE; eqopt:= rank(IUPLS); goto SawKeyw;
%-A                end;
%-A                goto ParserC; end;

%-A           when IGO   do begin
%-A                nxtsym:=ITO; eqopt:=-284; opt:=IGOTO end;

%-A           when IHIDD do begin
%-A                nxtsym:=IPRTC; eqopt:= rank(ITO) end;

              when ILONG do begin
                   nxtsym:=IREAL; eqopt:=-281 end;

%-A           when IOR   do begin
%-A                nxtsym:=IELSE; eqopt:= rank(ICOR) end;

%-A           when IPRTC do begin
%-A                nxtsym:=IHIDD; eqopt:= rank(ITO) end;

              when ISHOR do begin
                   nxtsym:=IINTG; eqopt:=-280 end;

%-A           when ITO   do begin
%-A                P1warn(279); opt:=IGOTO; goto ParserC end;

%-A           when IRCRD do begin
%-A                if Simuletta then goto ParserC;
%-A                opt:=NUL; curidlo:=recordindex; goto SAWRID end;

%-A           when IVIRT do begin
%-A                ScanPastFormat; if atom <> ':' then begin
%-A                   P1warn(283); goto ParserC end;
%-A                goto ReadPC end;

              when INONE,INOTE,ITRUE,IFALS do begin
                 !*** operand found, continue scan;
                 if optx<>NUL then OperandToParser;
                 parser.cs:=ICONS;
                 optx:=
%-A                          if curidlo=INOTE then ITEXT
%+A                          if curidlo=INOBO then IENTR
%+A                     else if curidlo=INOFI then IFIEL
%+A                     else if curidlo=INONA then INAME
%+A                     else if curidlo=INOSI then ISIZE
%+A                     else if curidlo=INOWH then ILABE
                        else if curidlo=INONE then IREF else IBOOL;
                 goto RESKW;
              end;

%title ***  R E C O G N I Z E R : Begin - end  ***

              when IBEGI do begin
                   maxnumoftags:=maxnumoftags+1;
                   goto ParserC; end;

              when IEND  do begin
                   while opt = IEND do begin
                      maxnumoftags:=maxnumoftags-1;
                      inspect parser do begin
                         getopt:=true;
                         if optx=NUL then begin
                            cs:=opt; getopt:=false end;
%+S                      PaFreq(rank(cs)):=PaFreq(rank(cs))+1;
%+D                      if option(rank('1'))<>NUL then dump("scanner:");
%+D                      if option(rank('2'))<>NUL
%+D                      then W1("NEXT:"&DB(rank(cs)),rank(cs));
                         call(this component !parser; );
                         cs:=opt:=optx:=opdhi:=opdlo:=NUL;
                      end;
            FindEnd:  !*** look for semicolon or special keyword ***;
                      if atom=';' then begin
              SawSMCL:   opt:=ISMCL; optpos:=linepos;
                         atom:=loadchar(line,linepos);
                         linepos:=linepos+1;
%+D                      if linepos > linelength
%+D                      then internerr('!2!',sourceline);
                      end
                      else begin
                         while InputClass(rank(atom))>LetterC_cl
                         do begin
%-Z %setopt +D
                            if atom=EOL then nextLine
                            else begin atom:=loadchar(line,linepos);
                                 linepos:=linepos+1 end;
%-Z %setopt -D
                            if atom=';' then goto SawSMCL;
                         end;
     
                         if atom='e' or else atom='w' or else
                            atom='o' or else atom='E' or else
                            atom='W' or else atom='O'
                         then begin
                            call(IdScanner);
                            ! see whether it is a terminating keyword;
                            if simsymbol="end"   then opt:=IEND  else
                            if simsymbol="else"  then opt:=IELSE else
                            if simsymbol="when"  then opt:=IWHEN else
                            if simsymbol="otherwise" then opt:=IOTHW
                            else goto FindEnd;
                         end
                         else begin
                            while InputClass(rank(atom)) <= Uscore_cl
                            do begin
                               atom:=loadchar(line,linepos);
                               linepos:=linepos+1;
                            end;
                            goto FindEnd;
                         end;
                      end;
        TESTENDCOUNT: if maxnumoftags=0 then begin !*** FINAL END ***;
                         if opt=ISMCL then ScanPastFormat;
                         !*** fix DOS CTRL-Z problem ***;
                         if atom<>'!26!' then P1warn(288);
                         while true do detach; !skip to EOF;
                      end;
                   end *** while opt=IEND ***;
                   goto ParserC; end;

              when NONE do goto ParserC; end *** case ***;

  SawKeyW:    curidhi:=curidlo:=NUL;
              ScanPastFormat; startpos:=linepos;
              if InputClass(rank(atom)) < Digit_cl then begin
                 call(IdScanner); DEFIDENT;
                 if hashlo=nxtsym and then hashhi=NUL then begin
                    if eqopt>0 then opt:=char(eqopt);goto ParserC;
                 end;
                 curidhi:=hashhi; curidlo:=hashlo;
              end;
              if eqopt < 0 then P1warn(-eqopt);
              if curidlo<>NUL or else curidhi<>NUL then begin
                 inspect parser do begin
                    getopt:=true;
                    if optx=NUL then begin cs:=opt; getopt:=false end;
%+S                 PaFreq(rank(cs)):=PaFreq(rank(cs))+1;
%+D                 if option(rank('1'))<>NUL then dump("scanner:");
%+D                 if option(rank('2'))<>NUL
%+D                 then W1("NEXT:"&DB(rank(cs)),rank(cs));
                    call(this component !parser; );
                    cs:=opt:=optx:=opdhi:=opdlo:=NUL;
                 end;
                 optpos:=startpos; goto IdentifierFound; end;

%          end *** keywords ***;

%            if optx<>NUL then begin
%               opt:=IROPD; call(parser); end;
%            optx:=INOTY; ! identifier;
% RESKW:     opdhi:=curidhi; opdlo:=curidlo;
% OPERAND:   opdline := linenr;         !*** from number and ident;
% OPERAND2:  opdpos  := optpos; goto ASSESS;

             goto ParserC;
           end *** identifier scan ***;


        when NONE do begin
    Mill:    IllegalChar; goto NxtChar end;

        end *** main loop case ***;

      goto ReadPC;

end recognizer;
%title ***  L 2 C O D E R  ***

      idpack class protpack; ;

      ref(L2coder) P1coder;
      outcodefile class L2Coder;
      hidden protected notok,locals,ctype,ckind,dimcount,iii,jjj,
                       lanhi,lanlo,firstarr,fvis,x,pq,virq,cbrec,xbrec,
                       cquant,vquant,xquant,cvispack,lastlinenr,
                       NewQuant,brecterm,chainVis,!*** store3chars,;
                       forbrec,L2max,L2limit,
                       cqual, iihi,iilo,specErr;
      begin
            boolean notok,locals;
            character ctype,ckind;
            character iihi,iilo;
            character lanhi,lanlo; ! language of external procedure;
            short integer L2p;
%+Z         short integer L2max   =  256; !*** to minimize space ***;
%-Z         short integer L2max   = 2048;
            short integer L2limit = L2max-7;
            short integer cqual;
            short integer cswa,cswb; !parameters to setswitch directive;
            short integer dimcount;
            short integer iii,jjj,lastlinenr; ! working variables;
            ref(symbolbox) symx;
            ref(quantity)firstarr;
            ref(idpack) fvis,x;
            ref(quantity) pq,virq;
            ref(brecord)cbrec,xbrec,forbrec;
            ref(quantity)cquant,vquant,xquant;
%                  ! xbrec and xquant are utility variables used within
%                    one active phase of the L2Coder.  They never
%                    carry information from one phase to another.
            ref(quantity)p_or_c_qt;
%                    p_or_c_qt is used to reference the current
%                    procedure or class quant during treatment of its
%                    declaration.  It carries significant information
%                    from one active phase to another in the special
%                    case where ="..." is allowed after all declaring
%                    occurencies of identifiers.
%                    See LIDCLP, LIDCLC and LIEXNM ;

            ref(idpack)cvispack; ref(brecord) lastBrec; text L2buf;

            procedure specErr(n); short integer n;
            begin diag(0):-nameof(opdhi,opdlo); P1error(n); end;

%+PQ        prior
            procedure NewQuant(qcateg); character qcateg;
            inspect new quantity do begin
%+S                 Freq(10):=Freq(10)+1;
                    type:=ctype; kind:=ckind;
                    categ:=qcateg; line:=linenr;
                    plev:=one;
                    ftag:=-cqual;
                    symb:-boxof(opdhi,opdlo);
                    if qcateg <> C_virt
                    then cquant:-cquant.next:-this quantity
               else if cbrec.favirt==none
                    then cbrec.favirt:-vquant:-this quantity
                    else vquant:-vquant.next:-this quantity
            end;

%+PQ %+M    prior
%+M         procedure makeVis(mdef); ref(Macro) mdef;
%+M         begin if cbrec.preinsp == none then cbrec.preinsp:-
%+M                                 new stackedb(NUL,NUL,zero,NUL,none);
%+M               inspect mdef.symb do begin
%+Z %+M              if curmeaning =/= none
%+Z %+M              then note1id(293,this symbolbox);
%+M                  inspect cbrec.preinsp do
%+M                    inspect new stackedi(idhi,idlo) do begin
%+M                       next:-redeclChain; redeclChain:-this stackedi;
%+M                       prevmeaning:-curmeaning;
%+M                  end;
%+M                  curmeaning:-mdef;
%+M               end;
%+M         end;

%+PQ        prior
            procedure brecinit(breckind); character breckind;
            begin ref(brctab2) tab2;
               inspect new brecord do begin
                    blnohi:=nextblhi; blnolo:=nextbllo;
                    kind:=breckind; line1:=linenr;
                    if nextbllo='!255!' then begin
                       nextbllo:=NUL;
                       nextblhi:=char(rank(nextblhi)+1);
                    end else nextbllo:=char(rank(nextbllo)+1);
                    cquant:-fpar:-new quantity; fpar.categ:=C_unknwn;
                    fpar.encl:-cbrec;
                    tab2:-brctab(rank(blnohi));
                    if tab2==none then begin
                      tab2:-new brctab2; brctab(rank(blnohi)):-tab2 end;
                    tab2.val(rank(blnolo)):-cbrec:-this brecord;
               end inspect brecord;
            end ***brecinit***;

%+PQ        prior
            procedure brecterm;
            inspect cbrec do begin
%+M               while preinsp =/= none do begin
%+M                  inspect preinsp.redeclChain do begin
%+M                     boxof(rehi,relo) qua identsymbol
%+M                     .curmeaning:-prevmeaning;
%+M                     preinsp.redeclChain:-next;
%+M                  end otherwise preinsp:-none;
%+M               end;
                  xquant:-fpar;
                  fpar:-fpar.next;
                  if xquant.encl==none
                  then begin cquant:-none; cbrec:-none end
                  else begin
                       cbrec:-xquant.encl;
                       cquant:-cbrec.fpar;
                       while cquant.next=/=none do cquant:-cquant.next;
                       vquant:-cbrec.favirt;
                       if vquant=/=none then
                       while vquant.next=/=none do vquant:-vquant.next;
                  end;
                  ! not used: line2:=linenr;
                  if stmtag <> NUL or else dcltag <> NUL
                     or else inrtag <> NUL
                  then begin hasCode:=true;
                     if stmtag <> NUL and then dcltag <> NUL
                     then stmtag:='!3!';
                     if inrtag<>NUL then begin
                        if stmtag<>NUL
                        then inrtag:=char(rank(stmtag)+1)
                   else if dcltag<>NUL then inrtag:='!3!';
                     end;
                  end hascode;
            end brecterm;

%+PQ        prior
            procedure chainVis(hidp); boolean hidp;
%-Z %IMPLNONE OFF
            inspect (if hidp then new idpack else new protpack) do begin
                  line:=linenr; idhi:=opdhi; idlo:=opdlo;
                  if cbrec.hidlist==none
                  then cvispack:-cbrec.hidlist:-this idpack
                  else cvispack:-cvispack.next:- this idpack;
            end;

            procedure storecharint(ch,int);
                  character ch; short integer int;
                  store3chars(ch,char(int//256),char(rem(int,256)));

%+P         prior
            procedure store3chars(ch1,ch2,ch3);
                  character ch1,ch2,ch3;
            begin storechar(ch1,L2buf,L2p  );
                  storechar(ch2,L2buf,L2p+1);
                  storechar(ch3,L2buf,L2p+2); L2p:=L2p+3;
%+S               Freq(11):=Freq(11)+1;
            end;

            procedure outbuffer;
            begin text fname;
%+S               Freq(12):=Freq(12)+1;
%+D               if option(rank('5'))<>NUL then inspect sysout do begin
%+D                  if pos>1 then outimage;
%+D                  outtext(" L2output: (l. ");
%+D                  outint(linenr,5);outchar(')');
%+D                  outtext(" OPN=EXNM (end buffer), L2p=");
%+D                  outint(L2p,0);
%+D               end;
                  storechar(IEXNM,L2buf,L2p);
                  if L2OUPT==none then
                  begin
                     setaccess("%NOBUFFER");
                     if not open then begin
                        fname:-filename; openerror(fname) end;
                     L2OUPT:-this outbytefile;
                  end;
                  outtext(L2buf);
                  L2p:=0;
            end;


%      ******************   M a i n   l o o p   ***********************

    detach;
    L2codebuffer:-L2buf:-blanks(L2max); goto CheckNxt;
%   L2codebuffer:-L2buf:-blanks(1024 ); goto CheckNxt;

    while true do begin

     NEXTOPN:
       if lastlinenr<linenr then begin
          if L2p > L2max-4 then outbuffer;
          lastlinenr:=linenr; storecharint(ILINE,lastlinenr);
       end;

%-Z %setopt +D
       detach;   !***   R e a c t i v a t i o n   p o i n t   ***;
%-Z %setopt -D

   CheckNxt:
       if L2p > L2limit then outbuffer;

%+D    if option(rank('5'))<>NUL then inspect sysout do begin
%+D         if pos>1 then outimage;
%+D         outtext(" L2output: (l. "); outint(linenr,5); outchar(')');
%+D         outtext(" OPN="); outtext(DB(rank(opn))); setpos(32);
%+D         if optx<>NUL then begin outtext("OPD=" &
%+D                    DB(rank(optx)) & " ");
%+D            if optx=ICHAR then begin
%+D               if opdlo>' ' and opdlo<'!127!' then outchar(opdlo)
%+D               else begin outchar('!'); outint(rank(opdlo),0);
%+D                          outchar('!') end
%+D            end else outtext(nameof(opdhi,opdlo));
%+D         end else if opdlo<>NUL or else opdhi<>NUL then begin
%+D            outtext("OPD=("); outint(rank(opdhi),0);
%+D            outchar(',');     outint(rank(opdlo),0); outchar(')');
%+D         end;
%+D    end dumpfromparser;


%+S    L2Freq(rank(opn)):=L2Freq(rank(opn))+1;

       switch(NUL:IMXMX) opn begin

       when
       IBNDE, IDCLE, ILFPA, IRGPA,
       IIF,   ITHEN, IELSE, IEEXP,
       IPLUS, IMINU, ISLAS, IMULT, IIDIV, IPOWE,
       IEQ,   INE,   IGE,   IGT,   ILE,   ILT,
       IAND,  IEQV,  IIMP,  IOR,   IRFEQ, IRFNE,
       IUMNS,        INOT,  IABTE, IIFSB,
       IINSP, ITHSB, IGOE,  IELSB, IIFSE,
       IASSG, IDENO, ITRUE, IFALS, IDO,   IFDNO, IUNTI,
       IASGE, ICOMA, IARGE, ICAPE, IESTM, IOTHE,
       ICONC, ICAND, ICOR,  ISMCL  do begin !1 byte;
 OPNOUT:    storechar(opn,L2buf,L2p); L2p:=L2p+1;
            goto NEXTOPN;
            end;

       when
%+D    ISSWB, !new options directly from %SETOPT;
       ISIDN, IIDN,  IIDNP, IDOT,  IDOTP, INEW,  INEWP, ISTEP,
       IIN,   IIS,   IQUA,  ITHIS, IELME  do begin !3 byte;
 OPDOUT:    storechar(opn  ,L2buf,L2p  );
            storechar(opdhi,L2buf,L2p+1);
            storechar(opdlo,L2buf,L2p+2);
            L2p:=L2p+3;;
            goto NEXTOPN;
            end;

       when
       ICOMN,         ! start declaration line (Scode DECL) ;
       IROPD do begin ! start statementt  line (Scode STMT) ; !3 bytes;
            lastlinenr:=linenr; storecharint(opn,lastlinenr);
            goto NEXTOPN;
            end;

       when
       INOTY, IINTG, IREAL, ILONG, ISHOR, IBOOL, ICHAR, ITEXT do begin
            ! Part of param.spec. or local declaration;
            ctype:=opn; ckind:=K_ident;
            cqual:=0;
            goto NEXTOPN; end;

       when IARRA do begin
            ckind:=K_array;
            goto NEXTOPN; end;
       when IPROC do  begin
            ckind:=K_proc;
            goto NEXTOPN; end;

       when ICLAS do ! Param.spec or ext. decl. ; begin
            ckind:=K_class;
            goto NEXTOPN; end;

       when IRCRD do ! Param.spec or ext. decl. ; begin
            ckind:=K_record;
            goto NEXTOPN; end;

%      Constants are output as 1 type-byte, followed by 0,1 or 2 bytes:
%           - ref:               REF        0 bytes (NONE is only)
%           - character/boolean: CHAR/BOOL  1 byte holds value
%           - arithmetic types:  <type>     2 bytes holding index
%           - text:              TEXT       2 bytes holding index
%      If the constant is single, the byte SCST follows

       when 
       ISCST, ICONS do begin  !max 3 bytes out;
            !The type is output first;
            storechar(optx ,L2buf,L2p); ! L2p:=L2p+1;
            switch(NUL:ITEXT) optx begin
            when IBOOL,ICHAR do begin
                 storechar(opdlo,L2buf,L2p+1); L2p:=L2p+2;
                 goto NEXTOPN end;
            when ISHOR,IINTG,IREAL,ILONG,ITEXT do begin
                 storechar(opdhi,L2buf,L2p+1); ! L2p:=L2p+1;
        SINGLE:  storechar(opdlo,L2buf,L2p+2); L2p:=L2p+3;
                 goto NEXTOPN end;
            when NONE do
                 L2p:=L2p+1;
            end case;
            goto NEXTOPN end;

       when
       ISWIT, ILABE do begin !Part of param.spec. ;
            ctype:=ILABE;
            ckind:=if opn=ILABE then K_label else K_switch;
            cqual:=0;
            goto NEXTOPN; end;

       when
       ICPRF do begin ! Prefix in class declaration;
            goto SetQual; end;

       when IREF do begin
            ctype:=IREF; ckind:=K_ident; 
     SetQual:
            cqual:=rank(opdhi)*256+rank(opdlo);
            goto NEXTOPN; end;

       when ILANG do begin ! lamguage of external proc (opd=0: simula);
            lanhi:=opdhi; lanlo:=opdlo;
            goto NEXTOPN; end;

       when
       IDCLC,IREAC do begin ! class/record declaration;  !3 bytes out;
            ckind:=if opn=IDCLC then K_class else K_record;
            ctype:=INOTY; NewQuant(C_local);
            ! *** inspected:=plev:=0;
            p_or_c_qt:-cquant;
%           ! It is important that p_or_c_qt is left as old cquant ;
            brecinit(ckind);
            p_or_c_qt.descr:-cbrec;
            if ckind=K_record then cbrec.declquant:-p_or_c_qt;
            p_or_c_qt.ftag:=-cqual;
            goto BLOCKOUT end;

       when
       IBEGI do begin !3 bytes out;
            brecinit(K_prefbl); cbrec.stmtag:=cbrec.inrtag:='!2!';
            goto BLOCKOUT end;

       when
       IBLKB do begin !3 bytes out;
            brecinit(K_subbl);
 BLOCKOUT:  store3chars(opn,cbrec.blnohi,cbrec.blnolo);
            goto NEXTOPN; end;

       when
       IECWI, IEND do begin !4 + 4*(number of unmatched virts);
            if cbrec.kind = K_class then begin
%-Z %IMPLNONE OFF
              inspect cbrec do begin
                  virq:-favirt;
                  while true do inspect virq do begin
                     ! insert dummy matches for non-matched virtprocs,
                     ! note that virt quant is unaffected by this;
                     if kind<>K_proc then goto NXTVIRT;
                     pq:-fpar.next;
                     while pq =/= none do begin
                        if pq.symb == symb
                        then goto NXTVIRT; !matched;
                        pq:-pq.next end;
                     ctype:=type; ckind:=K_proc;
                     NewQuant(C_local);
                     cquant.line:=line; cquant.ftag:=ftag;
                     cquant.symb:-symb;
                     cquant.dim:=78; !marks this as a dummy match;
                     xquant:-cquant;
                     brecinit(K_proc); xquant.descr:-cbrec;
                     if descr =/= none
                     then cbrec.fpar.next:-descr.fpar;
                     !*** parameter specs of dummy must fit virt spec;
                     xbrec:-cbrec; cbrec.line1:=line; brecterm;
                     brecinit(K_proc); cbrec.line1:=line;
                     inspect new idpack do begin
                        ! linking body brec to head brec;
                        cbrec.hidlist:-this idpack;
                        idhi:=xbrec.blnohi; idlo:=xbrec.blnolo;
                     end;
                     store3chars(IBREC,cbrec.blnohi,cbrec.blnolo);
                     brecterm;
                     storechar(IEREC,L2buf,L2p); L2p:=L2p+1;
                     if L2p > L2limit then outbuffer;
         NXTVIRT:    virq:-next;
                  end otherwise goto EXvloop;  EXvloop:

                  fvis:-hidlist; hidlist:-x:-none;
                  while fvis=/=none do begin
%-Z %IMPLNONE OFF
                     if fvis is protpack then begin
                     !*** mark corresponding quant and delete pack ***;
                        iihi:=fvis.idhi; iilo:=fvis.idlo;
                        locals:=false; notok:=true;
                        pq:-favirt;
                  L1:   while pq=/=none do begin
                           if pq.symb==boxof(iihi,iilo) and then
                              (pq.protect='!0!' or else pq.type=ILABE)
                           then begin pq.protect:='!1!';
                              if locals then goto FOUND;
                              ! if virtual then mark local match;
                              notok:=false end;
                           pq:-pq.next;
                        end;
                        if not locals then begin
                           locals:=true; pq:-fpar.next; goto L1 end;

%                       for pq:-favirt, fpar.next do begin
%                           locals:=not locals;
%                           while pq=/=none do begin
%                              if pq.symb==boxof(iihi,iilo) and then
%                                 (not pq.protect or else pq.type=ILABE)
%                              then begin pq.protect:=true;
%                                 if locals then goto FOUND;
%                                 ! if virtual then mark local match;
%                                 notok:=false end;
%                              pq:-pq.next;
%                           end
%                       end;
                        if notok then begin
                           error1id(-290,boxof(iihi,iilo));
                           !remove next pack too if hidden protected;
                           inspect fvis.next do
                             if idlo=iilo and then idhi=iihi and then
                                this idpack is idpack
                           then fvis:-fvis.next;
                        end;
              FOUND: end
                     else begin
                        if x==none then x:-hidlist:-fvis
                        else x:-x.next:-fvis;
                     end;
                     fvis:-fvis.next
                  end idpacklist scan;
                  if x=/=none then x.next:-none;
              end inspect cbrec;
            end termClass;

            if opdlo <> NUL then begin
               cbrec.stmtag:='!2!';
% D            opdlo:=NUL;
            end;
            lastlinenr:=linenr; storecharint(IROPD,lastlinenr);
            goto btout end;

       when
       IFORE, ICONE, IOTHW, IAFTR  do begin !1 byte out;
  btout:    brecterm; goto OPNOUT end;

       when
       IINNE do begin !1 byte out;
            if opdlo <> NUL then begin
               cbrec.stmtag:='!2!';
% D            opdlo:=NUL;
            end;
            cbrec.inrtag:='!2!'; goto OPNOUT end;

       when
       IWHIL do begin  !declare FOR variable - max 3 bytes out;
             ctype:=optx; ckind:=K_ident; cqual:=0;
             xbrec:-cbrec; xquant:-cquant;
             while cbrec.kind=K_labbl do cbrec:-cbrec.fpar.encl;
             cquant:-cbrec.fpar;
             while cquant.next=/=none do begin
                cquant:-cquant.next;
                if cquant.symb==boxof(opdhi,opdlo) then goto Qfound ;
             end;
             newQuant(C_local);
             if ctype=ILABE then begin
                cquant.kind:=K_label; cquant.dim:=1 end;
   Qfound:   cbrec:-xbrec; cquant:-xquant;
             if ctype=ILABE then goto OPDOUT;
             goto NEXTOPN; end;

       when
       IDCLS do begin !3 bytes out;
            cbrec.dcltag:='!2!'; !give correct value;
            dimcount:=0;
            ckind:=K_switch; goto genlab end;

       when
       ICL do begin    !3 bytes out;
            ckind:=K_label;
   genlab:  ctype:=ILABE;
            cqual:=0;
            NewQuant(C_local);
            cquant.protect:='!1!'; !*** labels are protected;
            if opn=IWHIL then cquant.dim:=1; !marked variable;
            goto OPDOUT end;

       when
       IDCLI do begin
            ckind:=K_ident; NewQuant(C_local);
            goto NEXTOPN; end;

%+K     when
%+K     IBLNO do begin !Set global inst - 1 byte out;
%+K         cbrec.dcltag:='!2!'; !give correct value;
%+K         cbrec.isGlobal:=true; !mark global;
%+K         goto OPNOUT; end;
 
       when
       ISWEE, IDIME do begin !1 bytes out;
            dimcount:=dimcount+1; goto OPNOUT end;

       when
       ISWDE do begin !1 byte out;
            cquant.dim:=dimcount;
            goto OPNOUT end;

       when
       ISIMU do begin !infix array - 0 byte out;
            cquant.kind:=K_rep; cquant.dim:=1; cquant.encl:-cbrec;
            xquant:-cquant; brecinit(K_rep);
            xquant.descr:-cbrec; cbrec.declquant:-xquant;
            cbrec.line1:=repcount;
            brecterm; goto NEXTOPN end;

       when
       IACTE do begin !error in infix array - convert to array(0:...);
            cquant.kind:=K_array; !DCLI => DCLA;
            dimcount:=0; if firstarr==none then firstarr:-cquant;
            cbrec.dcltag:='!2!'; !give correct value;
            inspect cquant.symb do store3chars(IDCLA,idhi,idlo);
            store3chars(IINTG,zerohi,zerolo);
            opn:=IBNDE; goto OPNOUT end;

       when
       IDCLA do begin !3 byte out;
            ckind:=K_array; NewQuant(C_local);
            dimcount:=0; if firstarr==none then firstarr:-cquant;
            cbrec.dcltag:='!2!'; !give correct value;
            goto OPDOUT end;

       when
       IARDE do begin !end of array decl - 1 byte out;
            dimcount:=dimcount+1;
            while true do inspect firstarr do begin
                  dim:=dimcount; firstarr:-next end
            otherwise goto OPNOUT; end;

       when
       INONE do begin !prior procedure;  !3 bytes out;
%+K         cbrec.dcltag:='!2!'; !give correct value;
%+K         goto LIDCLP;
%-K         goto NEXTOPN;
            end;

       when
       INOTE do begin !external procedure binding;  !3 bytes out;
            ! do not generate new quant, but modify the current one ;
            if cquant.virtno=0
            then cquant.virtno:=rank(cquant.symb.idhi)*256
                              + rank(cquant.symb.idlo);
            cquant.symb:-boxof(opdhi,opdlo); cquant.type:=ctype;
            cquant.ftag:=-cqual;
            goto genbrc end;

       when
       IDCLP do begin !normal or prior procedure decl. ;  !3 bytes out;
    lidclp: ckind:=K_proc; NewQuant(C_local);
   genbrc:  
            p_or_c_qt:-cquant;
%           ! It is important that p_or_c_qt is left as old cquant ;
            brecinit(K_proc); p_or_c_qt.descr:-cbrec;
%+K         if opn=INONE then begin opn:=IDCLP;cbrec.thisused:=true end;
            store3chars(opn,nextblhi,nextbllo);
            !*** The blno of the body-brec is output here;
            goto NEXTOPN;
            end;

       when
       IBREC do begin !virtual procedure binding;
            ! check and modify current virtual quant ;
%-Z %IMPLNONE OFF
            inspect vquant do begin
               if type<>INOTY then error1id(-444,symb);
               ! specified virtual proc must be PROC ident IS ...;
               symb:-boxof(opdhi,opdlo); type:=ctype;
               ftag:=-cqual;
               brecinit(K_proc); descr:-cbrec;
            end;
            goto NEXTOPN; end;

       when
       IEREC do begin !termination of virtual procedure binding;
            brecterm;
            goto NEXTOPN; end;

       when
       IFRMP do begin
            ctype:=IELSE; ckind:=K_unknwn;
            cqual:=0;
            NewQuant(C_unspec);
            goto NEXTOPN; end;

       when
       IVALU, INAME do begin
            xquant:-cbrec.fpar;
            while xquant.symb =/= boxof(opdhi,opdlo)
                  and then xquant.next=/=none
               do xquant:-xquant.next;
            if xquant.symb.idhi<>opdhi or else xquant.symb.idlo<>opdlo
            then SpecErr(223) 
       else if xquant.categ <> C_unspec then SpecErr(224)
            else xquant.categ:=if opn=IVALU then C_value else C_name;
            goto NEXTOPN; end;

       when
       IPSPC, ICSPC do begin !procedure/class parameter spec. end;
            xquant:-cbrec.fpar;
            while xquant.symb =/= boxof(opdhi,opdlo)
                  and then xquant.next=/=none
               do xquant:-xquant.next;
%-Z %IMPLNONE OFF
            inspect xquant do begin
               if symb.idhi<>opdhi or else symb.idlo<>opdlo
               then SpecErr(223)
          else if kind <> K_unknwn then SpecErr(224)
               else begin
                  type:=ctype; kind:=ckind;
                  ftag:=-cqual;
               end;
            end;
            goto NEXTOPN; end;

       when
       IEPRM do begin
            if cbrec.kind=K_proc then begin
               !*** Terminate par-brecord and start body-brecord
                    if not in procedure binding after IS;
                  xbrec:-cbrec; brecterm;
                  if cquant.categ <> C_extnal then
                  begin brecinit(K_proc);
                        inspect new idpack do begin
                           ! linking body brec to head brec;
                           cbrec.hidlist:-this idpack;
                           idhi:=xbrec.blnohi; idlo:=xbrec.blnolo;
                        end;
                        cbrec.line1:=xbrec.line1;
                  end
             else if cquant.dim = rank(Cindex)  or else
                     cquant.dim = rank(Pascalindex)
                  then begin ! parameter check for C-like routines ;
                     pq:-xbrec.fpar;
                     while pq=/=none do begin
                        if pq.kind=K_proc then begin
                           if pq.categ<>C_name then goto Nspec end
                   else if pq.categ=C_unspec then begin
                           if pq.kind=K_array then goto Nspec;
                           switch(NUL:IELSE) pq.type begin
                           when IBOOL,ICHAR,ISHOR,IINTG,IREAL,ILONG,
                                IPTR do begin
                                pq.categ:=C_value; iii:=244;
                                end;
                           when NONE do begin
                      Nspec:    pq.categ:=C_name; iii:=248;
                                end;
                           end case;
                           diag(0):-pq.symb.symbol;
                           diag(1):-cquant.symb.symbol;
                           P1warn(iii);
                        end unspec;
                        pq:-pq.next;
                     end;
                  end;
            end;
            goto NEXTOPN; end;

       when
       IVSPC do begin
            NewQuant(C_virt);
            goto NEXTOPN; end;

       when
       IWHEN do begin !5 bytes out;
            brecterm; goto LIFWHN end;

       when
       ICONB, IFWHN do begin  !CONB:3, else 5 bytes out;
   LIFWHN:  brecinit(K_labbl);
            ! cbrec represents a block holding labels
              local to a connection block ;
            ! update 'connests' attributes ;
            jjj:=1;
            xbrec:-cbrec.fpar.encl;
            while xbrec.kind=K_labbl do  !Count inspect nesting ;
            begin if xbrec.connests <> 0 then jjj:=jjj+1;
                  ! xbrec is the labbl block of an inspect;
                  xbrec:-xbrec.fpar.encl;
            end;
%           if jjj > 255 then ......
            if xbrec.kind=K_proc then
               xbrec:-getBrc(xbrec.hidlist.idhi,xbrec.hidlist.idlo);
            !connests is updated in the procedure head, not the body,
             because of the way quick procedures are implemented ;
            cbrec.connests:=jjj;
            if xbrec.connests<jjj then xbrec.connests:=jjj;
            if opn=ICONB then goto BLOCKOUT;
QBLOCKOUT:  store3chars(opn,cbrec.blnohi,cbrec.blnolo);
            storechar(opdhi,L2buf,L2p  );
            storechar(opdlo,L2buf,L2p+1); L2p:=L2p+2;
            goto NEXTOPN; end;

       when
       IFOR do begin  ! 5 bytes out;
            brecinit(K_labbl); goto QBLOCKOUT; end;

       when
       IBPRF do begin !5 bytes out;
            brecinit(K_prefbl); cbrec.stmtag:=cbrec.inrtag:='!2!';
            goto QBLOCKOUT end;

       when
       IEOP  do begin !2 byte out;
%+D         inspect sysout do begin if pos>1 then outimage end;
            while cbrec=/=none do brecterm;
            storechar(IEOP,L2buf,L2p); storechar(IEOP,L2buf,L2p+1);
            L2codebuffer.setpos(L2p+2); !*** optimize outtext;
            while true do detach; !*** until killed by control ***;
            end;

       when
       IEXTR do begin
            NewQuant(C_extnal);
            if ckind=K_proc then begin
               cquant.dim:=rank(lanhi)*256 + rank(lanlo);
               lanhi:=lanlo:=NUL;
            end;
            end;

       when
       IEXNM do begin
%+Z         if cquant.categ=C_unknwn
%+Z         then p_or_c_qt.virtno:=rank(opdhi)*256 + rank(opdlo) else
            cquant.virtno:=rank(opdhi)*256 + rank(opdlo);
%           ! The first alt. only used when =="..." can follow any
%             declaring identifier, and a proc or class is declared;
%           ! cquant.categ=C_unknwn means that cquant is the first,
%             dummy quant of cbrec.  The occurence of 'IEXNM opd'
%             then means that this is a string connected to a
%             declaration for which a new brecord has just been pushed
%             on the stack, i.e. a normal procedure or class
%             declaration.
%             For an external declaration a new brecord is not pushed on
%             stack, which means that in this case cquant is the one
%             of interest.  This is true in all other cases too, i.e.
%             when a string is connected to a non-procedure/non-class
%             quantity ;
            end;

       when
       ICASE do begin !case-stat., opdlo=output character; !1 byte out;
            if opdlo<>NUL then opn:=opdlo; goto OPNOUT end;

       when
       ITO do begin ! '=' in const. element, mark quant const; !3 bytes;
            cquant.special:='!3!'; ! constant mark ;
            if cquant.type=ISHOR then cquant.type:=IINTG;
            opdhi:=cquant.symb.idhi; opdlo:=cquant.symb.idlo;
            goto OPDOUT end;

       when
       IFASG do begin ! ':=' in const. element, mark quant read only; !2 bytes;
            cquant.protect:='!2!'; cbrec.dcltag:='!2!';
            storechar(IFASG,L2buf,L2p); L2p:=L2p+1;
            opn:=opdlo; goto OPNOUT end;

       when
       IPRHI, IPRTC do begin
            chainVis(false); ! register 'protected';
            if opn = IPRHI then goto LIHIDD;
            end;

       when
       IHIDD do
       LIHIDD: begin
            chainVis(true);  ! register 'hidden';
            end;

       when
       ISSWA do begin !6 bytes out;
            !*** Now both scanner and parser are bypassed;
            storecharint(ISSWA,cswa);
            storechar(char(cswb//256),    L2buf,L2p  );
            storechar(char(rem(cswb,256)),L2buf,L2p+1); L2p:=L2p+2;
%+D         if option(rank('5'))<>NUL then inspect sysout do begin
%+D               outtext("SWITCHES: "); outint(cswa,3);
%+D               outint(cswb,3); outimage; end;
            end;

       when
       IGOTO do begin !max 4 bytes out;
              storechar(IGOTO,L2buf,L2p); L2p:=L2p+1;
%-Z %setopt +D
              detach; !*******   N O T E   *******;
%-Z %setopt -D
              if opn=ISIDN then begin
                 symx:-boxof(opdhi,opdlo);
                 pq:-cbrec.favirt;
                 while pq=/=none do begin
                    if pq.symb==symx then goto OPDOUT;
                    pq:-pq.next end;
                 pq:-cbrec.fpar.next;
                 while pq=/=none do begin
                    if pq.symb==symx and then pq.kind=K_label then begin
                       if pq.plev<200 then pq.plev:=pq.plev+1;
                       !save some indices here;
                       goto OPDOUT end;
                    pq:-pq.next;
                 end;
              end;
    NonLoc:
              goto CheckNxt;
            end;

       when none do ;

%   IBLNO: begin
%   %-D ISSWB:
%   ILINE: IUPLS: IVIRT: IGO:
%   IACTV: IREAC: IBEFO: IAFTR: IAT: IDELA: IPRIO:

       end *** case opn ***;

    end *** while true do ***;

 end L2Coder;


      procedure ClosePass1;
      begin while cursource=/=none do cursource.close;
            scanner:-parser:-none; lexScanner:-none;
            inspect L2OUPT do begin
            !*** NOTE: L2OUPT==none if nothing output, i.e. incore;
                outtext(L2codebuffer.sub(1,L2codebuffer.pos)); close;
            end;
            P1coder:-coder:-none;
      end;

end of SCANNER;
