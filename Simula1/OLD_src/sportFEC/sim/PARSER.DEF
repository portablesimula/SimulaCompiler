external class SCANINP;
% external class SCANINP="C:\GitHub\SimulaCompiler\Simula/src/sportFEC/bin/SCANINP.jar ";
SCANINP class PARSER;

hidden protected codebuffer;

%      -----------------------------------------------------------------
%      ---  COPYRIGHT 1988 by                                        ---
%      ---  Simula a.s.                                              ---
%      ---  Oslo, Norway                                             ---
%      ---                                                           ---
%      ---                 P O R T A B L E     S I M U L A           ---
%      ---              F R O N T - E N D    C O M P I L E R         ---
%      ---             T h e    S y n t a x    C h e c k e r         ---
%      ---                                                           ---
%      --- Selection switches: DKPIRZ                                ---
%      ---                                                           ---
%      ---    'D' Included when dump is wanted                       ---
%      ---    'I' Included to make compiler use inserted mnemonics   ---
%      ---    'K' Included always when quick capability wanted       ---
%      ---    'P' Included to make compiler use quick procedures     ---
%      ---    'R' Included for full REAL capability                  ---
%      ---    'Z' Included at system generation (for "ZIMULA")       ---
%      ---                                                           ---
%      -----------------------------------------------------------------

%SELECT Z

begin

%SPORT ON
%REUSE ON
%-Z %RECORD ON

%+I %INSERT $SIMSRC/fec/common.mne
%+I %INSERT $SIMSRC/fec/parser.mne

%title ******   L 2 - b u f f e r i n g   ******

% - initial output is buffered here in order to insert a block to
%   hold a possible external head of the main program

      outcodefile class codebuffer;
      begin ref(outcodefile) prev;  !stacked coder;
            ref(elt) curelt, firstelt;
            !*** the following for use by for-statement ***;
            ref(elt) cvar,       !controlled variable;
                     stepexpr,   ! - may be more than one elt;
                     forvar,     !temp var;
                     wheeler,    !list comma, or first elt;
                     deltavar,   !DELTA variable of definition;
                     statlabel;  !statement label and exit label def;

            class elt;
            begin character opdhii,opdloo,optxx,opnn;
                  ref(elt)next;
%+D               procedure dump(t); text t; begin integer i;
%+D               inspect sysout do begin i:=pos;
%+D                  outtext(t); setpos(i+8);
%+D                  outtext(DB(rank(opnn))); setpos(i+20);outchar('(');
%+D                  outint(rank(opdhii),0); outchar(',');
%+D                  outint(rank(opdloo),0);
%+D                  outtext(")=" & nameof(opdhii,opdloo) ); outimage;
%+D               end end;
                  procedure emit;
                  begin opdhi:=opdhii; opdlo:=opdloo;
                        optx :=optxx;  opn  :=opnn;   call(coder);
                  end;
            end;

            procedure copyexpr(oldelt); ref(elt) oldelt;
            while oldelt=/=none do begin
               oldelt.emit; oldelt:-oldelt.next;
            end;

            procedure termModul;
            begin character optxp,opdhip,opdlop;
                  opdhip:=opdhi;opdlop:=opdlo; optxp:=optx;
                  if separatecomp then ! no special action;
                  else begin !insert ext.head block;
                       opn:=IDCLE; call(prev);
                       opn:=IBLKB; call(prev);
                       parser qua grammer.blockfound:=1;
                  end;
                  terminate;
                  opdhi:=opdhip; opdlo:=opdlop; optx:=optxp;
            end;

            procedure terminate;
            begin coder:-prev; prev:-none;
                  curelt:-firstelt.next; firstelt.next:-none;
                  while curelt=/=none do 
%-Z %IMPLNONE OFF
                   inspect curelt do begin
                     opdhi:=opdhii; opdlo:=opdloo;
                     optx :=optxx;  opn  :=opnn;   call(coder);
                     curelt:-next;
                  end;
                  curelt:-firstelt; !for re-use;
            end;

            prev:-coder; coder:-this outcodefile;
            firstelt:-curelt:-new elt; !dummy head of list;
            detach;

            while true do begin
               inspect new elt do begin opnn:=opn;
                  opdhii:=opdhi; opdloo:=opdlo; optxx :=optx;
                  next:-curelt.next; curelt:-curelt.next:-this elt;
               end;
%-Z %setopt +D
               detach;
%-Z %setopt -D
            end;

      end;

%title ***  G r a m m e r  ***

%  GRAMMER is the coroutine monitor for the parsing system. It contains
%          the syntax analysis and L2-generation either inline in its
%          action part, or as classes (subclasses of class statement).
%          A global reference to the grammer object is kept in 'parser'
%          but no attributes of grammer need be visible from outside
%          Since only one grammer is generated, all non-recursive procs
%          are 'prior'.

      component class grammer;  !*** all prior proc., only one grammer;
      hidden protected first,last,exList,foList,whList,itList,ifList,
                       deList,newstat,stmtwnt,readtype,reac,
                       specofvirtual,labelused,experrorno,
                       fornests,uniqueindex,
                       lastDECLnr,lastSTMTnr,ex,
                       setCurPos,currentPos,ParsErr,ParsWarn,
                       syntaxerror,search,readtypespec,readprocpar,
                       readclasspar,readspecification,extbinding,
                       notBoundPair,setbasicrecovery,skip,
                       statement,module,declaration,blockOrComp,
                       whilstat,ifstat,forstat,inspectstat,casestat,
                       expression;
      begin ref(statement) first, last; ! stack chain;
	    ref(statement) exList, foList, whList, itList, ifList,
			   deList;
	    ref(statement) newstat;
	    character stmtwnt;
	    character readtype;       ! result of readtypespec;
            boolean specofvirtual;    ! true in spec of virt proc;
            boolean labelused;        ! used to remember if label
				        from grammer to statement;
            character reac;           ! - see REAC/ACTV;
            short integer fornests;
            short integer experrorno;
            short integer uniqueindex;
            short integer lastDECLnr, ! last DECL number sent to pass 2;
		          lastSTMTnr; ! last STMT number sent to pass 2;
%           short integer curdepth;   ! to set 'maxdepth' for pass 2;
            short integer blockfound; ! indicates the nesting of blocks;
            ref(expression)ex;

%+Z         boolean array   recoversymbol(0:150); ! zero never used;
%+Z         character array symboltype(0:150);    ! CONST local use;
%-Z         boolean         recoversymbol(  150); ! zero never used;
%-Z         character       symboltype(  150);    ! CONST local use;

%           ********   Named Constants   ********
            character

         ! *** values of symboltype (+ 0: none of these) ;
               declsymbol  = '!1!',
               exprtermin  = '!2!',
               arithop     = '!3!',
               relop       = '!4!',
               logop       = '!5!',

         ! *** values of statement'stmtreq (requirem. to inner unit) ;
               allstmt     = '!0!', !NUL, ! all statements;
               allbutif    = '!1!', ! all but if-stmt;
               outermost   = '!2!', ! only block, compound stmt, or
                                    ! ext. decl. of proc or class;
               classbody   = '!3!',
               stmtorinner = '!4!', ! statements or inner;
               procbody    = '!5!', ! procedure body;

         ! *** values of statement'stmttype (type of actual inner unit);
               basicstmt   = '!0!', !NUL, ! basic stmt,block or compound;
               openstmt    = '!1!', ! all "open" stmt;
               innerstmt   = '!2!', ! inner, also used to signal
                                    ! split body to class declaration;
               declunit    = '!3!', ! declaration (*);
               dummystmt   = '!4!', ! dummy statement (class decl) (*);
                                    ! *) these 2 must be last;

         ! *** values of blockOrComp'blocktype;
               compstmt    = '!0!', !NUL, ! compound stmt;
               usualblock  = '!1!', ! block;
               prefixblock = '!2!',

         ! *** values for statement'blockstatus;
               stmtnotseen = '!1!', ! no statement seen, or error;
               lastwasstmt = '!2!',
               lastwasdecl = '!3!';

% -V  switch OPTSW := !*** after recognized operator keyword ***;
% -V       ErrorSt!BOOL;, ErrorSt!CHAR;, ErrorSt!SHOR;, ErrorSt!INTG;,
% -V       ErrorSt!REAL;, ErrorSt!LONG;, ErrorSt!REF ;, ErrorSt!TEXT;,
% -V       ErrorSt!VALU;, ErrorSt!LABE;, ErrorSt!PROC;, ErrorSt!ARRA;,
% -V       ErrorSt!ELSE;, SawEND,        ErrorSt!EQV ;, ErrorSt!EXTR;,
% -V       SawFOR,        ErrorSt!GO  ;, SawGOTO,       ErrorSt!HIDD;,
% -V       SawIF,         ErrorSt!IMP ;, ErrorSt!IN  ;, SawINNE,
% -V       SawINSP,       ErrorSt!DO  ;, ErrorSt!IS  ;, ErrorSt!CLAS;,
% -V       SawBEGI,       ErrorSt!NAME;, SawNEW,        ErrorSt!NOT ;,
% -V       ErrorSt!OR  ;, ErrorSt!OTHW;, ErrorSt!PRIO;, ErrorSt!DELA;,
% -V       ErrorSt!PRTC;, ErrorSt!QUA ;, SawREAC,       ErrorSt!AT  ;,
% -V       ErrorSt!BEFO;, ErrorSt!AND ;, ErrorSt!STEP;, ErrorSt!SWIT;,
% -V       SawACTV,       ErrorSt!THEN;, SawTHIS,       ErrorSt!TO  ;,
% -V       ErrorSt!UNTI;, ErrorSt!AFTR;, ErrorSt!VIRT;, ErrorSt!WHEN;,
% -V       SawWHIL,       ErrorSt!LT  ;, ErrorSt!EQ  ;, ErrorSt!LE  ;,
% -V       ErrorSt!GT  ;, ErrorSt!NE  ;, ErrorSt!GE  ;, ErrorSt!COMN;,
% -V       ErrorSt!NONE;, ErrorSt!NOTE;, ErrorSt!TRUE;, ErrorSt!FALS;,
% -V       ErrorSt!RFEQ;, ErrorSt!RFNE;, ErrorSt!PLUS;, ErrorSt!MINU;,
% -V       ErrorSt!MULT;, ErrorSt!SLAS;, ErrorSt!POWE;, ErrorSt!IDIV;,
% -V       ErrorSt!DOT ;, ErrorSt!CL  ;, ErrorSt!COMA;, SawSMCL,
% -V       SawLFPA,       ErrorSt!RGPA;, ErrorSt!ASSG;, ErrorSt!DENO;,
% -V       ErrorSt!CONC;, ErrorSt!CAND;, ErrorSt!COR ;, SawCASE,
% -V       ErrorSt!EOP ;, SawROPD,       SawIDN,        SawCONS;

%title *****    S Y N T A X   E R R O R    *****

           short integer currentPos;

           procedure setCurPos;
           begin setP1line;
%-Z %IMPLNONE OFF
              inspect lexScanner
	      do currentPos:=(if optx<>NUL and then getopt and then
                              opdline=linenr then opdpos else optpos)+1;
           end;
              

%+PQ       prior
           procedure syntaxerror(errorno); short integer errorno;
	   begin short integer c;  ref(statement) stmnt;
                 if cs<>IEOP then begin setCurPos;
	            parserMessage(currentPos, errorno, experrorno ) end;
	         experrorno:=0;
		 for c:=1 step 1 until 150 do recoversymbol(c):=false;
		 setbasicrecovery;
		 stmnt:-first;
		 while stmnt=/=none do begin
		       stmnt.recoversetting; stmnt:-stmnt.next end;
		 search;
		 while not last.recover do begin
%+D                    if option(rank('2'))<>NUL
%+D                    then W1("UNSTACK - cs:",rank(cs));
		       last:-last.caller; !curdepth:=curdepth-1; end;
		 last.next:-none;
%                ! last is now the statement which
%                  recovered successfully and may continue parsing;
%               ! goto proceed;    NEVER DO THAT - left as a warning !!!
           end;

% %+P        prior
%            procedure writeerror(n); short integer n;
%            begin  ! should put mark in output !!!;
%                  setCurPos; parserMessage(currentPos, n , 0 );
%            end;

%+PQ       prior
           procedure ParsErr(n); short integer n;
           if n<>212 or else numerrfound=0 then
           begin
                 setCurPos; outP1message(currentPos, n , '!2!' );
           end;

%+PQ       prior
           procedure skip(err); short integer err;
           !??? IMPORTANT: scanner MUST be advanced on semic ***;
           begin
                 if err<>0 then ParsErr(err);
           REP:  search;
                 if cs=ISMCL then NEXTSYMBOL; !???;
           end;

%+PQ       prior
           procedure ParsWarn(n); short integer n;
           begin
                 setCurPos; outP1message(currentPos, n , '!1!' );
           end;

%+PQ       prior
           procedure search;
%           ! performs a search for the first symbol
%             which is a recoversymbol, cs will denote the found symbol;
	         while not recoversymbol(rank(cs)) do NEXTSYMBOL;

%title *****   NEXTSYMBOL - readtypespec - lookforstring   *****

%     NOTE: Whenever an operator has been recognized, getopt is false
%           - thus NEXTSYMBOL is replaced by moresymbols

%+PQ       prior
           procedure NEXTSYMBOL;
           begin if getopt then begin cs:=opt; getopt:=false;
%+D                 if option(rank('2'))<>NUL
%+D                 then W1("next:"&DB(rank(cs)),rank(cs));
                 end
                 else detach; !get symbols;
%+S              Freq(13):=Freq(13)+1;
           end NEXTSYMBOL;

%+Z        procedure lookforstring;
%+Z        ! called after decl.-identifiers when I-option;
%+Z        if cs=IRFEQ then begin
%+Z           detach; !get symbols;
%+Z           if cs=ICONS and then optx=ITEXT then begin
%+Z              opn:=IEXNM; call(coder);
%+Z              getopt:=false; cs:=opt;
%+Z           end;
%+Z        end of lookforstring;

%+PQ        prior
	    procedure readtypespec;
            if cs<=ITEXT then begin
%+S           Freq(14):=Freq(14)+1;
	       readtype:=cs;
	       if cs=IREF then begin  !check identifier followed by ) ;
		  detach; !get symbols;
		  if cs<>ILFPA then ParsWarn(282)
                  else detach; !get symbols;
		  if cs<>IIDN then begin character opdhip,opdlop;
		     ParsErr(185); opdhip:=opdhi; opdlop:=opdlo;
		     opn:=IREF; opdhi:=NUL; opdlo:=errorident;
                     call(coder);
                     opdhi:=opdhip; opdlo:=opdlop;
		  end else begin opn:=IREF; call(coder);
                      getopt:=false; cs:=opt;
                  end;
		  if cs<>IRGPA then ParsWarn(285);
	       end
	       else begin opn:=cs; call(coder) end;
	       detach; !get symbols;
	    end else begin
%+S           Freq(15):=Freq(15)+1;
               readtype:=NUL;
            end readtypespec;

%title ***  readprocpar ***

      procedure readprocpar(speckind); character speckind;
%           !  speckind = IPSPC: procedurespec,
%                       = ICSPC: classspec,
      begin character opx;
	    boolean namefound,valuefound;

	    procedure procparerror(errno);short integer errno;
	    begin ParsErr(errno);
     searchagain: search;
		  if cs=IEND then begin
		     detach; !get symbols; goto searchagain end;
		  if cs=ICOMA then goto P1;
		  if cs=ISMCL then begin
		     detach; !get symbols; goto namevaluepart end;
		  if cs=INAME or else cs=IVALU then goto namevaluepart;
		  if symboltype(rank(cs))=declsymbol
		  then goto specification;
		  goto readprocparexit;
	    end procparerror;

	    procedure setrecsymb(b); boolean b;
	    begin !character c;
	    ! when searching for recoversymbols, the declaration symbols
	      plus name and value must be searched for;
                  recoversymbol(rank(IBOOL)):=b;
                  recoversymbol(rank(ICHAR)):=b;
                  recoversymbol(rank(ISHOR)):=b;
                  recoversymbol(rank(IINTG)):=b;
                  recoversymbol(rank(IREAL)):=b;
                  recoversymbol(rank(ILONG)):=b;
                  recoversymbol(rank(IREF )):=b;
                  recoversymbol(rank(ITEXT)):=b;
                  recoversymbol(rank(IVALU)):=b;
                  recoversymbol(rank(IPROC)):=b;
                  recoversymbol(rank(IARRA)):=b;
                  recoversymbol(rank(IEXTR)):=b;
                  recoversymbol(rank(INAME)):=b;
                  recoversymbol(rank(ISWIT)):=b;
                  recoversymbol(rank(ICOMA)):=b;
%                 for c:=IARRA,IBOOL,ICHAR,IEXTR,IINTG,ILONG,IREAL,IREF,
%                        ISHOR,ISWIT,ITEXT,IPROC,INAME,IVALU,ICOMA
%                  do recoversymbol(rank(c)):=b;
	    end;

%+S         Freq(16):=Freq(16)+1;
	    setrecsymb(true);
	    if cs=ILFPA then begin
   P1:            detach; !get symbols;
		  if cs <> IIDN then procparerror(185);
		  opn:=IFRMP; call(coder);
                  getopt:=false; cs:=opt;
%+Z               if option(rank('I'))<>NUL then lookforstring;
		  if cs=ICOMA then goto P1;
		  if cs <> IRGPA then procparerror(186);
		  detach; !get symbols;
   checksemic:    if cs <> ISMCL then ParsWarn(300) else
		  detach; !get symbols;
   namevaluepart: if cs=IVALU then begin
                     if valuefound then ParsErr(196);
                     valuefound:= true;
   P3:               opx:=cs;
   P2:               detach; !get symbols;
	             if cs<>IIDN then procparerror(185);
		     opn:=opx; call(coder);
		     getopt:=false; cs:=opt;
                     if cs=ICOMA then goto P2; goto checksemic;
		  end;
                  if cs=INAME then begin
		     if speckind = ICSPC then ParsErr(194)
		     else if namefound then ParsErr(195);
		     namefound:= true; goto P3;
		  end;
   specification: readspecification(speckind);
		  if cs=INAME or else cs=IVALU then procparerror(217);
	    end else
	    begin if cs <> ISMCL then ParsWarn(286) else
		  detach; !get symbols;
	    end;
   readprocparexit:
	    if specofvirtual then !nothing - virt.spec.; else begin
	       opn:=IEPRM; call(coder); end;
	    setrecsymb(false);
      end readprocpar;
%title *** readclasspar ***

      procedure readclasspar;
      begin character oph;

	    procedure classparerror(errno);short integer errno;
	    begin ParsErr(errno);
     srchagain:   search;
		  if cs=IEND then begin
		     detach; !get symbols; goto srchagain end;
		  if symboltype(rank(cs))=declsymbol
		  then goto specification;
		  if cs=IVIRT then         goto virtualspec;
		  if cs=IHIDD or cs=IPRTC or cs=ITO
		  then goto hiddenprotected;
		  goto readclassparexit;
	    end classparerror;

	    procedure setrecsymb(b); boolean b;
	    begin !character c;
                  recoversymbol(rank(IBOOL)):=b;
                  recoversymbol(rank(ICHAR)):=b;
                  recoversymbol(rank(ISHOR)):=b;
                  recoversymbol(rank(IINTG)):=b;
                  recoversymbol(rank(IREAL)):=b;
                  recoversymbol(rank(ILONG)):=b;
                  recoversymbol(rank(IREF )):=b;
                  recoversymbol(rank(ITEXT)):=b;
                  recoversymbol(rank(IPROC)):=b;
                  recoversymbol(rank(IARRA)):=b;
                  recoversymbol(rank(IEXTR)):=b;
                  recoversymbol(rank(IHIDD)):=b;
                  recoversymbol(rank(IPRTC)):=b;
                  recoversymbol(rank(ISWIT)):=b;
                  recoversymbol(rank(ITO  )):=b;
                  recoversymbol(rank(IVIRT)):=b;
%                for c:=IARRA,IBOOL,ICHAR,IEXTR,IINTG,ILONG,
%                IREAL,IREF,ISHOR,ISWIT,ITEXT,IPROC,
%                IHIDD,IPRTC,ITO  ,IVIRT
%                 do recoversymbol(rank(c)):=b;
	    end;

%+S         Freq(17):=Freq(17)+1;
	    readprocpar(ICSPC);
	    setrecsymb(true);
hiddenprotected:
	    while cs=IHIDD or else cs=ITO or else cs=IPRTC do begin
		  oph:=if cs=ITO then IPRHI else cs;
	      PH: detach; !get symbols;
		  if cs <> IIDN then classparerror(185);
		  opn:=oph; call(coder);
		  getopt:=false; cs:=opt;
                  if cs=ICOMA then goto PH;
		  if cs <> ISMCL then skip(300) else
		  detach; !get symbols;
	    end;

virtualspec:
	    if cs=IVIRT then begin
                  detach; !get symbols;
specification:    readspecification(IVSPC); end;
	    if cs=INAME or else cs=IVALU then ParsErr(217)
       else if cs=IHIDD or else cs=ITO   or else cs=IPRTC then begin
               ParsWarn(291); goto hiddenprotected end
       else if symboltype(rank(cs))=declsymbol then ParsErr(218);

readclassparexit:
	    setrecsymb(false);
      end readclasspar;

%title *** readspecification ***

      !*** ring recursive (called from extbinding->readprocpar) ***;
      procedure readspecification(speckind); character speckind;
      begin character opnx;

	    procedure specificationerror(errno);short integer errno;
	    begin ParsErr(errno);
     searchagain: search;
		  if cs=IEND then begin
		     detach; !get symbols;goto searchagain end;
		  if cs=ICOMA then goto P3;
		  if cs=ISMCL then begin
		     detach; !get symbols; goto spes end;
		  if symboltype(rank(cs))=declsymbol then  goto spes;
		  goto readspecificationexit;
	    end specificationerror;

%+S         Freq(18):=Freq(18)+1;
	    recoversymbol(rank(ICOMA)):=true;
      spes: while true do begin
                  readtypespec; opnx:=NUL;

%                 if readtype<>NUL then begin
%                    if cs<>IPROC and then cs<>IARRA then goto P4;
%                 end
%            else if cs=IPROC then begin opn:=INOTY; call(coder) end
%            else if cs=IARRA then begin opn:=IREAL; call(coder) end
%            else if cs<>ILABE and then cs<>ISWIT then goto P5 end;

                  if readtype=NUL then begin
                     if cs=IPROC then begin opn:=INOTY; call(coder) end
                else if cs=IARRA then begin opn:=IREAL; call(coder) end
                else if cs<>ILABE and then cs<>ISWIT then goto P5 end
             else if cs<>IPROC and then cs<>IARRA then goto P4;

          P2:     opnx:=opn:=cs; call(coder);
          P3:     detach; !get symbols;
          P4:     if cs <> IIDN then specificationerror(185);
	          opn:= speckind; call(coder);
	          if opt=ICOMA then goto P3;
		  getopt:=false; cs:=opt;
	          if cs=IIS and then opnx=IPROC and then speckind=IVSPC
	          then begin !specification of virtual procedure;
	             specofvirtual:=true;
	             if not extbinding then specificationerror(214);
	             specofvirtual:=false;
	             opn:=IEREC; call(coder);
	          end;
	          if cs <> ISMCL then ParsWarn(300)
                  else detach; !get symbols;
	    end;
       P5:  if speckind=IVSPC and then opnx=NUL and then cs=IIDN
	    then begin !*** assume procedure;
	       ParsErr(184); opn:=opnx:=IPROC; call(coder); goto P4
	    end;
readspecificationexit:
	    recoversymbol(rank(ICOMA)):=false; readtype:=NUL;
      end readspecification;

      boolean procedure extbinding; !--- corr: accept spec with type ;
      begin !cs=IIS at entry;
	    detach; !get symbols; readtypespec; extbinding:=false;
	    if cs=IPROC then begin
	       if readtype=NUL then begin opn:=INOTY;call(coder); end;
	       detach; !get symbols;
	       if cs <> IIDN then syntaxerror(185)
	       else begin
		  opn:=if specofvirtual then IBREC else INOTE;
		  call(coder);
		  getopt:=false; cs:=opt;
		  readprocpar(IPSPC); extbinding:=true;
	       end;
	    end
	    else syntaxerror(221);
	    readtype:=NUL;
      end;
%title *****   notBoundPair - repeatedConst   *****

%+PQ        prior
            short integer procedure notBoundPair(colon);
            character colon;
            begin detach; !get symbols; notBoundPair:=0;
%+S             Freq(19):=Freq(19)+1;
	        call(ex);
	        if ex.wasNOTexpr then begin
	           notBoundPair:=4; syntaxerror(188); goto EXIT end;
	        if cs <> ICL and then cs <> IDENO then begin
	           notBoundPair:=4; syntaxerror(189); goto EXIT end;
	        opn:=colon;
	        if colon=IPSPC then begin opn:=ICASE; opdlo:=IPSPC end;
	        call(coder);
	        if cs=IDENO then cs:=IMINU
                else detach; !get symbols;
	        call(ex);
	        if ex.wasNOTexpr then begin
	           notBoundPair:=5; syntaxerror(188) end;
    EXIT:   end;

%           procedure repeatedConst;
%           begin moresymbols; if cs<>ILFPA then error(1000);
%                 opn:=ITO; call(coder);
%           REP:  moresymbols;
%                 call(ex); if ex.wasNOTexpr then error(1000);
%                 if cs = ICOMA then begin
%                    opn:=ISIMU; call(coder); goto REP end;
%                 if cs <> IRGPA then error(1000) else moresymbols;
%                 opn:=ISMCL; call(coder);
%           end;
%title ***   setbasicrec. - markDecl - skip   ***

	    procedure setbasicrecovery;
	    begin !character c;
                  recoversymbol(rank(IEND )):=true;
                  recoversymbol(rank(ISMCL)):=true;
                  recoversymbol(rank(IBEGI)):=true;
                  recoversymbol(rank(IGOTO)):=true;
                  recoversymbol(rank(IWHIL)):=true;
%                 recoversymbol(rank(IGO  )):=true;
                  recoversymbol(rank(IINSP)):=true;
                  recoversymbol(rank(IFOR )):=true;
                  recoversymbol(rank(IINNE)):=true;
                  recoversymbol(rank(IACTV)):=true;
                  recoversymbol(rank(IREAC)):=true;
                  recoversymbol(rank(IEOP )):=true;
%                 for c:=IEND,ISMCL,IBEGI,IGOTO,IWHIL,IGO,
%                        IINSP,IFOR,IINNE,IACTV,IREAC,IEOP
%                  do recoversymbol(rank(c)):=true;
	    end;


% %+P         prior
%             procedure markDecl;
%             begin
% %+S               Freq(20):=Freq(20)+1;
% %+D               if option(rank('2'))<>NUL then W0("Mark decl.");
%             !     if last.blockstatus = stmtnotseen
%             !     then last.blockstatus:=lastwasdecl;
%                   if not last.isblocklike or
%                      last.blockstatus=lastwasstmt
%                   then begin
%                      ParsErr(289); last.blockstatus:=stmtnotseen; end;
%                   last.stmttype:=declunit;
%                   if lastDECLnr < linenr then begin
%                      opn:=ICOMN; call(coder); lastDECLnr:=linenr end;
%             end;

            procedure markStmt; !from GOTO and (RE)ACT;
            begin
                  if last.blockstatus = stmtnotseen or else
                     stmtwnt=classbody or else stmtwnt=procbody
                  then begin
                     last.blockstatus:= lastwasdecl;
                     opn:=IDCLE; call(coder);
                  end;
%                 if lastSTMTnr < linenr then begin
                     opn:=IROPD; call(coder);
%                    lastSTMTnr:=linenr;
%                 end;
            end;

%title ***  S t a t e m e n t  ***

      class statement;
      virtual: procedure recover is boolean procedure recover;;
               procedure recoversetting is procedure recoversetting;;
      begin
            boolean recovered;
            boolean isblocklike; ! is true for blocks, prefixed
                                   blocks and compounds;

            character stmtreq, stmttype;
%              !  stmtreq is requirement to inner unit:
%                         =allstmt    : all statements,
%                         =allbutif   : all but if-stmt,
%                         =outermost  : only block,comp.stmt or
%                                       ext,proc-or class-decl,
%                         =classbody  : classbody,
%                         =stmtorinner: statements or inner,
%                         =procbody   : procedure body.

%                       stmttype is type of actual internal unit:
%                         =basicstmt : basic stmt,block or compound,
%                         =openstmt  : all "open" stmt,
%                         =innerstmt : inner, also used to signal
%                                    split body to class declaration
%                         =declunit  : declaration;
%                         =dummystmt : dummy statement (class decl)


            character blockstatus;
%                   ! only significant when isblocklike=true.
%                     - and at end of class declaration where it
%                       comm. statementseen from class body (PJ).
%                     defines the status with respect to occurence
%                     of declarations and statements.
%                     =stmtnotseen: no statement seen, or error
%                     =lastwasstmt: obvious,
%                     =lastwasdecl: obvious;
%                     Initially, the blockstatus is stmtnotseen.
%                     At the first occurence of a declaration, it
%                     becomes lastwasdecl. At the first occurrence of
%                     a statement, it becomes lastwasstmt, AND (in
%                     certain circumstances, see markStmt) DCLE is
%                     output. Incorrectly placed declarations will
%                     NOT change the value of blockstatus;

            character rp; !react. point, =!0! when finished;
            short integer errorno;
            ref(statement) caller, next;

            procedure recoversetting; ;    ! virtual match;

      end statement;
%title *** syntax - class module ***

      statement class module;
%     hidden RPSW;
      begin boolean SepOK; !true if sep.comp, block or compound;

            boolean procedure recover;
            begin recovered:= recover:=true;
                  rp:= if cs=ISMCL then '!3!' else
                       if cs=IBEGI then '!4!' else
                       if cs=IEOP  then '!6!' else '!5!' ;
            end;

            procedure recoversetting;
            begin if errorno=1 then errorno:=0;
                  recoversymbol(rank(IEOP )):=true;
                  recoversymbol(rank(IEXTR)):=true;
            end;

            switch RPSW:= S0,S1,S2,RECOVER1,RECOVER2,RECOVER3,RECOVER4;

            detach;
%+D         if option(rank('2'))<>NUL then W0("module");

  S0:       isblocklike:=true; blockstatus:=stmtnotseen;
            stmtreq:=outermost;
            if cs=IEXTR then new codebuffer("$ext$");
  RECOVER3: while cs=IEXTR do begin
                  rp:='!1!';
  PARSE:          detach;  goto RPSW(rank(rp)+1);
  S1:             ! if cs <> ISMCL then ParsWarn(286) else ;
  RECOVER1:       ! detach - get symbols;
            end;
%-Z %IMPLNONE OFF
            if coder is codebuffer then coder qua codebuffer.TermModul;

  RECOVER2: rp:='!2!'; goto PARSE;

  S2:       while cs<>IEOP do NEXTSYMBOL;
  RECOVER4: if SepOK or else separatecomp then !OK;
            else ParsErr(212);
            while blockfound>0 do begin
               opn:=IEND; call(coder); blockfound:=blockfound-1 end;
%              terminate inserted psudo-block around ext. declarations
%              (external head of main program) or for/inspect statement;
            opn:=IEOP; call(coder);
            while true do NEXTSYMBOL; !*** skip after final end ***;
            !***  module must never terminate ***;

      end module;
%title *** syntax - class declaration ***

      statement class declaration;
      !*** treating (external) procedure or class declarations.
           All other declarations are handled in grammer;
      begin boolean innerseen,priorseen;
            ! priorseen used 1) to indicate prior procedure,
              2) to indicate stmt within class and
              3) to indicate external procedure (vs. class) ;

            boolean procedure recover;
            if errorno=2 then begin
                  ! an error has occurred in the enclosed
                    statement and it has not recovered;
                  if cs=IEOP then begin
                     opn:=if rp<='!1!' or else (rp='!2!' and innerseen)
                          then IEND else IECWI;
                     opdlo:='!1!';call(coder); blockfound:=blockfound-1;
                  end else recovered:= recover:=true;
            end recover;

      procedure declError(i); short integer i;
      begin errorno:=1; syntaxerror(i); goto PARSE end;

      procedure REGSEPCOMP;
      begin separatecomp:=true;
%-Z %IMPLNONE OFF
            if coder is codebuffer then coder qua codebuffer.TermModul;
%+Z         if option(rank('I'))<>NUL then begin
%+Z            moduleident:-attrfilename:-
%+Z              if opdhi=NUL and opdlo=predefindex then predefname
%+Z         else if nameof(opdhi,opdlo)="simset"      then simsetname
%+Z         else if nameof(opdhi,opdlo)="simulation"  then simulaname
%+Z              else attrfilename;
%+Z            checkcode:-copy("SYS");
%+Z         end else begin
               givetextinfo(1,nameof(opdhi,opdlo));
               attrfilename:-gettextinfo(11);
               moduleident:-gettextinfo(14); checkcode:-gettextinfo(15);
               if checkcode==notext then checkcode:-timestamp;
               if not recomp and moduleident=notext then begin
                  if GiveNotes then note1(397,attrfilename);
                  moduleident:-copy(attrfilename);
               end;
%+Z         end;
      end;

      procedure externalItem;
      begin this grammer.detach; !moresymbols;
            if cs <> IIDN then declError(185);
            opn:=IEXTR; call(coder);
            getopt:=false; cs:=opt;
            if cs=IEQ then begin
               this grammer.detach; !moresymbols;
               if cs <> ICONS or optx <> ITEXT then begin
                  skip(193); goto NoSpec end;
               opn:=IEXNM; call(coder);
               getopt:=false; cs:=opt;
            end
            else begin
%      NoSpec: opdhi:=questhi; opdlo:=questlo;
       NoSpec: opdhi:=opdlo:=NUL;
               opn:=IEXNM; call(coder);
            end;
      end;

            detach;
    REUSE:
%+D         if option(rank('2'))<>NUL then W0("declaration");
            if not caller.isblocklike or else
               caller.blockstatus=lastwasstmt
            then begin
               ParsErr(289); caller.blockstatus:=stmtnotseen; end;
            caller.stmttype:=declunit;
% %           if lastDECLnr < linenr then begin
%                opn:=ICOMN; call(coder);
% %              lastDECLnr:=linenr; end;
        S0: if cs=IPROC then begin
%+S            Freq(34):=Freq(34)+1;
               blockfound:=blockfound+1;
               !*** to avoid dummy blocks in procedures ***;
               if readtype=NUL then begin opn:=INOTY; call(coder) end;
               readtype:=NUL;
               this grammer.detach; !moresymbols;
               if cs <> IIDN then declError(185);
               if caller.stmtreq=outermost then REGSEPCOMP; !TEMP;
%+K            if priorseen then begin
%+K %             if lastDECLnr < linenr then begin
%+K                  opn:=ICOMN; call(coder);
%+K %                lastDECLnr:=linenr; end;
%+K               priorseen:=false; opn:=INONE end else
               opn:=IDCLP; call(coder);
               getopt:=false; cs:=opt;
%+Z            if option(rank('I'))<>NUL then lookforstring;
               readprocpar(IPSPC);
               rp:='!1!'; stmtreq:=procbody;
               errorno:=2; !if error in the enclosed statement;
%-Z %setopt +D
     PARSE:    detach;
%-Z %setopt -D
               switch(NUL:'!3!') rp begin
                 when NUL do goto S0;
                 when '!2!' do goto S2;
                 when '!3!' do goto S3; end;
           S1: blockfound:=blockfound-1; opn:=IEND; call(coder);
            end
       else if cs=IIDN then begin !*** must be subclass decl.;
               opn:=ICPRF; goto if opt=ICLAS then C1 else R1 end
       else if cs=ICLAS then begin
               opn:=INOTY;
          C1:  call(coder);
               this grammer.detach; !moresymbols;
%+S            Freq(35):=Freq(35)+1;
               if cs <> IIDN then declError(185);
               if caller.stmtreq=outermost then REGSEPCOMP; ! TEMP??;
               opn:=IDCLC; call(coder);
               getopt:=false; cs:=opt;
%+Z            if option(rank('I'))<>NUL then lookforstring;
               readclasspar;
               rp:='!2!'; stmtreq:=classbody;
               stmttype:=dummystmt; !if no statement found;
               errorno:=2; !if error in the enclosed statement;
               goto PARSE;
           S2: if innerseen then begin
                  opn:=IEND; opdlo:=NUL; !statementseen set by INNER;
               end
               else begin
                  if blockstatus=stmtnotseen
                  then begin opn:=IDCLE; call(coder) end;
                  opn:=IECWI; !means end class without inner;
                  opdlo:=if stmttype >= declunit or else priorseen
                       then NUL else '!1!';
                       ! the first case covers empty body,
                         the second "block" body without stmt;
               end;
               call(coder);
            end
       else if cs=IRCRD then begin
               opn:=INOTY;
          R1:  call(coder);
               this grammer.detach; !moresymbols;
%+S            Freq(35):=Freq(35)+1;
               if cs <> IIDN then declError(185);
               if caller.stmtreq=outermost then REGSEPCOMP; ! TEMP??;
               opn:=IREAC; call(coder);
%+Z            if option(rank('I'))<>NUL then lookforstring;
% ************ NOTE:  no virtuals - no attr. protect. ***************
               if opt <> ISMCL then declError(286); !NO PARAMETERS;
               this grammer.detach; !moresymbols;
               rp:='!3!'; stmtreq:=classbody;
               stmttype:=dummystmt; !if no statement found;
               errorno:=2; !if error in the enclosed statement;
               goto PARSE;
           S3: if blockstatus=stmtnotseen
               then begin opn:=IDCLE; call(coder) end;
               if priorseen or else stmttype >= declunit then !ok;
               else declError(240); !record cannot have statements;
               opn:=IAFTR; !end record;
               call(coder);
            end
       else if cs=IEXTR then begin
               this grammer.detach; !moresymbols;
               if cs=ICLAS or else cs=IRCRD then begin !priorseen false;
                  opn:=INOTY; call(coder); opn:=cs; call(coder);
               end
               else begin priorseen:=true;
                  if cs=IIDN then begin ! Non-Simula procedure ;
                     if caller.stmtreq=outermost then ParsErr(222);
                     ! Non-Simula procedure in external head ;
                     opn:=ILANG; call(coder);
                     getopt:=false; cs:=opt;
                  end;
                  readtypespec;
                  if readtype=NUL then begin
                     opn:=INOTY; call(coder) end;
                  if cs <> IPROC then declError(192);
                  opn:=IPROC; call(coder);
               end;
               externalItem;
               if cs=IIS then begin ! external binding;
                  if not priorseen then declError(219);
                  if not extbinding then begin
                     errorno:=1; syntaxerror(220); goto PARSE end;
               end else  ! external list ;
               while cs = ICOMA do externalItem;
            end
            else internerr('!4!',sourceline); !intern.decl.err.;
            !declaration must terminate with ISMCL - check and scan off;
            if cs = ISMCL
            then this grammer.detach !moresymbols;
       else if cs <> IEOP then declerror(286);

%+D         if option(rank('2'))<>NUL then W0("unstack declaration");
            !*** pop this statement ***;
            caller.next:-none; last:-caller;
            deList:-this statement;
%-Z %setopt +D
            detach;
%-Z %setopt -D
            !*** reset attributes for reuse ***;
            deList:-none;
            errorno:=0;
            priorseen:=innerseen:=
            recovered:= isblocklike:= false;
            rp:=blockstatus:=stmtreq:=stmttype:=NUL;
            goto REUSE;

      end declaration;
%title *** syntax - class blockOrComp ***

      statement class blockOrComp;
      begin
            boolean innerseen,   ! only used by innerstat;
                    labels,type,unlabbody;
            character blocktype; !  =compstmt   : compound stmt,
                                    =usualblock : block,
                                    =prefixblock: prefixed block;
            character R;  !*** requirement to inner stmt;
            short integer recovernox, recoverno;

            boolean procedure recover;
            begin if cs=IEOP then
                  begin if blocktype=prefixblock or
                           (blocktype=usualblock and not unlabbody) then
                        begin opn:=IEND; call(coder);
                              blockfound:=blockfound-1 end;
                  end
             else begin recoverno:=if cs=ISMCL then 1 else
                                   if cs=IEND  then 2 else 3;
                        if recoverno <> 3 then recovered:=recover:=true;
                        rp:='!2!';
                  end;
            end recover;

            procedure recoversetting;
            begin !character c;
                  recoversymbol(rank(IARRA)):=true;
                  recoversymbol(rank(IREAL)):=true;
                  recoversymbol(rank(IBOOL)):=true;
                  recoversymbol(rank(IREF )):=true;
                  recoversymbol(rank(ICHAR)):=true;
                  recoversymbol(rank(ISHOR)):=true;
                  recoversymbol(rank(IEXTR)):=true;
                  recoversymbol(rank(ISWIT)):=true;
                  recoversymbol(rank(IINTG)):=true;
                  recoversymbol(rank(ITEXT)):=true;
                  recoversymbol(rank(ILONG)):=true;
                  recoversymbol(rank(IPROC)):=true;
%              for c:=!ISMCL,IEND,IBEGI,IGOTO,IFOR,IWHIL,IGO,
%                      IINSP,IACTV,IREAC,IINNE,;
%                      ! these are ALWAYS recovery symbols;
%                   IARRA, IBOOL, ICHAR, IEXTR, IINTG, ILONG,
%                   IREAL, IREF , ISHOR, ISWIT, ITEXT, IPROC
%               do  recoversymbol(rank(c)):=true;
            end;

            detach;
    REUSE:
%+D         if option(rank('2'))<>NUL then W1("blockOrComp",rank(last.stmtreq));
            labels:=labelused;
            if caller.stmtreq=outermost then begin
               caller qua module.SepOK:=true;
%-Z %IMPLNONE OFF
               if coder is codebuffer
               then coder qua codebuffer.TermModul;
            end;
        S0: if ex.startexprstmt then begin !prefixed block;
               ex.startexprstmt:=false;
%+S            Freq(36):=Freq(36)+1;
               opn:=if optx<>NUL then IBPRF else IBEGI;
               ! prefix without or with parameters resp.;
               call(coder);
               this grammer.detach; !moresymbols;
               if cs=ISMCL then begin opn:=IDCLE; call(coder); end;
               isblocklike:=true; blockfound:=blockfound+1;
               blocktype:=prefixblock; blockstatus:=stmtnotseen;
               R:=allstmt; goto unitmore;
            end;
            ! begin is found;
            this grammer.detach; !moresymbols;
            unlabbody:=not labels and then
               (caller.stmtreq=classbody or caller.stmtreq=procbody);
            isblocklike:=true;
            if symboltype(rank(cs))=declsymbol or else
%+K            cs=IPRIO or else
               (cs=IIDN and then (opt=ICLAS or else opt=IRCRD))
            then begin
%+S            Freq(40):=Freq(40)+1;
               blocktype:=usualblock; blockstatus:=stmtnotseen;
               if not  unlabbody then begin
                  opn:=IBLKB; call(coder);
                  blockfound:=blockfound+1;
               end;
            end
            else begin
               blocktype:=compstmt; blockstatus:=lastwasstmt;
               if unlabbody then begin opn:=IDCLE; call(coder) end;
            end;

            R:=if caller.stmtreq=classbody
               and then not labels then stmtorinner else allstmt;

  unitmore: rp:='!1!'; stmtreq:=R;
%-Z %setopt +D
  PARSE:    detach;
%-Z %setopt -D
            if rp=NUL then goto S0;
               !*** else if rp='!1!' then goto S1
                    else goto recoverfromhere;
 recoverfromhere:
  S1:       if stmttype=declunit then begin
               if cs=ISMCL then begin !*** change to dummystmt;
                  stmttype:=dummystmt; goto unitmore end;
               if cs<>IEND then goto unitmore;
            end
       else if stmttype<>dummystmt then blockstatus:=lastwasstmt;

            if recoverno<>0 then begin
               recovernox:=recoverno; recoverno:=0;
               if recovernox=2 then goto endrecover;
               if recovernox=3 then goto unitmore;
            end;
              
            if cs<>IEND then begin
               if cs=ISMCL then begin
                  this grammer.detach; !moresymbols; goto unitmore end;
               syntaxerror(204); goto PARSE;
            end;
  endrecover:  if blocktype=prefixblock or
               (blocktype=usualblock and not unlabbody)
            then begin
%                 if blockstatus=lastwasdecl then begin
%                    opn:=IDCLE; call(coder) end;
               opdlo:=if innerseen or else blockstatus<>lastwasstmt
                      then NUL else '!1!';
               opn:=IEND; call(coder);
               blockfound:=blockfound-1 end;
            if caller.stmtreq=classbody then begin
               if innerseen
               then caller qua declaration.innerseen:=true
               else caller qua declaration.priorseen:=
                                     blockstatus <> lastwasstmt;
               !*** caller.priorseen TRUE: no statements in body;
            end;
            this grammer.detach; !moresymbols;
%+D         if option(rank('2'))<>NUL then W0("unstack blockOrComp");
            !*** pop this statement ***;
            caller.next:-none; last:-caller;
            exList:-this statement;
%-Z %setopt +D
            detach;
%-Z %setopt -D
            !*** reset attributes for reuse ***;
            exList:-none;
            recovernox:=recoverno:=
            errorno:=0;
            innerseen:=labels:=type:=unlabbody:=
            recovered:= isblocklike:= false;
            blocktype:=R:=
            rp:=blockstatus:=stmtreq:=stmttype:=NUL;
            goto REUSE;

      end of blockOrComp;
%title ***  WHILE / GOTO - Statement  ***

%  while-statement   while B do S   is transformed to
%
%          BDEST;
%     (*)  if B then begin
%          S;
%          BJUMP;
%     (*)  end;
%
%     (*) is generated only if B<>true

      statement class whilstat;
      begin

            boolean procedure recover;
            if cs=IDO then begin rp:='!2!'; recovered:=recover:=true end
            else begin recovered:=false; opn:=IFALS; call(coder);
                       opn:=IIFSE; call(coder);
            end;

            procedure recoversetting;
                  recoversymbol(rank(IDO)):=true;

            detach;
    REUSE:
%+D         if option(rank('2'))<>NUL then W0("WHILE");

        S0: caller.stmttype:=openstmt;
            this grammer.detach; !moresymbols;
            opn:=ITRUE; call(coder);
            if cs=ICONS and then opdhi=NUL and then opdlo=ITRUE
               and then opt=IDO
            then rp:='!3!'
            else begin
               opn:=IIFSB; call(coder);
               call(ex);
               if ex.wasNOTexpr or else cs<>IDO then begin
                  syntaxerror(if cs<>IDO then 206 else 205);
                  goto PARSE end;
  recover1:    opn:=ITHSB; call(coder);
               rp:='!1!';
            end;
            this grammer.detach; !moresymbols;
%-Z %setopt +D
     PARSE: detach;
%-Z %setopt -D
            opn:=IFALS; call(coder); !*** loop back;
            switch(NUL:'!3!') rp begin
            when NUL do
                 goto S0;
            when '!2!' do
                 goto recover1;
            when '!1!' do begin
                 opn:=IIFSE; call(coder) end;
            end ***case***;

%+D         if option(rank('2'))<>NUL then W0("unstack while");
            !*** pop this statement ***;
            caller.next:-none; last:-caller;
            whList:-this statement;
%-Z %setopt +D
            detach;
%-Z %setopt -D
            !*** reset attributes for reuse ***;
            whList:-none;
            errorno:=0;
            recovered:= isblocklike:= false;
            rp:=blockstatus:=stmtreq:=stmttype:=NUL;
            goto REUSE;

      end whilstat;


%     statement class gotostat;
%     begin
%           boolean procedure recover;
%           begin opn:=IGOE; call(coder); end;

% D         if option(rank('2'))<>NUL then W0("gotostat");

%       S0: caller.stmttype:=basicstmt;
%           opn:=IGOTO; call(coder); NEXTSYMBOL;
%           call(ex);
%           if ex.NOTdesig then begin
%              syntaxerror(191); detach; goto S0 end;
%           opn:=IGOE; call(coder);
%           goList:-this statement;

%     end gotostat;
%title ***  IF - Statement  ***

      statement class ifstat;
      begin
            boolean procedure recover;
            begin recovered:= recover:=true;
                  if cs=ITHEN then rp:='!3!'
             else if cs=IELSE then begin
                        opn:=ITHSB; call(coder); rp:='!4!' end
             else begin opn:=ITHSB; call(coder);
                        opn:=IIFSE; call(coder);
                        recovered:=recover:=false;
                  end;
            end;

            procedure recoversetting;
            begin !character c;
                  recoversymbol(rank(ITHEN)):=true;
                  recoversymbol(rank(IELSE)):=true;
%                 for c:=ITHEN,IELSE do recoversymbol(rank(c)):=true;
            end;

            detach;
    REUSE:
%+D         if option(rank('2'))<>NUL then W0("IF");

        S0: if caller.stmtreq=allbutif then ParsWarn(213);
            caller.stmttype:=openstmt;
            opn:=IIFSB; call(coder);
            this grammer.detach; !moresymbols;
            call(ex);
            if ex.wasNOTexpr then syntaxerror(205) !not expr after IF;
            else begin
               if cs = ITHEN then begin
  recover1:       opn:=ITHSB; call(coder);
                  this grammer.detach; !moresymbols;
                  stmtreq:=allbutif; rp:='!1!';
               end else syntaxerror(207) !missing THEN;
            end;

%-Z %setopt +D
     PARSE: detach;
%-Z %setopt -D
            switch(NUL:'!4!') rp begin
              when '!2!' do goto S2;
              when '!3!' do goto recover1;
              when '!4!' do goto recover2;
              when NUL do goto S0; end;

            ! rp='!1!': Return from stmt following then;
     S1:    if cs=IELSE then begin
% WRONG!?      if stmttype<>basicstmt and then stmttype<>dummystmt
% WRONG!?      then ParsWarn(208);
% WRONG!?      ! stmt after then was conditional, else-part illegal;
   recover2:   opn:=IELSB; call(coder);
               this grammer.detach; !moresymbols;
               stmtreq:=allstmt; rp:='!2!'; goto PARSE;
            end;
            
     S2:    opn:=IIFSE; call(coder);
%+D         if option(rank('2'))<>NUL then W0("unstack if");
            !*** pop this statement ***;
            caller.next:-none; last:-caller;
            ifList:-this statement;
%-Z %setopt +D
            detach;
%-Z %setopt -D
            !*** reset attributes for reuse ***;
            ifList:-none;
            errorno:=0;
            recovered:= isblocklike:= false;
            rp:=blockstatus:=stmtreq:=stmttype:=NUL;
            goto REUSE;

      end ifstat;

%title *** FOR - Statement ***

%  The general FOR statement   for cvar:=FELT1,FELT2,...,FELTn do S
%  is changed to  (for cvar:=FELTi and term FELTi, see later)
%  NOTE: the enclosing block (marked + below) is generated only when
%        no enclosing block exists. Otherwise, the for variable is
%        placed in the available block. Thus, at most one block is
%        created for nested FOR-statements.
%        The name U1 is not generated as a quantity, the statement tag
%        is placed directly in the idtag field of identsymbol. The exit
%        tag is = statement tag+1

%  +     BLKB               - block to hold forvar
%        WHIL  <var> ILABE  - FOR variable (LABEL variable)
%  +     DCLE
%        FOR   cvar         - cvar here for checking in Pass 2
%        cvar:=FELT1;
%        ELME  U1           ==> set forvar, and fjump to statement
%        <term FELT1>
%        cvar:=FELT2;
%        ELME  U1           ==> set forvar, and fjump to statement
%        <term FELT2>
%        ...
%        cvar:=FELTn;
%        ELME  U1           ==> set forvar, and fjump to statement
%        <term FELTn>
%        DO    U1           - set statlabel
%        <S>
%        UNTI  U1           - perform GOTO forvar and set exitlabel
%        FORE
%  +     END                - of block
%
%  If only one FELT is given, the above generates to
%
%        FOR   cvar
%        cvar:=FELT;
%        <S>
%        <term FELT>
%        FORE
%
%  The for elements are divided into
%     0. errors has occurred
%     1. simple for-step-until (step expr is a constant)
%     2. while
%     3. simple assign (denote)
%     4. complex for-step-until
%  Generally, the for elements are transformed to the defining code
%  given in the Standard.
%  The corresponding L2-code is
%
%  Case 1: (simple step-until, i.e.stepexpr is constant)
%
%    cvar:=FELT:   IDN <cvar>  <-- cvarelt
%                  ASSG
%                  <expr1>
%                  ASGE
%                  TRUE
%                  IFSB
%                  IDN <cvar>
%                  LE / GE  -- dep. on the sign of expr2
%                  <expr3>
%                  THSB
%
%    term FELT:    IDN <cvar>
%                  ASSG
%                  IDN <cvar>
%                  PLUS
%                  SCST <expr2>  <-- stepepr
%                  ASGE
%                  FALS
%                  IFSE
%
%  Case 2: while
%
%    cvar:=FELT:   TRUE          <-- whildest
%                  IDN <cvar>
%                  ASSG / DENO
%                  <expr1>
%                  ASGE
%                  IFSB
%                  <expr2>
%                  THSB
%
%    term FELT:    FALS          --> whildest
%                  IFSE
%
%  Case 3: - simple assignment
%
%    cvar:=FELT:   IDN <cvar>
%                  ASSG / DENO
%                  <expr1>
%                  ASGE
%
%    term FELT:    - empty
%
%  Case 4: step-until with non-constant stepexpr
%
%  The implementation is not strictly exact. Only two types are used
%  for the DELTA variable, INTG and LONG. The type of DELTA cannot
%  be decided until Pass2, therefore a special ASGE on the
%  assignments to U2, see (*).
%  The declarations of DELTA are placed in an enclosing block, see above

%                  WHIL  deltaInt INTG
%                  WHIL  deltaLng LONG
%    cvar:=FELT:   IDN <cvar>  <-- cvarelt
%                  ASSG
%                  <expr1>
%                  ASGE
%                  IIDN  deltaInt
%                  ASSG
%                  <expr2>
%  (*)             STEP  deltaInt
%                  TRUE
%                  IFSB
%                  IIDN  deltaInt
%                  MULT
%                  LPAR
%                  IDN <cvar>
%                  MINU
%                  <epr3>
%                  RPAR
%                  LE
%                  "0"
%                  THSB
%
%    term FELT:    IIDN  deltaInt
%                  ASSG
%                  <expr2>
%  (*)             STEP  deltaInt
%                  IDN <cvar>
%                  ASSG
%                  IDN <cvar>
%                  PLUS
%                  IIDN  deltaInt
%                  ASGE
%                  FALS
%                  IFSE
%
      statement class forstat;
      begin boolean enclgen;  !true if dummy block generated;
            boolean commaSeen; !true if more than one for-elt;
            character ftype;  !indicates type of for-stat;
            character forass; !IASSG or IDENO;
            short integer oldUniq; !for resetting uniqueIndex at end;
            ref(codebuffer) forcoder;

            boolean procedure recover;
            begin ! switch erroraction:=
                    ERR1,ERR2,ERR3,ERR4,ERR5,ERR6,ERR7,ERR8;
%                 goto erroraction(errorno);
%           ERR2:      opn:=IFASG; call(coder);
%                      opn:=IABTE; call(coder);
%           ERR7:ERR8:
%           ERR3:ERR4: opn:=IDO;   call(coder);
%                      opn:=IFORE; call(coder);
%                      if enclgen then begin       
%                         enclgen:=false; blockfound:=blockfound-1;
%                         opn:=IEND; call(coder) end;
%                      goto exit;
%           ERR5:ERR6: opn:=IUNTI; call(coder);
%                      opn:=IABTE; call(coder);
%                      ! Complete for-stmt from do;
%                      goto ERR4;
%           ERR1:
       exit:end recover;

            procedure terminateForelt;
%-Z %IMPLNONE OFF
            inspect forcoder do begin
               switch(NUL:'!4!') ftype begin
               when '!1!' do begin !simple step-until;
                  cvar.emit;
                  opn:=IASSG; call(coder);
                  cvar.emit;
                  opn:=IPLUS; call(coder);
                  stepexpr.emit;
                  opn:=IASGE; call(coder);
                  goto termIF;
                  end;
               when '!2!' do begin !while;
        termIF:   opn:=IFALS; call(coder);
                  opn:=IIFSE; call(coder);
                  end;
%                when '!3!' do begin !pure assign - nothing;
%                   end;
               when '!4!' do begin !complex step-until;
                  deltavar.emit;
                  opn:=IASSG; call(coder);
                  copyexpr(stepexpr);
%                 opn:=IASGE; call(coder);
                  opn:=ISTEP; opdhi:=deltavar.opdhii;
                              opdlo:=deltavar.opdloo; call(coder);
                  cvar.emit;
                  opn:=IASSG; call(coder);
                  cvar.emit;
                  opn:=IPLUS; call(coder);
                  deltavar.emit;
                  opn:=IASGE; call(coder);
                  opn:=IFALS; call(coder);
                  opn:=IIFSE; call(coder);
                  end;
               end ***case***;
               stepexpr:-none;
            end;

%+PQ        prior
            procedure new_elt(opn); character opn;
%-Z %IMPLNONE OFF
            inspect forcoder do inspect new elt do begin opnn:=opn;
                  next:-curelt.next; curelt:-curelt.next:-this elt;
            end;

            detach;
            forcoder:-new codebuffer("$for$");
    REUSE:
%+D         if option(rank('2'))<>NUL then W0("FOR");

%-Z %IMPLNONE OFF
         inspect forcoder do begin
            !oldUniq:=uniqueIndex;

     S0:    caller.stmttype:=openstmt;
            this grammer.detach; !moresymbols;
            if cs<>IIDN then begin
%              errorno:=1; syntaxerror(185); goto PARSE end;
               errorno:=               185 ; goto PARSE end;
            opn:=IFOR ; call(forcoder);
            wheeler :-curelt;
            if opt<>IASSG and then opt<>IDENO then begin
               getopt:=false; cs:=opt;
%              errorno:=2; syntaxerror(209); goto PARSE end;
               errorno:=               209 ; goto PARSE end;
            opn:=IIDN ; call(forcoder); cvar:-curelt;
            forass:=opt;
            this grammer.detach; !moresymbols;
   forelem: ! treatment of a for element;
            new_elt(forass);
            call(ex);
            new_elt(IASGE);
            if ex.wasNOTexpr then begin
%              errorno:=3; syntaxerror(205); goto PARSE end;
               errorno:=               205 ; goto PARSE end;
            if cs=ISTEP then begin ftype:='!1!';
               forvar:-curelt;
               new_elt(ITRUE); new_elt(IIFSB); stepexpr:-curelt;
% ??? qual ??? stepelt:-coder qua codebuffer.curelt;
               this grammer.detach; !moresymbols;
               call(ex);
               if ex.wasNOTexpr then begin
%                 errorno:=5; syntaxerror(205); goto PARSE end;
                  goto exprErr end;
               if cs <> IUNTI then begin
%                    errorno:=6; syntaxerror(210); goto PARSE end;
                     errorno:=               210 ; goto PARSE end;
%-Z %IMPLNONE OFF
               inspect stepexpr.next do begin
                  if curelt=/=this elt or else
                     (opnn<>ISCST and then opnn<>ICONS)
                  then begin !non-constant stepexpr - take out;
                     ftype:='!4!'; curelt:-stepexpr; curelt.next:-none;
                  end else curelt:-stepexpr;
                  stepexpr:-this elt;
               end;
               if ftype='!4!' then begin
                  if deltavar==none then begin
                     if blockfound=0 then begin
                        curelt:-firstelt;
                        new_elt(IBLKB); new_elt(IDCLE);
                        blockfound:=1; enclGen:=true;
                     end;
                     curelt:-firstelt.next;
                     simsymbol:-         leftint(uniqueindex);
                     simsymbol:-"$int" & simsymbol; DEFIDENT;
                     uniqueindex:=uniqueindex+1;
                     inspect new elt do begin
                        deltavar:-this elt;
                        opdhii:=hashhi; opdloo:=hashlo;
                        opnn:=IWHIL; optxx:=IINTG;
                     end;
                     deltavar.emit;
                     deltavar.opnn:=IIDN; !for all further use;
                     simsymbol.sub(2,3):="lrl"; DEFIDENT;
                     opdhi:=hashhi; opdlo:=hashlo;
                     opn:=IWHIL; optx:=ILONG; call(forcoder);
                  end;
                  curelt:-forvar; ! i.e. find(IWSTB);
                  deltavar.emit;
                  opn:=IASSG; call(forcoder);
                  copyexpr(stepexpr);
%                 new_elt(IASGE);
                  deltavar.emit; curelt.opnn:=ISTEP;
                  curelt:-curelt.next.next; !i.e. WSTB;
                  deltavar.emit;
                  new_elt(IMULT); new_elt(ILFPA);
                  cvar.emit;
                  new_elt(IMINU); new_elt(ILFPA);
               end
%-Z %IMPLNONE OFF
               else inspect stepexpr do begin
                  cvar.emit;
                  new_elt(if loadchar(nameof(opdhii,opdloo),0)='-'
                          then IGE else ILE);
               end;
               this grammer.detach; !moresymbols;
               call(ex);
               if ex.wasNOTexpr then begin
%                 errorno:=7; syntaxerror(205); goto PARSE end;
                  goto exprErr end;
               if ftype='!4!' then begin
                  new_elt(IRGPA); new_elt(IRGPA);
                  new_elt(ILE  );
                  opn:=ISCST; opdhi:=zerohi; opdlo:=zerolo; optx:=IINTG;
                              call(forcoder);
               end;
               new_elt(ITHSB);
                  
            end else
            if cs=IWHIL then begin ftype:='!2!';
               new_elt(IIFSB);
               forvar:-curelt;
               curelt:-wheeler; new_elt(ITRUE); curelt:-forvar;
               this grammer.detach; !moresymbols;
               call(ex);
               if ex.wasNOTexpr then begin
%                 errorno:=8; syntaxerror(205); goto PARSE end;
       exprErr:   errorno:=               205 ; goto PARSE end;
               new_elt(ITHSB);
            end
            else ftype:='!3!';
            if cs=ICOMA or else commaSeen then begin
               if not commaSeen then begin commaSeen:=true;
                  statlabel:-curelt; !save curelt;
                  curelt:-firstelt;
                  if blockfound=0 then begin
                     new_elt(IBLKB); new_elt(IDCLE);
                     blockfound:=1; enclGen:=true;
                     curelt:-firstelt.next;
                  end
                  else while curelt.next.opnn <>
                       (if enclGen then IDCLE else IFOR)
                     !FOR variables must be inserted last in decl;
                     do curelt:-curelt.next;
                  simsymbol:-         leftint(fornests);
                  simsymbol:-"$for" & simsymbol;         DEFIDENT;
                  fornests:=fornests+1;
                  opn:=IWHIL; opdhi:=hashhi; opdlo:=hashlo; optx:=ILABE;
                  call(forcoder);
                  curelt:-statlabel; !restore curelt;
                  simsymbol.sub(2,3):="stm"; DEFIDENT;
                  inspect new elt do begin
                     statlabel:-this elt;
                     opdhii:=hashhi; opdloo:=hashlo; opnn:=IELME end;
               end;
               statlabel.emit; terminateForelt;
               if cs=ICOMA then begin
                  wheeler :-curelt;
                  cvar.emit;
                  this grammer.detach; !moresymbols; goto forelem end;
               new_elt(IDO);
               statlabel.emit; curelt.opnn:=ICL;
            end;
            if cs = IDO then begin
               terminate; !output buffer, reset coder, delete garbage;
               this grammer.detach; !moresymbols;
               stmtreq:=allstmt; rp:='!1!';
            end
            else begin
%              errorno:=4; syntaxerror(206);
               errorno:=               206 ;
    PARSE:     firstelt.next:-none; ftype:=NUL;
               terminate; ! reset coder, delete garbage;
               syntaxerror(errorno);
            end;
               
            this forstat.detach;

            if rp = NUL then goto S0;
        S1: ! finish of for-stmt;
            if CommaSeen then begin commaSeen:=false;
               fornests:=fornests-1;
               statlabel.opnn:=IUNTI; statlabel.emit;
            end
            else terminateForelt;
            opn:=IFORE; call(coder);
            if enclGen then begin enclGen:=false;
               blockfound:=blockfound-1; opn:=IEND; call(coder); end;
            !uniqueIndex:=oldUniq;
            statlabel:-deltavar:-forvar:-wheeler:-cvar:-none;
         end inspect forcoder;
%+D         if option(rank('2'))<>NUL then W0("unstack for");
            !*** pop this statement ***;
            caller.next:-none; last:-caller;
            foList:-this statement;
            detach;
            !*** reset attributes for reuse ***;
            foList:-none;
            forcoder.prev:-coder; coder:-forcoder;
            errorno:=0;
            recovered:= isblocklike:= false;
            rp:=blockstatus:=stmtreq:=stmttype:=NUL;
            goto REUSE;

      end forstat;

%title *** INSPECT - Statement ***

      statement class inspectstat;
      hidden protected firstwhen,iothwsent,enclgen;
      begin boolean firstwhen,iothwsent,enclgen;

            boolean procedure recover;
            begin recover:=false;
                  if errorno=1 or else errorno=2 then begin
                     opn:=ICONB; call(coder) end;
                  opn:=if iothwsent then IOTHE else ICONE; call(coder);
                  if enclgen then begin enclgen:=false;
                     blockfound:=0; opn:=IEND; call(coder) end;
            end recover;

            detach;
    REUSE:
%+D         if option(rank('2'))<>NUL then W0("inspect");
            if blockfound=0 and then (dummygen or not separatecomp)
            then begin enclgen:=true; blockfound:=1;
                opn:=IBLKB; call(coder); end;

        S0: caller.stmttype:=openstmt;
            opn:=IINSP; call(coder);
            this grammer.detach; !moresymbols;
            call(ex);
            if ex.wasNOTexpr then begin
                  errorno:=1; syntaxerror(205); goto PARSE end;
            if cs=IWHEN then firstwhen:=true
            else begin
                  if cs=IDO then begin
                     opn:=ICONB; call(coder);
                     this grammer.detach; !moresymbols;
                     stmtreq:=allstmt; rp:='!2!' end
                  else begin errorno:=2; syntaxerror(211) end;
%-Z %setopt +D
     PARSE:       detach;
%-Z %setopt -D
                  switch(NUL:'!3!') rp begin
                    when NUL do goto S0;
                    when '!2!' do goto S2;
                    when '!3!' do goto S3; end;
            end;

       S1:  ! Treatment of a when-list;
            while cs=IWHEN do begin
                  this grammer.detach; !moresymbols;
                  if cs <> IIDN then begin
                        errorno:=3; syntaxerror(185); goto PARSE end;
                  if firstwhen then begin opn:=IFWHN; firstwhen:=false
                  end else opn:=IWHEN; call(coder);
                  if opt <> IDO then begin
                       getopt:=false; cs:=opt;
                       errorno:=4; syntaxerror(206); end
                  else begin
                       this grammer.detach; !moresymbols;
                       stmtreq:=allstmt; rp:='!1!';
                  end;
                  goto PARSE;
            end;
            ! cs is not when, look for otherwise;
       S2:  ! treatment of a possible otherwise;
            if cs=IOTHW then begin
                  opn:=IOTHW; call(coder);
                  this grammer.detach; !moresymbols;
                  iothwsent:=true;
                  stmtreq:=allstmt; rp:='!3!'; goto PARSE;
       S3:        ! Return from statement after otherwise,output
                    special end of connection;
                  opn:=IOTHE; call(coder);
                  goto ENDINSP;
            end;
            ! inspect finish;
            opn:=ICONE; call(coder);
 ENDINSP:   if enclgen then begin enclgen:=false;
               blockfound:=0; opn:=IEND; call(coder) end;
%+D         if option(rank('2'))<>NUL then W0("unstack inspect");
            !*** pop this statement ***;
            caller.next:-none; last:-caller;
            itList:-this statement;
%-Z %setopt +D
            detach;
%-Z %setopt -D
            !*** reset attributes for reuse ***;
            itList:-none;
            errorno:=0;
            firstwhen:=iothwsent:=enclgen:=
            recovered:= isblocklike:= false;
            rp:=blockstatus:=stmtreq:=stmttype:=NUL;
            goto REUSE;

      end inspectstat;

%title *** CASE - Statement ***

%     SYNTAX:  ICASE <expr> IIN <lb>:<ub>
%              IWHEN <select-list> IDO <statement>
%                .....
%              IOTHW <statement>  -- if out of range or not in list

%     select-list:  ( <expr> ! <low> ICL <hi> )  (ICOMA <select-list>)*

      statement class casestat;
      hidden protected nocolon;
      begin  boolean nocolon;

            boolean procedure recover;
            begin recover:=false;
                  if errorno=1 then begin !invalid case-expr;
                     rp:='!1!';
                  end
             else if errorno=2 then begin !invalid expr after when;
                     L2output(ICPRF);
                  end
             else if errorno=3 then begin !missing semic after branch;
                     !recover:=true;
                  end
             else ! if errorno=4 then begin !error in bound-pair;
                  begin !error 5: error in bound-pair;
                     L2output(ICSPC);
                  end;
                  errorno:=0;

            end recover;

            procedure L2output(code); character code;
            begin opn:=ICASE; opdlo:=code; call(coder) end;

            detach;
    REUSE:
%+D         if option(rank('2'))<>NUL then W0("case");

        S0: caller.stmttype:=openstmt;
            L2output(NUL);
            errorno:=notBoundPair(IPSPC); if errorno<>0 then goto PARSE;
            L2output(IVSPC);
            if cs<>IRGPA then ParsWarn(285)
            else this grammer.detach; !moresymbols;
            call(ex);
            if ex.wasNOTexpr then begin
                  errorno:=1; syntaxerror(230); goto PARSE end;
            L2output(ICSPC);
            if cs<>IBEGI then ParsWarn(435)
            else this grammer.detach; !moresymbols;
            while cs=IWHEN do begin
               cs:=ICOMA;
               while cs=ICOMA do begin
                  L2output(ILABE); nocolon:=true;
          NXTL:   this grammer.detach; !moresymbols; call(ex);
                  if ex.wasNOTexpr then begin
                     errorno:=2; syntaxerror(231); goto PARSE end;
                  if cs=ICL and then nocolon then begin
                     L2output(IFRMP); nocolon:=false; goto NXTL end;
                  L2output(ICPRF);
               end cs=ICOMA;
               if cs<>IDO then ParsErr(206)
               else this grammer.detach; !moresymbols;
               stmtreq:=allstmt; rp:='!1!';
%              if lastSTMTnr < linenr then begin
                  opn:=IROPD; call(coder);
%                 lastSTMTnr:=linenr;
%              end;
% Z %setopt +D
     PARSE:    detach;
% Z %setopt -D
               if rp<>'!1!' then begin
                  if rp=NUL then goto S0;
                  if rp='!3!' then goto S3;
               end;
%              L2output(if opn=IGOE then ISSWB else ISWIT);
               L2output(ISWIT);
               if cs<>ISMCL then begin
                  errorno:=3; syntaxerror(286); goto PARSE end;
               this grammer.detach; !moresymbols;
               if rp = '!2!' then goto S2;
            end cs=IWHEN;
            if cs=IUPLS then begin
               L2output(INONE);
               this grammer.detach; !moresymbols;
               if cs<>IDO then ParsWarn(206)
               else this grammer.detach; !moresymbols;
               stmtreq:=allstmt; rp:='!2!'; goto PARSE;
            end;
     S2:    while cs=ISMCL do this grammer.detach; !moresymbols;
                              ! must skip dummies here ;
            if cs<>IEND then ParsErr(436)
            else this grammer.detach; !moresymbols;
            if cs=IOTHW then begin
               L2output(IVALU);
               this grammer.detach; !moresymbols;
               stmtreq:=allstmt; rp:='!3!'; goto PARSE;
            end;
     S3:    L2output(IEPRM);
%+D         if option(rank('2'))<>NUL then W0("unstack case");
            !*** pop this statement ***;
            caller.next:-none; last:-caller;
%           caList:-this statement;
% Z %setopt +D
            detach;
% Z %setopt -D
            !*** reset attributes for reuse ***;
%           --- case statement is not reused ---
%           caList:-none;
%           errorno:=0;
%           recovered:= isblocklike:= false;
%           rp:=blockstatus:=stmtreq:=stmttype:=NUL;
%           goto REUSE;

      end casestat;

%title *** ACTIVATE / INNER / DUMMY - Statement ***

%     statement class innerstat;
%     begin
% D         if option(rank('2'))<>NUL then W1("innerstat",rank(last.stmtreq));
%           if caller.stmtreq = stmtorinner then begin
%              inspect caller qua blockOrComp do
%                 if innerseen then ParsErr(203)
%                 else begin
%                    opd:=if blockstatus=lastwasstmt then 1 else 0;
%                    opn:=IINNE; call(coder);
%                    innerseen:=true;
%                 end
%           end
%           else ParsWarn(287);
%           NEXTSYMBOL;
%           inList:-this statement;

%     end innerstat;


%       statement class dummystat;
% %     dummy statement is generated only in error situations.
%       begin
%             boolean procedure recover;  recover:=false;
% 
% %+D         if option(rank('2'))<>NUL then W0("dummystat");
% 
%         S0: while cs<>IEND  and then cs<>ISMCL and then
%                   cs<>IELSE and then cs<>IWHEN and then
%                   cs<>IOTHW and then cs<>IEOP
%             do begin
%                detach;
% %+D            if option(rank('2'))<>NUL then W1("dummy called - cs:",rank(cs));
%                goto S0;
%             end;
% %+D         if option(rank('2'))<>NUL then W0("unstack dummystat");
% 
%       end dummystat;
%title ***  E x p r e s s i o n  ***

      class expression;
      hidden protected operatortype,opnx,lastsymb,ex;
      begin boolean wasNotexpr,startexprstmt,
                    NOTblockprefix,NOTdesig,NOTlhsassig,NOTrefexpr;

%        TRUE means:
%                             wasNOTexpr: incorrect expression
%        A: IF-expr     B: DOT/QUA     C: operator/CONST<>notext/IN/IS
%        D: LFPA in primary            E: lastsymbol was RGPA
%        F: NEW/THIS or notext         G: lastsym QUA

            character operatortype;
            character opnx; !*** workvariables in exp;
            character lastsymb;! last symbol - INOTY,ILFPA or IQUA;

            ref(expression) ex;

            procedure exp(sr); boolean sr;  !RECURSIVE;
            begin ! sr=true means that a simple expression is required
                              (not starting with 'IF');

                  short integer parnum;

                  procedure parexprecover;
                  begin ! recovers from errors in expressions
                                occurring as parameter expressions;
                        recoversymbol(rank(ICOMA)):=true;
                        recoversymbol(rank(IRGPA)):=true;
                        search;
                        recoversymbol(rank(ICOMA)):=false;
                        recoversymbol(rank(IRGPA)):=false;

%                       -- if ibrecoutput then
%                       -- begin opn:=IEREC; call(coder);
%                       --       ibrecoutput:=false; end;
                        goto (if cs=ICOMA then comarecover else
                           if cs=IRGPA then rgparecover else rgpaerror);
                  end parexprecover;

%+S               Freq(22):=Freq(22)+1;
                  ! parnum:= 0;
%+D               if option(rank('2'))<>NUL then W0("exp called");

         restart: if cs=IIF then begin
                     if sr and then parnum=0 then begin
%+D                     if option(rank('2'))<>NUL
%+D                     then W1("experror",225);
                        experrorno:=225; goto Eabte end;
                     opn:=IIF; call(coder);
                     this grammer.detach; !moresymbols;
                     if ex==none then ex:-new expression;
                     call(ex); !*** inner expression;
                     if ex.wasNOTexpr then goto Eset;
                     if cs <> ITHEN then begin
%+D                     if option(rank('2'))<>NUL
%+D                     then W1("experror",207);
                        experrorno:=207; goto Eabte end;
                     opn:=ITHEN; call(coder);
                     this grammer.detach; !moresymbols;
                     exp(true);
                     if cs <> IELSE then begin
%+D                     if option(rank('2'))<>NUL
%+D                     then W1("experror",226);
                        experrorno:=226; goto Eabte end;
                     opn:=IELSE; call(coder);
                     this grammer.detach; !moresymbols;
                     exp(false);
                     opn:=IEEXP; call(coder);
                     if parnum=0 then begin
                        NOTblockprefix:=NOTlhsassig:=NOTrefexpr:=true;
                        lastsymb:=INOTY; goto expexit end;
         RPARout:    opn:=IRGPA; call(coder);
                     if cs<>IRGPA then ParsWarn(285)
                     else this grammer.detach; !moresymbols;
                     lastsymb:=IRGPA; parnum:= parnum-1; goto postfix;
                  end;
       prefix:    if cs=INOT then begin
       relopout:     opn:=cs; 
                     NOTblockprefix:=NOTdesig:=
                     NOTlhsassig:=NOTrefexpr:=true;
                     call(coder);
                     this grammer.detach; !moresymbols; end;

                  if cs=IMINU then begin
                     this grammer.detach; !moresymbols;
                     if cs=ICONS then begin
                        !convert to negative constant;
%-Z %IMPLNONE OFF
                        inspect boxof(opdhi,opdlo) do begin
                           if digit(loadchar(symbol,0))
                           then begin simsymbol:-"-"&symbol;
                              DEFCONST; opdhi:=hashhi; opdlo:=hashlo;
                              goto constout;
                           end;
                        end;
                     end;
                     opn:=IUMNS;
       arithopout:   call(coder);
                     if opn<>IUMNS
                     then this grammer.detach; !moresymbols;
                     NOTblockprefix:=NOTdesig:=
                     NOTlhsassig:=NOTrefexpr:=true;
                  end else
                  if cs=IPLUS then begin 
                     this grammer.detach; !moresymbols;
                     NOTblockprefix:=NOTdesig:=
                     NOTlhsassig:=NOTrefexpr:=true;
                  end;

       constout:  lastsymb:=INOTY;
                  if cs=IIDN then opn:=IIDN
                  else begin
                     NOTblockprefix:=true;
                     if cs=ICONS then begin
                        opn:=ICONS; call(coder);
                        getopt:=false; cs:=opt;
                        NOTdesig:=true;
                        if opdhi=NUL and then opdlo = INOTE then begin
                           !CONS was notext;
                           goto postfix;  end;
                        NOTlhsassig:=NOTrefexpr:=true;
                        goto operator;
                     end;
                     if cs=ILFPA then begin
                        opn:=ILFPA; call(coder);
                        this grammer.detach; !moresymbols;
                        parnum:=parnum+1; goto restart;
                     end;
                     NOTdesig:=true;
                     if cs=ITHIS then begin
                        this grammer.detach; !moresymbols;
%                       if cs <> IIDN then experror(185);
                        if cs <> IIDN then goto E185;
                        opn:=ITHIS; call(coder);
                        getopt:=false; cs:=opt;
                        goto postfix;
                     end;
                     if cs<>INEW
%                    then experror(if symboltype(rank(cs))=exprtermin
%                                  then 229 else 228)
                     then begin
%+D                     if option(rank('2'))<>NUL
%+D                     then W1("experror",229);
                        experrorno:= if symboltype(rank(cs))=exprtermin
                                     then 229 else 228;
                        goto Eabte;
                     end experror
                     else this grammer.detach; !moresymbols;
                     opn:=INEW;

           param:    ! after INEW or IDOT;
%                    if cs <> IIDN then experror(185);
                     if cs <> IIDN then goto E185;
                  end *** cs<>IIDN ***;

                  !*** a primary is found, identifier and new ***;
                  !*** may be followed by a parameter-list    ***;
                  getopt:=false; cs:=opt;
                  if cs=ILFPA then begin
                     opn:=opnx:=if opn=INEW then INEWP else
                                if opn=IIDN then IIDNP else IDOTP;
                     call(coder);
        paramexp:    this grammer.detach; !moresymbols;
                     if ex==none then ex:-new expression;
                     call(ex); !*** inner expression;
                     if ex.wasNOTexpr then begin
                           ParsErr(205); parexprecover end;
                     if cs=ICOMA then begin
        comarecover:    opn:=ICOMA; call(coder); goto paramexp end;
                     if cs <> IRGPA then begin
          rgpaerror:    ! terminate IDN(..) properly;
                        ParsWarn(285);
                     end else
        rgparecover:          this grammer.detach; !moresymbols;
                     if cs<>IBEGI or else not startexprstmt then begin
                        opn:=if opnx = INEWP then ICAPE else IARGE;
                        call(coder);
                     end;
                  end *** ILFPA ***
             else if cs<>IBEGI or else not startexprstmt
                  then call(coder);

         postfix: 
% V               switch(NUL:ICONS) cs begin !*** 0 < cs <= ICONS ***;
% V               when IDOT do begin
                  if cs=IDOT then begin
                     NOTblockprefix:=NOTdesig:=true;
                     this grammer.detach; !moresymbols; opn:=IDOT;
                     lastsymb:=INOTY; goto param;
                  end;

% V               when IQUA do begin
                  if cs=IQUA then begin
                     this grammer.detach; !moresymbols;
%                    if cs <> IIDN then experror(185);
                     if cs <> IIDN then goto E185;
                     opn:=IQUA; call(coder);
                     getopt:=false; cs:=opt;
                     NOTblockprefix:=NOTdesig:=true;
                     lastsymb:=IQUA; goto postfix;
                  end;

% V               when IIS,IIN do begin
                  if cs=IIS or else cs=IIN then begin
                        NOTblockprefix:=NOTdesig:=
                        NOTlhsassig:=NOTrefexpr:=true;
                        opn:=cs;
                        this grammer.detach; !moresymbols;
                        if cs <> IIDN then begin
                  E185:
%+D                        if option(rank('2'))<>NUL
%+D                        then W1("experror",185);
                           experrorno:=185;
                  Eabte:   opn:=IABTE; call(coder);
                  Eset:    wasNOTexpr:= NOTblockprefix:=NOTdesig:=
                                        NOTlhsassig:=NOTrefexpr:=true;
                           if symboltype(rank(cs))=exprtermin
                           then getopt:=true;
                           goto expexit;
                        end experror;
                        call(coder); lastsymb:=INOTY;
                        getopt:=false; cs:=opt;
                  end;
% V               end ***case***;

        operator:
                  switch(NUL:'!5!') symboltype(rank(cs)) begin
                  when relop do goto relopout;
                  when arithop do begin opn:=cs; goto arithopout end;
                  when logop do begin
                     NOTblockprefix:=NOTdesig:=
                     NOTlhsassig:=NOTrefexpr:=true;
                     opn:=cs; call(coder);
                     this grammer.detach; !moresymbols;
                     goto prefix end;
                  end ***case***;

                  !*** cs was no operator;
                  if parnum <> 0 then goto RPARout;

         expexit:
% D               if option(rank('2'))<>NUL then
% D               begin W8("A B C D E F G wasexpr  = ",
% D                        if A then 1 else 0,if B then 1 else 0,
% D                        if C then 1 else 0,if D then 1 else 0,
% D                        if E then 1 else 0,if F then 1 else 0,
% D                        if G then 1 else 0,
% D                        if wasNOTexpr then 0 else 1);
% D               end;
            end exp;

           detach;
  restart: while true do begin
%+D            if option(rank('2'))<>NUL then W1("expr., cs=",rank(cs));
               NOTblockprefix:=NOTdesig:=NOTlhsassig:=NOTrefexpr:=
               wasNOTexpr:=false;

               if symboltype(rank(opt))=exprtermin or else
                 (startexprstmt and then symboltype(rank(opt))=relop)
               then begin
                  if cs=IIDN then opn:=ISIDN else
                  if cs=ICONS then begin
                     NOTblockprefix:=NOTdesig:=true;
                     NOTlhsassig:=NOTrefexpr:=
                                  opdhi<>NUL or else opdlo<>INOTE;
                     opn:=ISCST
                  end else goto EXCALL;
                  call(coder);
                  getopt:=false; cs:=opt;
%-Z %setopt +D
                  detach;
%-Z %setopt -D
                  goto restart;
               end;
%+S            Freq(23):=Freq(23)+1;
       EXCALL:      
               exp(false);
               if lastsymb=IRGPA then NOTrefexpr:=true
          else if lastsymb=IQUA then NOTlhsassig:=NOTrefexpr:=true;
%-Z %setopt +D
               detach;
%-Z %setopt -D
           end ***re-use loop***;

      end expression;

%title *****   G R A M M E R :   m a i n  p r o g r a m   *****

            setbasicrecovery;
            detach;      !*** detach and do initialisations ***;
            ex:-new expression; first:-last:-new module; !curdepth:=1;

            detach; ! and activate scanner;
            goto PARSE;

MarkPush:   !*** markStmt ***;
            if last.blockstatus = stmtnotseen or else
               (! ??? labelused and then;
                stmtwnt=classbody or else stmtwnt=procbody)
            then begin
               last.blockstatus:= lastwasdecl;
               opn:=IDCLE; call(coder);
            end;
%           if lastSTMTnr < linenr then begin
               opn:=IROPD; call(coder);
%              lastSTMTnr:=linenr;
%           end;
    Push:   !*** push new statement ***;
            newstat.caller:-last; last:-last.next:-newstat;

   PARSE:   call(last);
            if last.recovered then begin
               last.recovered:=false; goto PARSE end;
            stmtwnt:=last.stmtreq; labelused:=false;

BlockHead:
%+D         if option(rank('2'))<>NUL then W3("Head, cs=",cs);
            switch(NUL:ICONS) cs begin !*** 0 < cs <= ICONS ***;
            when ISMCL,IELSE,IWHEN,IOTHW,IEOP do begin
                 !*** deliver to last unit ***;
                 goto PARSE;
            end;
            when IIDN do begin
                 switch(NUL:ICONS) opt begin !*** 0 < cs <= ICONS ***;
                 when ICLAS,IRCRD do goto newdcl;
%                when IROPD,NUL do begin skip(236); goto Blockhead end;
                 when NUL do begin skip(236); goto Blockhead end;
                 when ICL do begin
                    labelused:=true;
                    if last.blockstatus = stmtnotseen or else
                       stmtwnt=classbody or else stmtwnt=procbody
                    then begin
                       last.blockstatus:= lastwasdecl;
                       opn:=IDCLE; call(coder);
                    end;
%                   if lastSTMTnr < linenr then begin
%                      opn:=IROPD; call(coder); lastSTMTnr:=linenr;
%                   end;
                    while opt=ICL and then cs=IIDN do begin
                          opn:=ICL; call(coder);
                          DETACH end;
                    goto BlockHead;
                 end;
                 end ***case***;
    XorB:        ! markStmt;
                 if last.blockstatus = stmtnotseen or else
                    stmtwnt=classbody or else stmtwnt=procbody
                 then begin
                    last.blockstatus:= lastwasdecl;
                    opn:=IDCLE; call(coder);
                 end;
%                if lastSTMTnr < linenr then begin
                    opn:=IROPD; call(coder);
%                   lastSTMTnr:=linenr;
%                end;
                 last.stmttype:=basicstmt;
%                - may be changed to innerstmt if this is a split body;
                 ex.startexprstmt:=true; call(ex);
                 ex.startexprstmt:=false;
                 switch(NUL:ICONS) cs begin !*** 0 < cs <= ICONS ***;
%                  when IROPD do begin ! *** skip dummy operator *** ;
%                       NEXTSYMBOL; goto BlockHead;
%                  end;
                 when IBEGI do begin
                    if ex.NOTblockprefix then begin
                       ParsErr(197);
                       ! test if the prefix is a valid statement;
                       ex.startexprstmt:=false; goto testcallorobjgen;
                    end;
                    newstat:-exList;
                    if newstat==none then newstat:-new blockOrComp;
                    ex.startexprstmt:=true; !prefixflag to blockOrComp;
                    !*** push statement ***;
                    newstat.caller:-last; last:-last.next:-newstat;
                    goto PARSE; end;
                 when IEQ do begin !recovery for missing : in assign;
                       ParsWarn(232); cs:=IASSG; goto AssStm end;
                 when IASSG do begin
%+S                 Freq(37):=Freq(37)+1;
       AssStm:      while cs=IASSG do begin
                        if ex.NOTlhsassig then ParsErr(150);
                        opn:=IASSG; call(coder);
                        DETACH;
                        call(ex);
                    end;
                    if ex.wasNOTexpr then skip(199);
                    opn:=IASGE; call(coder);
                    goto PARSE;
                    end;
                 when IDENO do begin
%+S                 Freq(38):=Freq(38)+1;
                    while cs=IDENO do begin
                        if ex.NOTrefexpr then ParsErr(200);
                        opn:=IDENO; call(coder);
                        detach; !get symbols;
                        call(ex);
                    end;
                    if ex.wasNOTexpr then ParsErr(201);
                    opn:=IASGE; call(coder);
                    goto PARSE;
                    end;
                 when NONE do begin
  testcallorobjgen: if ex.NOTrefexpr then ParsErr(202);
%+S                 Freq(39):=Freq(39)+1;
                    opn:=IESTM; call(coder);
                    end;
                 end ***case cs***;;
                 goto PARSE;
            end;
            when IBOOL,ICHAR,ISHOR,IINTG,IREAL,ILONG,IREF,ITEXT
                 do begin
                 readtypespec;
%+K      TstDcl:
                 if cs <> IIDN then begin
                    if cs=IPROC then goto newdcl;
                    if cs=IARRA then goto arrdcl;
                    readtype:=NUL; skip(185); goto BlockHead;
                 end;
             d1: if cs <> IIDN then begin skip(185); goto BlockHead end;
                 ! markDecl;
                 if not last.isblocklike or else
                    last.blockstatus=lastwasstmt
                 then begin
                    ParsErr(289); last.blockstatus:=stmtnotseen; end;
                 last.stmttype:=declunit;
% %                if lastDECLnr < linenr then begin
%                     opn:=ICOMN; call(coder);
% %                   lastDECLnr:=linenr end;
                 opn:=IDCLI; call(coder);
                 getopt:=false; cs:=opt;
%+Z              if option(rank('I'))<>NUL then lookforstring else
                 if cs=IEQ then begin !constant;
      !FIX;         if readtype=IREAL or readtype=ILONG then begin
      !FIX;            cs:=IASSG; goto ROattr end;
                    opn:=ITO; call(coder);
                    detach; !get symbols;
                    call(ex); opn:=ISMCL; call(coder);
                    if ex.wasNOTexpr then skip(188);
                 end
            else if cs = IASSG or else cs = IDENO then begin
                    if not SportOK then ParsWarn(254);
                    !read only attribute decl.;
%                   if lastDECLnr < linenr then begin
                       opn:=ICOMN; call(coder);
%                      lastDECLnr:=linenr end;
      ROattr:       opn:=IIDN; call(coder); !lhs of init. assign;
                    opn:=IFASG; opdlo:=cs; call(coder);
                    detach; !get symbols;
                    call(ex); opn:=IASGE; call(coder);
                    if ex.wasNOTexpr then skip(188);
                 end
            else if cs = ILFPA then begin
                    if Simuletta then begin !*** assume repetition ***;
                       detach; !get symbols;
                       if opt <> IRGPA then begin
                          ParsWarn(227); goto A2 end;
                       if optx <> IINTG then begin
                          ! IDCLI=>DCLA, lower bound zero, BNDE
                            done by IACTE;
                    reper1:
%                         if lastDECLnr < linenr then begin
                             opn:=ICOMN; call(coder);
%                            lastDECLnr:=linenr end;
                          opn:=IACTE; call(coder);
                          call(ex);
	                  if ex.wasNOTexpr then goto A30; goto A21;
                       end;
                       repcount:=nameof(opdhi,opdlo).getint+1;
                       if repcount<=0 or else repcount>repeatMax
                       then goto reper1;
                       opn:=ISIMU; call(coder);
                       detach; !get symbols; goto testSmcl;
                    end;
                    getopt:=false; ParsWarn(227); goto A1;
                 end;
                 if cs=ICOMA then begin
                    detach; !get symbols; goto d1 end;
                 readtype:=NUL;
   testSmcl:
%  --------      while cs<>ISMCL and then cs<>IEOP do Skip(300);
                 if cs<>ISMCL and then cs<>IEOP then skip(300)
                 else detach; !get symbols;
                 goto BlockHead;
            end;
            when IARRA do begin
                 if stmtwnt=outermost then ParsErr(216);
   arrdcl:       ! markDecl;
                 if not last.isblocklike or else
                    last.blockstatus=lastwasstmt
                 then begin
                    ParsErr(289); last.blockstatus:=stmtnotseen; end;
                 last.stmttype:=declunit;
%                if lastDECLnr < linenr then begin
                    opn:=ICOMN; call(coder);
%                   lastDECLnr:=linenr end;
                 if readtype=NUL then begin
                    opn:=IREAL; call(coder) end;
                 readtype:=NUL;
                 cs:=ICOMA;
                 while cs=ICOMA do begin
                    detach; !get symbols;
                    if cs <> IIDN then begin
                       skip(185); goto BlockHead end;
             A1:    getopt:=false; cs:=opt;
%+Z                 if option(rank('I'))<>NUL then lookforstring;
                    opn:=IDCLA; call(coder);
                    if cs<>ILFPA then begin
                       if cs=ICOMA then begin
                          detach; !get symbols;
                          if cs = IIDN then goto A1; skip(185) end
                       else skip(187);
                       goto A3;
                    end;
                    !***  cs=ILFPA  ***;
             A2:    if notBoundPair(IBNDE)=0 then begin
             A21:      if cs=ICOMA then begin
                          opn:=IDIME; call(coder); goto A2 end;
%                      if cs=IEQ then repeatedConst else begin
                          opn:=IARDE; call(coder);
%                      end;
                    end else begin
             A30:      skip(0);
             A3:       opn:=IARDE; call(coder);
                       goto BlockHead;
                    end;
                    if cs<>IRGPA then ParsErr(186)
                    else detach; !get symbols;
                 end list with dimensions;
                 goto testSmcl;
            end;
            when ISWIT do begin
                 detach; !get symbols;
                 if cs <> IIDN then begin
                    skip(185); goto BlockHead end;
                 if stmtwnt=outermost then ParsErr(216);
                 ! markDecl;
                 if not last.isblocklike or else
                    last.blockstatus=lastwasstmt
                 then begin
                    ParsErr(289); last.blockstatus:=stmtnotseen; end;
                 last.stmttype:=declunit;
%                if lastDECLnr < linenr then begin
                    opn:=ICOMN; call(coder);
%                   lastDECLnr:=linenr end;
                 opn:=IDCLS; call(coder);
                 getopt:=false; cs:=opt;
%+Z              if option(rank('I'))<>NUL then lookforstring;
                 if cs <> IASSG then ParsErr(190) else
            SW1:    detach; !get symbols;
                 call(ex);
                 if ex.wasNOTexpr then syntaxerror(205) else
                 if ex.NOTdesig then ParsErr(191);
                 opn:=ISWEE; call(coder);
                 if cs = ICOMA then goto SW1;
                 opn:=ISWDE; call(coder);
                 goto TestSmcl;
            end;
            when ICLAS,IRCRD,IPROC,IEXTR do begin
    newdcl:      newstat:-deList;
                 if newstat==none then newstat:-new declaration;
                 !*** push statement ***;
                 newstat.caller:-last; last:-last.next:-newstat;
                 goto PARSE;
            end;
            when INEW,ITHIS,ICONS,ILFPA do begin
                 goto XorB;
            end;
            when IBEGI do begin
                 last.stmttype:=basicstmt;
%                - may be changed to innerstmt if this is a split body;
                 newstat:-exList;
                 if newstat==none then newstat:-new blockOrComp;
                 if not labelused then begin
                    if stmtwnt<>procbody and then stmtwnt<>classbody
                    then goto MarkPush;
                 end;
                 if last.isblocklike and then
                    last.blockstatus=stmtnotseen
                 then begin
                    last.blockstatus:=lastwasdecl;
                    if stmtwnt<>outermost or else not separatecomp
                    then begin opn:=IDCLE; call(coder) end;
                 end;
                 !*** push statement ***;
                 newstat.caller:-last; last:-last.next:-newstat;
                 goto PARSE;
            end;
            when IWHIL do begin
%+S              Freq(25):=Freq(25)+1;
                 newstat:-whList;
                 if newstat==none then newstat:-new whilstat;
                 goto MarkPush;
            end;
            when IINSP do begin
%+S              Freq(26):=Freq(26)+1;
                 newstat:-itList;
                 if newstat==none then newstat:-new inspectstat;
                 goto MarkPush;
            end;
            when ICASE do begin
%+S              Freq(27):=Freq(27)+1;
                                      newstat:-new casestat;
%                if caList==none then newstat:-new casestat
%                else begin newstat:-caList; caList:-none end;
                 goto MarkPush;
            end;
            when IFOR  do begin
%+S              Freq(28):=Freq(28)+1;
                 newstat:-foList;
                 if newstat==none then newstat:-new forstat;
                 goto MarkPush;
            end;
            when IIF do begin
%+S              Freq(24):=Freq(24)+1;
                 newstat:-ifList;
                 if newstat==none then newstat:-new ifstat;
                 goto MarkPush;
            end;
            when IGOTO do begin
%+S              Freq(29):=Freq(29)+1;
                 !*** goto statement, treat it inline ***;
                 markStmt;
%+D              if option(rank('2'))<>NUL then W0("gotostat");
                 last.stmttype:=basicstmt;
                 opn:=IGOTO; call(coder);
                 detach; !get symbols;
                 call(ex);
                 if ex.NOTdesig then syntaxerror(191);
                 opn:=IGOE; call(coder);
                 goto PARSE;
            end;
            when IINNE do begin
%+S              Freq(30):=Freq(30)+1;
                 !*** inner statement, treat it inline ***;
%+D              if option(rank('2'))<>NUL then W1("innerstat",rank(stmtwnt));
                 if stmtwnt = stmtorinner then begin
%-Z %IMPLNONE OFF
                    inspect last qua blockOrComp do begin
                       if innerseen then ParsErr(203)
                       else begin
                          stmttype:=basicstmt;
                          !*** always mark statement (even empty) ***;
                          if last.isblocklike and then
                             last.blockstatus=stmtnotseen 
                          then begin
                             last.blockstatus:=lastwasdecl;
%                            if stmtwnt<>outermost or not separatecomp
%                            then begin opn:=IDCLE; call(coder) end;
                             opn:=IDCLE; call(coder);
                          end;
%                         if lastSTMTnr < linenr then begin
                             opn:=IROPD; call(coder);
%                            lastSTMTnr:=linenr;
%                         end;
                          opdlo:=if blockstatus=lastwasstmt or else
                                 labelused then '!1!' else NUL;
                          opn:=IINNE; call(coder); innerseen:=true;
                       end;
                    end inspect;
                 end else ParsWarn(287);
                 detach; !get symbols;
                 goto PARSE;
            end;
            when IREAC do begin
                 reac:=ITRUE; goto actv end;
            when IACTV do begin
%+S              Freq(31):=Freq(31)+1;
                 reac:=IFALS;
       actv:     !*** (re)activate statement, treat it inline ***;
                 markStmt;
%+D              if option(rank('2'))<>NUL then W0("activate");
                 last.stmttype:=basicstmt;
             inspect new codebuffer("$act$") do begin
                 if false then begin ! no output if error;
       actError:    !***terminate; syntaxerror(205); goto PARSE end;
                 opn:=IIDNP; call(this codebuffer);
                 this grammer.detach; !moresymbols; call(ex);
                 if ex.wasNOTexpr then goto actError;
 !insert reac;   opn:=ICOMA; call(this codebuffer);
                 opn:=ISCST; opdlo:=reac;
                 !opdhi:=NUL; optx:=IBOOL; call(this codebuffer);
                 if cs=IAT or cs=IDELA then begin
 !add code;         opn:=ICOMA; call(this codebuffer);
                    opn:=ISCST;opdlo:=if cs=IDELA then ITRUE else IFALS;
                    !opdhi:=NUL; optx:=IBOOL; call(this codebuffer);
 !add expr2;        opn:=ICOMA; call(this codebuffer);
                    this grammer.detach; !moresymbols; call(ex);
                    if ex.wasNOTexpr then goto actError;
 !add prio;         opn:=ICOMA; call(this codebuffer);
                    opn:=ISCST; opdlo:=if cs=IPRIO then ITRUE else IFALS;
                    !opdhi:=NUL; optx:=IBOOL; call(this codebuffer);
 !activate_2;       simsymbol:-"__2";
                 end
            else if cs=IBEFO or cs=IAFTR then begin
 !insert code;      opn:=ICOMA; call(this codebuffer);
                    opn:=ISCST; opdlo:=if cs=IAFTR then ITRUE else IFALS;
                    !opdhi:=NUL; optx:=IBOOL; call(this codebuffer);
                    opn:=ICOMA; call(this codebuffer);
                    this grammer.detach; !moresymbols; call(ex);
                    if ex.wasNOTexpr then goto actError;
 !activate_1;       simsymbol:-"__1";
                 end
            else begin !simple (re)activate P ;
 !activate_3;       simsymbol:-"__3";
                 end;
 !set proc;      DEFIDENT; curelt:-firstelt.next;
                 curelt.opdhii:=hashhi; curelt.opdloo:=hashlo;
                 terminate;
                 opn:=IARGE; call(coder); opn:=IESTM; call(coder);
                 if cs=IPRIO then
                    this grammer.detach; !moresymbols;
               end inspect codebuffer;
               goto PARSE;
            end;
            when IEND do begin
                 if last.isblocklike and then
                    last.blockstatus=stmtnotseen
                 then begin
                    last.blockstatus:=lastwasdecl;
                    if stmtwnt<>outermost or else not separatecomp
                    then begin opn:=IDCLE; call(coder) end;
                 end;
% --- SCODMAIN   if lastSTMTnr < linenr then begin
% --- SCODMAIN      opn:=IROPD; call(coder); lastSTMTnr:=linenr;
% --- SCODMAIN   end;
                 goto PARSE;
            end;
            when NUL do begin ! *** skip dummy operator *** ;
                 NEXTSYMBOL; goto BlockHead;
            end;
%+K         when IPRIO do begin
%+K              detach; !get symbols;
%+K              readtypespec;
%+K              if cs=IPROC then begin
%+K                 newstat:-new declaration;
%+K                 newstat qua declaration.priorseen:=true;
%+K                 goto Push end;
%+K              !PRIOR is an error - skip it;
%+K              ParsWarn(272); goto TstDcl;
%+K         end;
            when NONE do begin
                 !*** ERROR - replace by semicolon ??? ;
                 ParsErr(202); cs:=ISMCL;
                 goto PARSE;
            end;
            end ***case***;

      end ***grammer***;

end PARSER;
